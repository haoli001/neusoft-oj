-- MySQL dump 10.13  Distrib 5.5.43, for debian-linux-gnu (i686)
--
-- Host: localhost    Database: jolold
-- ------------------------------------------------------
-- Server version	5.5.43-0ubuntu0.12.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `source_code_new`
--

DROP TABLE IF EXISTS `source_code_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `source_code_user` (
  `solution_id` int(11) NOT NULL,
  `source` text NOT NULL,
  PRIMARY KEY (`solution_id`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `source_code_new`
--

LOCK TABLES `source_code_user` WRITE;
/*!40000 ALTER TABLE `source_code_new` DISABLE KEYS */;
INSERT INTO `source_code_user` VALUES (1,'#include <stdio.h>\r\n#include <string.h>\r\n\r\nint asc()\r\n{\r\n	int a[128];\r\n	int i = 0,count = 0;\r\n	while(scanf(\"%d\",&a[i++]) !=-1)\r\n	{\r\n		count++;\r\n	}\r\n\r\n	for(i = 0;i<count;i++)\r\n	{\r\n		printf(\"%c\",a[i]);\r\n	}\r\n	printf(\"\\n\");	\r\n	return 0;\r\n}\r\nint main()\r\n{\r\n	asc();\r\n	return 0;\r\n}'),(2,'main(){for(int c;scanf(\"%d\",&c)>0;putchar(c));}'),(3,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\nint sushu(int a)\r\n{\r\n    int m = sqrt(a);\r\n    int i;\r\n    for(i=2;i<=m;++i)\r\n        if(a%i==0) return 0;\r\n    return 1;\r\n}\r\nint main()\r\n{\r\n    int i,x;\r\n    scanf(\"%d\",&x);\r\n    for(i=2;i<x;i++)\r\n        {\r\n            if(sushu(i)!=0)\r\n                {\r\n                    printf(\"%d\",i);\r\n                    printf(\"\\n\");\r\n                }\r\n        }\r\n    return 0;\r\n}\r\n'),(4,'main(){int i=2,j,n;scanf(\"%d\",&n);for(;j<n;j=i++){for(;i%--j;);if(j<2)printf(\"%d\\n\",i);}}'),(5,'#include\"stdio.h\"\r\nint main()\r\n{int a,b;\r\n	while(scanf(\"%d %d\",&a,&b)!=EOF)\r\nprintf(\"%d\\n\",a+b);\r\n	return 0;\r\n\r\n}'),(6,'main(){for(int a,b;scanf(\"%d%d\",&a,&b)>0;)printf(\"%d\\n\",a+b);}'),(7,'#include <cstdio>\r\nusing namespace std;\r\nint main(){\r\n    int t(0);\r\n    scanf(\"%d\",&t);\r\n    for(int i=0;i<t;++i){\r\n        int a,b;\r\n        scanf(\"%d%d\",&a,&b);\r\n        printf(\"%d\\n\",a+b);\r\n    }\r\n    return 0;\r\n}'),(8,'main(){int i,n,a,b;scanf(\"%d\",&n);for(i=0;i<n;i++){scanf(\"%d %d\",&a,&b);printf(\"%d\\n\",a+b);}}'),(9,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf(\"%d %d\",&a,&b)!=EOF)\r\n	{\r\n		if(a+b!=0)\r\n		printf(\"%d\\n\",a+b);\r\n	}\r\n	return 0;\r\n}\r\n'),(10,'main(){int a,b;for(;;){scanf(\"%d %d\",&a,&b);if(!(a|b))break;printf(\"%d\\n\",a+b);}}'),(11,'#include<stdio.h>\r\nint main()\r\n{ int i,line,sum,a[30];\r\n  while(scanf(\"%d\",&line)!=EOF)\r\n    { if(line!=0)\r\n        { sum=0;\r\n          for(i=0;i<line;i++)\r\n           { scanf(\"%d\",&a[i]);\r\n             sum+=a[i];\r\n           }\r\n          printf(\"%d\\n\",sum);\r\n        }\r\n    }\r\n  return 0;\r\n}\r\n'),(12,'main(){int i,m,n,s;for(;;){s=0;scanf(\"%d\",&m);if(!m)break;for(i=0;i<m;i++){scanf(\"%d\",&n);s+=n;}printf(\"%d\\n\",s);}}'),(13,'#include <stdio.h>\r\n#include <math.h>\r\n#include <malloc.h>\r\n\r\n#include <stdlib.h>\r\nint add5(int n)\r\n{\r\n	int a[16],b[16],i = 0,count= 0,j = 0;\r\n	int *p = NULL;\r\n	p = (int*)malloc(sizeof(int) * (n+1));\r\n	int num;\r\n	p[j] = 0;\r\n	while( scanf(\"%d\",&num) != -1 && count < n)\r\n	{\r\n		\r\n		for(i = 0;i < num;i++)\r\n		{\r\n			\r\n			scanf(\"%d\",&a[i]);\r\n			p[j] = p[j] + a[i];\r\n		}\r\n		j = j+1;\r\n		p[j] = 0;\r\n		count += 1;\r\n\r\n	}\r\n\r\n\r\n	for( j = 0;j < count;j++)\r\n	{\r\n		printf(\"%d\\n\",p[j]);\r\n	}\r\n\r\n	free(p);\r\n	return 0;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int num;\r\n	scanf(\"%d\",&num);\r\n	add5(num);\r\n	return 0;\r\n}'),(14,'main(){int i,j,m,n,t,s;scanf(\"%d\",&t);for(i=0;i<t;i++){s=0;scanf(\"%d\",&m);if(!m)break;for(j=0;j<m;j++){scanf(\"%d\",&n);s+=n;}printf(\"%d\\n\",s);}}'),(15,'#include<stdio.h>\r\nint main()\r\n{\r\nint a,b,c;\r\nwhile(scanf(\"%d\",&a)!=EOF)\r\n{\r\nc=0;\r\nwhile(a--)\r\n{\r\nscanf(\"%d\",&b);\r\nc+=b;\r\n}\r\nprintf(\"%d\\n\",c);\r\n}\r\nreturn 0;\r\n}'),(16,'main(){int i,m,n,s;while(scanf(\"%d\",&m)==1){s=0;for(i=0;i<m;i++){scanf(\"%d\",&n);s+=n;}printf(\"%d\\n\",s);}}'),(17,'#include <stdio.h>\r\n#include <math.h>\r\n#include <malloc.h>\r\n#include <stdlib.h>\r\nint add7()\r\n{\r\n	int a,b,i;\r\n	int *p = NULL,count = 0;\r\n	p = (int*)malloc(sizeof(int) * 16);\r\n	for(i = 0;i< 2 ;i++)\r\n	{\r\n		scanf(\"%d\",&a);\r\n		scanf(\"%d\",&b);\r\n		p[i] = a + b;\r\n		count = count + 1;\r\n	}\r\n\r\n	for( i = 0;i < 2;i++)\r\n	{\r\n		printf(\"%d\\n\",p[i]);\r\n		printf(\"\\n\");\r\n	}\r\n\r\n	free(p);\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int num;\r\n	//scanf(\"%d\",&num);\r\n	add7();\r\n	return 0;\r\n}'),(18,'main(){int a,b;while(scanf(\"%d%d\",&a,&b)==2){printf(\"%d\\n\\n\",a+b);}}'),(19,'#include <stdio.h>\r\n#include <math.h>\r\n#include <malloc.h>\r\n#include <stdlib.h>\r\n\r\nint add8(int n)\r\n{\r\n	int a[16],b[16],i = 0,count= 0,j = 0;\r\n	int *p = NULL;\r\n	p = (int*)malloc(sizeof(int) * 16);\r\n	int num;\r\n	p[j] = 0;\r\n	while( scanf(\"%d\",&num) != -1)\r\n	{\r\n		\r\n		for(i = 0;i < num;i++)\r\n		{\r\n			\r\n			scanf(\"%d\",&a[i]);\r\n			p[j] = p[j] + a[i];\r\n		}\r\n		j = j+1;\r\n		p[j] = 0;\r\n		count += 1;\r\n\r\n	}\r\n\r\n\r\n	for( j = 0;j < count;j++)\r\n	{\r\n		printf(\"%d\\n\",p[j]);\r\n		printf(\"\\n\");\r\n	}\r\n\r\n	free(p);\r\n	return 0;\r\n}\r\nint main()\r\n{\r\n	int num;\r\n	scanf(\"%d\",&num);\r\n	add8(num);\r\n	return 0;\r\n}'),(20,'main(){int i,j,m,n,t,s;scanf(\"%d\",&t);for(i=0;i<t;i++){s=0;scanf(\"%d\",&m);if(!m)break;for(j=0;j<m;j++){scanf(\"%d\",&n);s+=n;}printf(\"%d\\n\\n\",s);}}'),(21,'#include<stdio.h>\r\nint main()\r\n{\r\n	char str[100];\r\n	int i,len,n;\r\n	gets(str);\r\n	len=strlen(str);\r\n	for(i=len-1;i>=0;i--)\r\n	{\r\n		printf(\"%c\",str[i]);\r\n	}\r\n	return 0;\r\n}'),(22,'int main() \r\n{printf(\"tneduts a ma I\");}'),(23,'#include\"stdio.h\"\r\nint main()\r\n{\r\n char a[1000];\r\n    int n,i;\r\n    scanf(\"%d\",&n);\r\n     gets(a);\r\n while(gets(a)!=0)\r\n    \r\n {\r\n  n--;\r\n \r\n  if(n>=0)\r\n \r\n  {\r\n   \r\n   for(i=0;a[i]!=\'\\0\';i++)\r\n    \r\n    printf(\"%c\",a[i]);\r\n   \r\n   printf(\"\\n\");\r\n   printf(\"\\n\");\r\n \r\n  }\r\n \r\n  else\r\n \r\n  {\r\n   for(i=0;a[i]!=\'\\0\';i++)\r\n  \r\n    if(a[i]==\' \')\r\n    {\r\n     printf(\"\\n\");\r\n\r\n     printf(\"\\n\");\r\n    }\r\n\r\n     \r\n    else printf(\"%c\",a[i]);\r\n \r\n    printf(\"\\n\");\r\n    printf(\"\\n\");\r\n  }\r\n \r\n }\r\n \r\n return 0;\r\n}\r\n'),(24,'main(){int n;char s[1000];scanf(\"%d\",&n);getchar();while(n--){scanf(\"%[^\\n]%*c\",s);printf(\"%s\\n\\n\",s);}while(scanf(\"%s\",s)>0)printf(\"%s\\n\\n\",s);}'),(25,'#include<stdio.h>\r\n#include<stdlib.h>\r\nint f(int num)\r\n{\r\n	int count=0;\r\n	while (num!=1)\r\n	{\r\n		if (num%2==0)\r\n		{\r\n			num/=2;\r\n		}\r\n		else\r\n		{\r\n			num=num*3+1;\r\n		}\r\n		count++;\r\n	}\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int from,to;\r\n	int oldFrom,oldTo;\r\n	int temp,temp2;\r\n	while (scanf (\"%d%d\",&from,&to)!=EOF)\r\n	{\r\n		oldFrom=from;\r\n		oldTo=to;\r\n		int maxNum=0,ans=0;\r\n		if (from>to) {temp=from;from=to;to=temp;}\r\n		for (int i=from;i<=to;++i)\r\n		{\r\n			temp2=f(i);\r\n			if (temp2>maxNum) {maxNum=temp2;ans=i;}\r\n		}\r\n		printf (\"%d %d %d\\n\",oldFrom,oldTo,maxNum+1);\r\n	}\r\n	return 0;\r\n}'),(26,'main(){int a,b,i,n,r,m;while(scanf(\"%d %d\",&a,&b)==2){printf(\"%d %d \",a,b);m=0;if(a>b){a^=b;b^=a;a^=b;}for(i=a;i<=b;i++){r=1;n=i;while(n!=1){r++;n=n%2?n*3+1:n/2;}if(m<r)m=r;}printf(\"%d\\n\",m);}}'),(27,'#include <stdio.h>\r\nint main()\r\n{\r\n	int x,y,t=1,i,m,n;\r\n	char a[100][100]={0},b[100][100]={0};\r\n	while(scanf(\"%d %d\",&x,&y)!=EOF)\r\n	{\r\n		if (x==0 && y==0)\r\n			break;\r\n		else\r\n		{\r\n			for(i=0;i<y;i++)\r\n				scanf(\"%s\",a[i]);\r\n				printf(\"Field #%d:\\n\",t);\r\n				t++;\r\n			for(n=0;n<y;n++)\r\n				for(m=0;m<x;m++)\r\n					if(a[m][n]==\'*\')\r\n						b[m][n]=\'*\';\r\n					else\r\n						b[m][n]=\'0\';\r\n			for(n=1;n<y-1;n++)\r\n				for(m=1;m<x-1;m++)\r\n					if(b[m][n]==\'*\')\r\n					{\r\n						if(b[m-1][n-1]!=\'*\')\r\n							b[m-1][n-1]++;\r\n						if(b[m][n-1]!=\'*\')\r\n							b[m][n-1]++;\r\n						if(b[m+1][n-1]!=\'*\')\r\n							b[m+1][n-1]++;\r\n						if(b[m-1][n]!=\'*\')\r\n							b[m-1][n]++;\r\n						if(b[m+1][n]!=\'*\')\r\n							b[m+1][n]++;\r\n						if(b[m-1][n+1]!=\'*\')\r\n							b[m-1][n+1]++;\r\n						if(b[m][n+1]!=\'*\')\r\n							b[m][n+1]++;\r\n						if(b[m+1][n+1]!=\'*\')\r\n							b[m+1][n+1]++;\r\n					}\r\n			if(b[0][0]==\'*\')\r\n			{\r\n				if(b[1][1]!=\'*\')\r\n					b[1][1]++;\r\n				if(b[0][1]!=\'*\')\r\n					b[0][1]++;\r\n				if(b[1][0]!=\'*\')\r\n					b[1][0]++;\r\n			}\r\n			if(b[x-1][0]==\'*\')\r\n			{\r\n				if(b[x-2][1]!=\'*\')\r\n					b[x-2][1]++;\r\n				if(b[x-1][1]!=\'*\')\r\n					b[x-1][1]++;\r\n				if(b[x-2][0]!=\'*\')\r\n					b[x-2][0]++;\r\n			}\r\n			if(b[0][y-1]==\'*\')\r\n			{\r\n				if(b[1][y-2]!=\'*\')\r\n					b[1][y-2]++;\r\n				if(b[0][y-2]!=\'*\')\r\n					b[0][y-2]++;\r\n				if(b[1][y-1]!=\'*\')\r\n					b[1][y-1]++;\r\n			}\r\n			if(b[x-1][y-1]==\'*\')\r\n			{\r\n				if(b[x-2][y-2]!=\'*\')\r\n					b[x-2][y-2]++;\r\n				if(b[x-1][y-2]!=\'*\')\r\n					b[x-1][y-2]++;\r\n				if(b[x-2][y-1]!=\'*\')\r\n					b[x-2][y-1]++;\r\n			}\r\n			for(m=1;m<x-1;m++)\r\n			{\r\n				if(b[m][0]==\'*\')\r\n				{\r\n					if(b[m-1][0]!=\'*\')\r\n						b[m-1][0]++;\r\n					if(b[m-1][1]!=\'*\')\r\n						b[m-1][1]++;\r\n					if(b[m][1]!=\'*\')\r\n						b[m][1]++;\r\n					if(b[m+1][0]!=\'*\')\r\n						b[m+1][0]++;\r\n					if(b[m+1][1]!=\'*\')\r\n						b[m+1][1]++;\r\n				}\r\n				if(b[m][y-1]==\'*\')\r\n				{\r\n					if(b[m-1][y-1]!=\'*\')\r\n						b[m-1][y-1]++;\r\n					if(b[m-1][y-2]!=\'*\')\r\n						b[m-1][y-2]++;\r\n					if(b[m][y-2]!=\'*\')\r\n						b[m][y-2]++;\r\n					if(b[m+1][y-1]!=\'*\')\r\n						b[m+1][y-1]++;\r\n					if(b[m+1][y-2]!=\'*\')\r\n						b[m+1][y-2]++;\r\n				}\r\n			}\r\n			for(n=1;n<x-1;n++)\r\n			{\r\n				if(b[0][n]==\'*\')\r\n				{\r\n					if(b[0][n-1]!=\'*\')\r\n						b[0][n-1]++;\r\n					if(b[1][n-1]!=\'*\')\r\n						b[1][n-1]++;\r\n					if(b[1][n]!=\'*\')\r\n						b[1][n]++;\r\n					if(b[0][n+1]!=\'*\')\r\n						b[0][n+1]++;\r\n					if(b[1][n+1]!=\'*\')\r\n						b[1][n+1]++;\r\n				}\r\n				if(b[x-1][n]==\'*\')\r\n				{\r\n					if(b[x-2][n]!=\'*\')\r\n						b[x-2][n]++;\r\n					if(b[x-2][n-1]!=\'*\')\r\n						b[x-2][n-1]++;\r\n					if(b[x-2][n+1]!=\'*\')\r\n						b[x-2][n+1]++;\r\n					if(b[x-1][n+1]!=\'*\')\r\n						b[x-1][n+1]++;\r\n					if(b[x-1][n-1]!=\'*\')\r\n						b[x-1][n-1]++;\r\n				}\r\n			}\r\n			\r\n			for(n=0;n<y;n++)\r\n			{\r\n				printf(\"%s\\n\",b[n]);\r\n			}\r\n			for(m=0;m<x;m++)\r\n				for(n=0;n<y;n++)\r\n				{\r\n					b[m][n]=\'\\0\';\r\n					a[m][n]=\'\\0\';\r\n				}\r\n			printf(\"\\n\");\r\n			x=0;\r\n			y=0;\r\n			i=0;\r\n			m=0;\r\n			n=0;\r\n			\r\n		}\r\n	}\r\n	return 0;\r\n}'),(28,'#include<string.h>\r\nint d(char*m,int y,int l){int i,c=0,a[9]={l-y-1,l-y,l-y+1,l-1,-1,l+1,l+y-1,l+y,l+y+1};if(l<y)a[0]=a[1]=a[2]=-1;else if(l+y>strlen(m))a[6]=a[7]=a[8]=-1;if(!(l%y))a[0]=a[3]=a[6]=-1;else if(l%y==y-1)a[2]=a[5]=a[8]=-1;for(i=0;i<9;i++){if(a[i]<0)continue;if(m[a[i]]==\'*\')c++;}return c;}main(){int i,j,x,y,c=0;char m[10000],r[10000];for(;;){scanf(\"%d %d\",&x,&y);if(!(x|y))break;c++;for(i=0;i<x;i++)scanf(\"%s\",m+i*y);for(i=0;i<strlen(m);i++)if(m[i]==\'*\')r[i]=\'*\';else r[i]=\'0\'+d(m,y,i);printf(\"Field #%d:\\n\",c);for(i=0;i<x;i++){for(j=0;j<y;j++)printf(\"%c\",r[j+i*y]);printf(\"\\n\");}printf(\"\\n\");}}'),(29,'#include<stdio.h>\r\nvoid sx(int n)\r\n{\r\n	int i,j,x,y=0;\r\n	for(i=0;i<n;i++)\r\n	{\r\n		y+=(i-1);\r\n		if(y<0) y=0;\r\n		x=y;\r\n		for(j=1;j<n-i+1;j++)\r\n		{\r\n			x+=(j+i);\r\n			if(j==n-i) printf(\"%d\",x);\r\n			else printf(\"%d \",x);\r\n		}\r\n		printf(\"\\n\");\r\n	}\r\n\r\n}\r\nmain()\r\n{\r\n	int n=5;\r\n	sx(n);\r\n}\r\n'),(30,'#include<stdio.h>\r\nint main()\r\n{\r\nint n;\r\nscanf(\"%d\",&n);\r\nprintf(\"1 3 6 10 15\\n2 5 9 14\\n4 8 13\\n7 12\\n11\\n\");\r\nreturn 0;\r\n}'),(31,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cmath>\r\n#include<cstring>\r\n#define zero(a) ((fabs(a)<eps))\r\n#define equal(a,b) (zero(((a)-(b))))\r\nconst int ppo[]= {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192};\r\nconst double eps=1e-12;\r\nint plan[15][15];\r\ndouble p[15],b[15];\r\ndouble f[14][14][8192];\r\nint head;\r\nint que[15];\r\nint next[15][8192];\r\nvoid prepare()\r\n{\r\n    memset(p,0,sizeof(p));\r\n}\r\nvoid calcplan(int now,int state)\r\n{\r\n    double maxt=0;\r\n    for(int l=1; l<=head; l++)\r\n        if (que[l]!=now)\r\n        {\r\n            int kill=que[l];\r\n            int k=next[now][state];\r\n            if (k==kill) k=next[k][state];\r\n            double com=f[now][k][state^ppo[kill-1]];\r\n            if (equal(com,maxt))\r\n            {\r\n                plan[now][0]++;\r\n                plan[now][plan[now][0]]=kill;\r\n            }\r\n            else if (com>maxt)\r\n            {\r\n                plan[now][0]=1;\r\n                maxt=com;\r\n                plan[now][1]=kill;\r\n            }\r\n        }\r\n}\r\nvoid ready()\r\n{\r\n    for (int state=1; state<ppo[13]; state++)\r\n    {\r\n        head=0;\r\n        memset(que,0,sizeof(que));\r\n        int stmp=state;\r\n        for(int i=1; i<=13; i++)\r\n        {\r\n            if (stmp & 1==1)\r\n            {\r\n                head++;\r\n                que[head]=i;\r\n                next[que[head-1]][state]=que[head];\r\n            };\r\n            stmp=stmp>>1;\r\n        }\r\n        next[que[head]][state]=que[1];\r\n        next[0][state]=0;\r\n    }\r\n}\r\nint main()\r\n{\r\n    int task=0;\r\n    ready();\r\n    scanf(\"%d\",&task);\r\n    for(; task>0; task--)\r\n    {\r\n        prepare;\r\n        int n;\r\n        int i;\r\n        scanf(\"%d\",&n);\r\n        for(i=1; i<=n; i++)\r\n        {\r\n            scanf(\"%lf\",&p[i]);\r\n            p[i]/=100;\r\n        }\r\n        int state;\r\n        for(state=1; state<ppo[n]; state++)\r\n        {\r\n            memset(plan,0,sizeof(plan));\r\n            memset(que,0,sizeof(que));\r\n            head=0;\r\n            memset(b,0,sizeof(b));\r\n            int stmp=state;\r\n            int j=0;\r\n            double tot=1;\r\n            for(i=1; i<=n; i++)\r\n            {\r\n                if (stmp & 1==1)\r\n                {\r\n                    head++;\r\n                    que[head]=i;\r\n                    tot=tot*(1-p[i]);\r\n                };\r\n                stmp=stmp>>1;\r\n            }\r\n            if (head==1)\r\n            {\r\n                f[que[1]][que[1]][state]=1;\r\n                continue;\r\n            }\r\n\r\n            tot=1-tot;\r\n            for(i=1; i<=head; i++)\r\n                calcplan(que[i],state);\r\n            for(int p1=1; p1<=head; p1++)\r\n            {\r\n                i=que[p1];\r\n                int p2;\r\n                for(  p2=1; p2<=head; p2++)\r\n                {\r\n                    j=que[p2];\r\n                    double sum=0;\r\n                    for(int p3=1; p3<=plan[j][0]; p3++)\r\n                    {\r\n                        int k=next[j][state];\r\n                        if (k==plan[j][p3]) k=next[k][state];\r\n                        sum+=f[i][k][state^ppo[plan[j][p3]-1]];\r\n                    }\r\n                    sum/=plan[j][0];\r\n                    b[p2]=sum*p[j];\r\n                }\r\n                for(  p2=1; p2<=head; p2++)\r\n                {\r\n                    j=que[p2];\r\n                    double sum=0;\r\n                    double times=1;\r\n                    int p3;\r\n                    for(  p3=p2; p3<=head; p3++)\r\n                    {\r\n                        sum+=b[p3]*times;\r\n                        times*=(1-p[que[p3]]);\r\n                    }\r\n                    for(  p3=1; p3<p2; p3++)\r\n                    {\r\n                        sum+=b[p3]*times;\r\n                        times*=(1-p[que[p3]]);\r\n                    }\r\n                    f[i][j][state]=sum/tot;\r\n                }\r\n            }\r\n        }\r\n        for (  i=1; i<n; i++)\r\n        {\r\n            printf(\"%.2f \",f[i][1][ppo[n]-1]*100.0);\r\n        }\r\n        printf(\"%.2f\",f[i][1][ppo[n]-1]*100.0);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n'),(32,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cmath>\r\n#include<cstring>\r\n#define zero(a) ((fabs(a)<eps))\r\n#define equal(a,b) (zero(((a)-(b))))\r\nconst int ppo[]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192};\r\nconst double eps=1e-12;\r\nint plan[15][15];\r\ndouble p[15],b[15];\r\ndouble f[14][14][8192];\r\nint head;\r\nint que[15];\r\nint next[15][8192];\r\nvoid prepare()\r\n{\r\n  memset(p,0,sizeof(p));\r\n}\r\nvoid calcplan(int now,int state)\r\n{\r\n  double maxt=0;\r\n  for(int l=1;l<=head;l++)\r\n    if (que[l]!=now)\r\n      {\r\nint kill=que[l];\r\nint k=next[now][state];\r\nif (k==kill) k=next[k][state];\r\ndouble com=f[now][k][state^ppo[kill-1]];\r\nif (equal(com,maxt))\r\n      {\r\nplan[now][0]++;\r\nplan[now][plan[now][0]]=kill;\r\n      }\r\nelse\r\n  if (com>maxt)\r\n{\r\n  plan[now][0]=1;\r\n  maxt=com;\r\n  plan[now][1]=kill;\r\n}\r\n      }\r\n}\r\nvoid ready()\r\n{\r\n  for (int state=1;state<ppo[13];state++)\r\n    {\r\n      head=0;\r\n      memset(que,0,sizeof(que));\r\n      int stmp=state;\r\n      for(int i=1;i<=13;i++)\r\n    {\r\n      if (stmp & 1==1)\r\n{\r\n  head++;\r\n  que[head]=i;\r\n  next[que[head-1]][state]=que[head];\r\n};\r\n      stmp=stmp>>1;\r\n    }\r\n      next[que[head]][state]=que[1];\r\n      next[0][state]=0;\r\n    }\r\n}\r\nint main()\r\n{\r\n  int task=0;\r\n  ready();\r\n  scanf(\"%d\",&task);\r\n  for(;task>0;task--)\r\n    {\r\n      prepare;\r\n      int n;\r\n      int i;\r\n      scanf(\"%d\",&n);\r\n      for(i=1;i<=n;i++)\r\n{\r\n  scanf(\"%lf\",&p[i]);\r\n  p[i]/=100;\r\n}\r\n      int state;\r\n      for(state=1;state<ppo[n];state++)\r\n{\r\n  memset(plan,0,sizeof(plan));\r\n  memset(que,0,sizeof(que));\r\n  head=0;\r\n  memset(b,0,sizeof(b));\r\n  int stmp=state;\r\n  int j=0;\r\n  double tot=1;\r\n  for(i=1;i<=n;i++)\r\n    {\r\n      if (stmp & 1==1)\r\n{\r\n  head++;\r\n  que[head]=i;\r\n  tot=tot*(1-p[i]);\r\n};\r\n      stmp=stmp>>1;\r\n    }\r\n  if (head==1)\r\n    {\r\n      f[que[1]][que[1]][state]=1;\r\n      continue;\r\n    }\r\n   \r\n  tot=1-tot;\r\n  for(i=1;i<=head;i++)\r\n    calcplan(que[i],state);\r\n  for(int p1=1;p1<=head;p1++)\r\n    {\r\n      i=que[p1];int p2;\r\n      for(  p2=1;p2<=head;p2++)\r\n{\r\n  j=que[p2];\r\n  double sum=0;\r\n  for(int p3=1;p3<=plan[j][0];p3++)\r\n    {\r\n      int k=next[j][state];\r\n      if (k==plan[j][p3]) k=next[k][state];\r\n      sum+=f[i][k][state^ppo[plan[j][p3]-1]];\r\n    }\r\n  sum/=plan[j][0];\r\n  b[p2]=sum*p[j];\r\n}\r\n      for(  p2=1;p2<=head;p2++)\r\n{\r\n  j=que[p2];\r\n  double sum=0;\r\n  double times=1;int p3;\r\n  for(  p3=p2;p3<=head;p3++)\r\n    {\r\n      sum+=b[p3]*times;\r\n      times*=(1-p[que[p3]]);\r\n    }\r\n  for(  p3=1;p3<p2;p3++)\r\n    {\r\n      sum+=b[p3]*times;\r\n      times*=(1-p[que[p3]]);\r\n    }\r\n  f[i][j][state]=sum/tot;\r\n}\r\n    }\r\n}\r\n      for (  i=1;i<n;i++)\r\n{\r\n  printf(\"%.2f \",f[i][1][ppo[n]-1]*100.0);\r\n}printf(\"%.2f\",f[i][1][ppo[n]-1]*100.0);\r\n      printf(\"\\n\");\r\n    }\r\n}'),(33,'#include<stdio.h>\r\n#include<math.h>\r\n\r\n#define COUNT_MAX    8\r\n#define TIME_MAX    1E7\r\n\r\ntypedef struct\r\n{\r\n    double x;\r\n    double y;\r\n    double v;\r\n    double d;\r\n}PERSON;\r\n\r\nPERSON Senior[COUNT_MAX];\r\nint List[COUNT_MAX];\r\nint N;\r\n\r\ndouble intersect(PERSON g, PERSON s, PERSON * mg)\r\n{\r\n    double c0, c1, c2, vsd, vcd, a, b, c;\r\n    double x, y, t;\r\n\r\n    vsd = s.v * sin(s.d);\r\n    vcd = s.v * cos(s.d);\r\n    c0 = g.v * g.v * g.d;\r\n    c1 = s.x - g.x;\r\n    c2 = s.y - g.y;\r\n\r\n    a = s.v * s.v - g.v * g.v;\r\n    b = 2 * (c0 + c1 * vcd + c2 * vsd);\r\n    c = c1 * c1 + c2 * c2 - c0 * g.d;\r\n\r\n    t = -(b + sqrt(b * b - 4 * a * c)) / (2 * a);\r\n    x = s.x + vcd * t;\r\n    y = s.y + vsd * t;\r\n\r\n    mg->x = x;\r\n    mg->y = y;\r\n    mg->v = g.v;\r\n    mg->d = t;\r\n\r\n    return t + sqrt(x * x + y * y) / s.v;\r\n}\r\n\r\ndouble sub_cal(PERSON g, double use_t, int deep)\r\n{\r\n    static double min_t;\r\n    double t;\r\n    PERSON mg;\r\n    int i, j, tmp;\r\n\r\n    if(deep == 0) min_t = TIME_MAX;\r\n    if(deep == N && min_t > use_t) min_t = use_t;\r\n\r\n    for(i = deep; i < N; i++)\r\n    {\r\n        tmp = List[i]; List[i] = List[deep]; List[deep] = tmp;\r\n        t = intersect(g, Senior[List[deep]], &mg);\r\n        if(t < min_t) sub_cal(mg, t > use_t ? t : use_t, deep + 1);\r\n        tmp = List[i]; List[i] = List[deep]; List[deep] = tmp;\r\n    }\r\n    return min_t;\r\n}\r\n\r\ndouble cal(double v)\r\n{\r\n    PERSON g = {0, 0, v, 0};\r\n    return sub_cal(g, 0, 0);\r\n}\r\n\r\nint main()\r\n{\r\n    double v;\r\n    int i;\r\n   \r\n    for(i = 0; i < COUNT_MAX; List[i] = i++);\r\n    for(; scanf(\"%d\", &N), N; printf(\"%.0f\\n\", cal(v)))\r\n    for(scanf(\"%lf\", &v), i = 0; i < N; i++)\r\n        scanf(\"%lf%lf%lf%lf\", &Senior[i].x, &Senior[i].y, &Senior[i].v, &Senior[i].d);\r\n    return 0;\r\n}\r\n'),(34,'#include<iostream>\r\n#include<cmath>\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct A\r\n{double t1,t2,x,y;};\r\nstruct B\r\n{double x,y,v,th;int i;\r\nfriend bool operator<(const B&a,const B&b)\r\n{\r\nreturn a.i<b.i;\r\n}\r\n};\r\nA f(double v1,double v2,double x1,double y1,\r\ndouble x2,double y2,double thita,double t0)\r\n{\r\nA aa;\r\ndouble dtx=x2-x1;\r\ndouble dty=y2-y1;\r\ndouble a=v2*v2-v1*v1;\r\ndouble b=2*(sin(thita)*dty+cos(thita)*dtx)*v2;\r\ndouble c=dtx*dtx+dty*dty;\r\ndouble t=(-b-sqrt(b*b-4*a*c))/2/a;\r\naa.t1= t+t0;\r\ndouble x3=x2+t*v2*cos(thita);\r\ndouble y3=y2+t*v2*sin(thita);\r\n//cout<<x3<<\" \"<<y3<<endl;\r\naa.t2=sqrt(x3*x3+y3*y3)/v2+aa.t1;\r\naa.x=x3;aa.y=y3;\r\nreturn aa;\r\n}\r\ndouble g(B a[] ,int n,double v)\r\n{\r\ndouble t=0;int i;A aa;\r\naa.t1=0;aa.t2=0;aa.x=aa.y=0;\r\nfor(i=0;i<n;i++)\r\n{\r\naa=f(v,a[i].v,aa.x,aa.y,a[i].x+a[i].v*cos(a[i].th)*aa.t1,\r\na[i].y+a[i].v*sin(a[i].th)*aa.t1\r\n,a[i].th,aa.t1);\r\nif(aa.t2>t)t=aa.t2;\r\n}\r\nreturn t;\r\n}\r\nB a[8];\r\nint n;\r\nint main()\r\n{\r\nwhile(cin>>n&&n)\r\n{ double v;\r\ncin>>v;\r\nint i=0;\r\nwhile(i<n)\r\n{ cin>>a[i].x>>a[i].y>>a[i].v>>a[i].th;a[i].i=i;i++;}\r\ndouble min=0;\r\ndo\r\n{\r\ndouble t=g(a,n,v);\r\nif(min==0||min>t) min=t;\r\n}\r\nwhile(next_permutation(a,a+n));\r\ncout<<(int)(0.5+min)<<endl;\r\n}\r\n}'),(35,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nint arry[15];\r\n\r\nvoid solve(int n)\r\n{\r\n	if (n==2)\r\n		cout<<2<<\" \"<<1<<endl;\r\n	else\r\n    {\r\n		memset(arry,0,sizeof(arry));\r\n		int temp=0;\r\n		int t=0;\r\n		for (int i=1;i<=n;++i)\r\n            {\r\n                temp=0;\r\n                for (int j=t;j<n;++j)\r\n                {\r\n                    if (arry[j]==0)\r\n                        temp++;\r\n                    if (temp==i)\r\n                    {\r\n                        int k;\r\n                        for (k=(j+1)%n;k<n;++k)\r\n                        {\r\n                            if (arry[k]==0)\r\n                            {\r\n                            	arry[k] = i;\r\n                                break;\r\n                            }\r\n						if (k+1==n)\r\n							k=-1;\r\n                        }\r\n                        t=(k+1)%n;\r\n                        break;\r\n                    }\r\n				if (j+1==n)\r\n					j=-1;\r\n                }\r\n            }\r\n		for (int i=0;i<n;++i)\r\n            {\r\n                if(i!=0)\r\n                    cout<<\" \";\r\n                cout<<arry[i];\r\n            }\r\n		cout<<endl;\r\n    }\r\n}\r\n\r\nvoid input()\r\n{\r\n\r\n	int test;\r\n	cin>>test;\r\n	while(test--)\r\n        {\r\n            int n;\r\n            cin>>n;\r\n            solve(n);\r\n        }\r\n}\r\n\r\nint main()\r\n{\r\n#ifdef _DEBUG\r\n	freopen(\"in.txt\", \"r\", stdin)\r\n#endif\r\n	input();\r\n	return 0;\r\n}\r\n'),(36,'#include<iostream>\r\n#include<list>\r\nusing namespace std;\r\nvoid f( int n)\r\n{\r\nlist<int> l;\r\nint a[13];\r\nint i=0;\r\nfor( i=0;i<n;i++)\r\nl.push_back(i+1);\r\nlist<int>::iterator r=l.begin();\r\ni=0;\r\nwhile(!l.empty())\r\n{ i++;\r\nfor(int j=1;j<=i;j++)\r\n{r++;if(r==l.end())r=l.begin();}\r\na[*r-1]=i;\r\nlist<int>::iterator dr=r;\r\nr++;if(r==l.end())r=l.begin();\r\nl.erase(dr);\r\n}\r\nfor(i=0;i<n-1;i++)cout<<a[i]<<\' \';\r\ncout<<a[i]<<\'\\n\';\r\n}\r\nint main()\r\n{\r\nint m,n;\r\ncin>>m;\r\nwhile(m--)\r\n{ cin>>n;f(n);}\r\n}'),(37,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nchar ch[101];\r\nint sn,ln;\r\nint minimal(int b,int e);\r\n\r\nint main()\r\n{\r\n   // freopen(\"d:\\\\in.txt\",\"r\",stdin);\r\n    int i,j,k,cn;\r\n    cin>>cn;\r\n    while(cn--)\r\n    {\r\n        cin>>ch;\r\n        ln=strlen(ch);\r\n        j=0;\r\n        k=ln-1;\r\n        while(1)\r\n        {\r\n            while(minimal(j,k)==0)\r\n                k--;\r\n            cout<<\"(\";\r\n            for(i=j; i<=k; i++)\r\n                cout<<ch[i];\r\n            cout<<\")\";\r\n                if(k==ln-1)\r\n                    break;\r\n            j=k+1,k=ln-1;\r\n        }\r\n        cout<<endl;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nint minimal(int b,int e)\r\n{\r\n    int i,j,pos1,pos2;\r\n    int len=e-b+1;\r\n    for(i=1; i<len; i++)\r\n    {\r\n        pos1=b;\r\n        pos2=b+i;\r\n        for(j=0; j<len; j++)\r\n        {\r\n            if(ch[pos1]<ch[pos2])\r\n                break;\r\n            else if(ch[pos1]>ch[pos2])\r\n                return 0;\r\n            pos1++;\r\n            pos2++;\r\n            if(pos2>e)\r\n                pos2=b;\r\n        }\r\n    }\r\n    return 1;\r\n}\r\n'),(38,'#include <stdio.h>\n#include <string.h>\n\nint eva(char *num, int len)\n{\n	int i;\n	char sum[512];\n\n	for (i = 1 ; i < len ; i++)\n	{\n		memset(sum, 0, sizeof(sum));\n		strncpy(sum, num + i, len - i);\n		strncpy(sum + len - i, num, i);\n		if (strncmp(num, sum, len) > 0)\n			return 0;\n	}\n\n	return 1;\n}\n\nint main(void)\n{\n	int n, i, j;\n	int len;\n	char *p;\n	char num[512];\n\n	scanf(\"%d%*c\", &n);\n	while (n--)\n	{\n		gets(num);\n		p = num;\n		while (len = strlen(p))\n		{\n			for (j = len ; !eva(p, j) ; j--)\n				;\n			putchar(\'(\');\n			for (i = 0 ; i < j ; i++)\n				putchar(*(p + i));\n			putchar(\')\');\n			p += j;\n		}\n		putchar(\'\\n\');\n	}\n\n	return 0;\n}'),(39,'#include<iostream>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct point\r\n{int x,y,o;};\r\nint a[101][101];\r\npoint b[101];\r\nint m,n;\r\nint r,in;\r\n bool done(int ri,char com,int re,bool s)\r\n {\r\n	 if(s==1) return 1;\r\n	 if(com==\'F\') \r\n	 {\r\n		 int x,y,i;\r\n		 if(b[ri].o==0){x=-1;y=  0;}\r\n		 else if(b[ri].o==1){x=0;y=1;}\r\n		 else if(b[ri].o==2){x=1;y=0;}\r\n		 else  {x=0;y=-1;}\r\n		 a[b[ri].x][b[ri].y]=0;\r\n		 for(i=1;i<=re;i++)\r\n			if(!(b[ri].x+i*x>0&&b[ri].x+i*x<=m\r\n			 &&b[ri].y+i*y>0&&b[ri].y+i*y<=n))\r\n			 {cout <<\"Robot \"<<ri<<\" crashes into the wall\"<<endl;\r\n		       return 1;}\r\n			else if(a[b[ri].x+i*x][b[ri].y+i*y])\r\n			 {\r\n				 cout<<\"Robot \"<<ri<<\" crashes into robot \"<<a[b[ri].x+i*x][b[ri].y+i*y]<<endl;\r\n				 return 1;\r\n			 }\r\n		  b[ri].x+=(x*re);b[ri].y+=(y*re);\r\n		  a[b[ri].x][b[ri].y]=ri; return 0; 		 \r\n	 }\r\n	 re%=4;\r\n	 if(re==0) return 0;\r\n	 if(com==\'L\') \r\n	   re=4-re;\r\n	 b[ri].o+=re;\r\n	 b[ri].o%=4;\r\n	 return 0;\r\n }\r\nint main()\r\n{\r\n	int cases,i;\r\n	cin>>cases;\r\n	while(cases--)\r\n	{\r\n		memset(a,0,sizeof(a));\r\n		cin>>m>>n;\r\n		cin>>r>>in;\r\n		int x,y;\r\n		char c;\r\n		for(i=0;i<r;i++)\r\n		{  cin>>x>>y>>c;\r\n		    \r\n		   b[i+1].x=x;\r\n		   b[i+1].y=y;\r\n		   if(c==\'W\') b[i+1].o=0;\r\n		   else if(c==\'N\') b[i+1].o=1;\r\n		   else if(c==\'E\') b[i+1].o=2;\r\n		   else if(c==\'S\') b[i+1].o=3;\r\n		   a[x][y]=i+1;		 \r\n		}\r\n		bool s=0;\r\n		for(i=0;i<in;i++)\r\n		{\r\n			cin>>x>>c>>y;\r\n			s=done(x,c,y,s);\r\n		}\r\n		if(s==0) cout<<\"OK\"<<endl;\r\n	}\r\n}'),(40,'#include<iostream>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct point\r\n{int x,y,o;};\r\nint a[101][101];\r\npoint b[101];\r\nint m,n;\r\nint r,in;\r\n bool done(int ri,char com,int re,bool s)\r\n {\r\n	 if(s==1) return 1;\r\n	 if(com==\'F\') \r\n	 {\r\n		 int x,y,i;\r\n		 if(b[ri].o==0){x=-1;y=  0;}\r\n		 else if(b[ri].o==1){x=0;y=1;}\r\n		 else if(b[ri].o==2){x=1;y=0;}\r\n		 else  {x=0;y=-1;}\r\n		 a[b[ri].x][b[ri].y]=0;\r\n		 for(i=1;i<=re;i++)\r\n			if(!(b[ri].x+i*x>0&&b[ri].x+i*x<=m\r\n			 &&b[ri].y+i*y>0&&b[ri].y+i*y<=n))\r\n			 {cout <<\"Robot \"<<ri<<\" crashes into the wall\"<<endl;\r\n		       return 1;}\r\n			else if(a[b[ri].x+i*x][b[ri].y+i*y])\r\n			 {\r\n				 cout<<\"Robot \"<<ri<<\" crashes into robot \"<<a[b[ri].x+i*x][b[ri].y+i*y]<<endl;\r\n				 return 1;\r\n			 }\r\n		  b[ri].x+=(x*re);b[ri].y+=(y*re);\r\n		  a[b[ri].x][b[ri].y]=ri; return 0; 		 \r\n	 }\r\n	 re%=4;\r\n	 if(re==0) return 0;\r\n	 if(com==\'L\') \r\n	   re=4-re;\r\n	 b[ri].o+=re;\r\n	 b[ri].o%=4;\r\n	 return 0;\r\n }\r\nint main()\r\n{\r\n	int cases,i;\r\n	cin>>cases;\r\n	while(cases--)\r\n	{\r\n		memset(a,0,sizeof(a));\r\n		cin>>m>>n;\r\n		cin>>r>>in;\r\n		int x,y;\r\n		char c;\r\n		for(i=0;i<r;i++)\r\n		{  cin>>x>>y>>c;\r\n		    \r\n		   b[i+1].x=x;\r\n		   b[i+1].y=y;\r\n		   if(c==\'W\') b[i+1].o=0;\r\n		   else if(c==\'N\') b[i+1].o=1;\r\n		   else if(c==\'E\') b[i+1].o=2;\r\n		   else if(c==\'S\') b[i+1].o=3;\r\n		   a[x][y]=i+1;		 \r\n		}\r\n		bool s=0;\r\n		for(i=0;i<in;i++)\r\n		{\r\n			cin>>x>>c>>y;\r\n			s=done(x,c,y,s);\r\n		}\r\n		if(s==0) cout<<\"OK\"<<endl;\r\n	}\r\n}'),(41,'#include<stdio.h>  \r\nint main()  \r\n{  \r\n    int t, a, sum, n, i;  \r\n    scanf(\"%d\",&t);  \r\n    while(t--)  \r\n    {  \r\n        scanf(\"%d\",&n);  \r\n        sum = 1 - n;\r\n        for(i=0; i<n; i++)  \r\n        {  \r\n            scanf(\"%d\",&a);  \r\n            sum += a;  \r\n        }  \r\n        printf(\"%d\\n\",sum);  \r\n    }  \r\n}'),(42,'#include<stdio.h>\nint main()\n{\n	int t,a[10];\n	int n,count,i;\n	scanf(\"%d\",&t);\n	while(t--)\n	{\n		count=0;\n		scanf(\"%d\",&n);\n		for(i=0;i<n;i++)\n		{\n			scanf(\"%d\",a+i);\n			count+=a[i];\n		}\n		count=count-n+1;\n		printf(\"%d\\n\",count);\n	}\n	return 0;\n}'),(43,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\nint p[60][2];\r\nint s,n;\r\nbool solve(int x,int y)\r\n{\r\n    int l=min(min(x,y),min(s-x,s-y));\r\n    l=l*l;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        int x1=p[i][0],y1=p[i][1];\r\n        if((x1==x&&y1==y)||((x1-x)*(x1-x)+(y1-y)*(y1-y))>l)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nint main()\r\n{\r\n    int t;\r\n    for(cin>>t;t;t--)\r\n    {\r\n        cin>>s>>n;\r\n        for(int i=0;i<n;i++)\r\n            cin>>p[i][0]>>p[i][1];\r\n        bool flag=false;\r\n        for(int x=1;x<s;x++)\r\n        {\r\n            for(int y=1;y<s;y++)\r\n            {\r\n                if(solve(x,y))\r\n                {\r\n                    flag=true;\r\n                    cout<<x<<\' \'<<y<<endl;\r\n                    x=y=s;\r\n                }\r\n            }\r\n        }\r\n        if(!flag)\r\n            cout<<\"poodle\"<<endl;\r\n    }\r\n    return 0;\r\n}\r\n'),(44,'#include <stdio.h>\n\nint main(void)\n{\n	int t;\n	int i, j;\n	int s, h;\n	int d[50][2];\n	int k, dig;\n	double max, r, min;\n	double l;\n\n	scanf(\"%d\", &t);\n	while (t--)\n	{\n		scanf(\"%d%d\", &s, &h);\n		for (i = 0 ; i < h ; i++)\n			scanf(\"%d%d\", d[i], d[i] + 1);\n		dig = 0;\n		for (i = 1 ; i < s ; i++)\n		{\n			for (j = 1 ; j < s ; j++)\n			{\n				r = i < s - i ? i : s - i;\n				if (r > j) r = j;\n				if (r > s - j) r = s - j;\n				r *= r;\n				max = 0;\n				min = 10000000;\n				for (k = 0 ; k < h ; k++)\n				{\n					l = (d[k][0] - i) * (d[k][0] - i) + (d[k][1] - j) * (d[k][1] - j);\n					if (l > max) max = l;\n					if (l < min) min = l;\n				}\n				if (r >= max && min > 1E-6)\n				{\n					dig = 1;\n					break;\n				}\n			}\n			if (dig) break;\n		}\n		if (dig)\n		{\n			printf(\"%d %d\\n\", i, j);\n		}\n		else\n			puts(\"poodle\");\n	}\n\n	return 0;\n}'),(45,'\r\n#include <cstring>\r\n#include <memory>\r\n#include <cstdio>\r\n#include <cmath>\r\n#define null 0\r\n#define y1 yy1\r\nusing namespace std;\r\nconst int size=510;\r\n\r\nint maxmatch(int n,int m,bool w[][size],int *p)\r\n{\r\n\r\n	int p_n[size];\r\n	int p_m[size];\r\n	bool sign[size];\r\n	int q[size],from[size],s,t;\r\n	int i,j,link,now,h;\r\n	memset(p_n,-1,sizeof(int)*n);\r\n	memset(p_m,-1,sizeof(int)*m);\r\n	for(i=0;i<n;i++)\r\n	if(p_n[i]==-1)\r\n	{\r\n		memset( sign, 0, sizeof(bool)*m );\r\n                s=1;link=-1;\r\n		from[0]=-1;\r\n		q[0]=size-1;\r\n		p_m[size-1]=i;\r\n		for(t=0;t<s;t++)\r\n		{\r\n		   now=q[t];\r\n		   for(j=0;j<m;j++)\r\n		   {\r\n			   if(w[p_m[now]][j]!=null && sign[j]==0)\r\n			   {\r\n					sign[j]=1;\r\n					q[s]=j;\r\n					from[s++]=t;\r\n					if(p_m[j]==-1)\r\n					{\r\n						link=s-1;\r\n						break;\r\n					}\r\n			   }\r\n		   }\r\n		   if(j<m)break;\r\n		}\r\n		if(t<s)\r\n		{\r\n			 while(from[link]!=-1)\r\n			 {\r\n					h=from[link];\r\n					p_m[q[link]]=p_m[q[h]];\r\n					p_n[p_m[q[h]]]=q[link];\r\n					link=h;\r\n			 }\r\n		}\r\n	}\r\n	int an;\r\n	for(i=0,an=0;i<n;i++)\r\n	{\r\n		if(p)p[i]=p_n[i];\r\n		if(p_n[i]>=0)an++;\r\n	}\r\n	return an;\r\n}\r\nbool e[size][size];\r\nint begin[size],end[size];\r\nint x1[size],y1[size],x2[size],y2[size],n;\r\ninline int dis(int x1,int y1,int x2,int y2)\r\n{\r\n	return abs(x1-x2)+abs(y1-y2);\r\n}\r\nint main()\r\n{\r\n	int cas,n,i,j,a,b;\r\n	scanf(\"%d\",&cas);\r\n	while(cas--)\r\n	{\r\n		memset(e,0,sizeof e);\r\n		scanf(\"%d\",&n);\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf(\"%d:%d %d %d %d %d\",&a,&b,x1+i,y1+i,x2+i,y2+i);\r\n			begin[i]=a*60+b;\r\n			end[i]=begin[i]+dis(x1[i],y1[i],x2[i],y2[i]);\r\n		}\r\n		for(i=0;i<n;i++)\r\n		for(j=i+1;j<n;j++)\r\n			if(end[i]+dis(x2[i],y2[i],x1[j],y1[j])<begin[j])\r\n				e[i][j]=true;\r\n		printf(\"%d\\n\",n-maxmatch(n,n,e,0));\r\n	}\r\n	return 0;\r\n}\r\n'),(46,'#include<iostream>\r\n#include<list>\r\n#include<bitset>\r\n#include<cstring>\r\nusing namespace std;\r\nstruct A\r\n{\r\n	int t,w,c,d;\r\n};\r\nA arr[501];\r\ntypedef list<int> LI;\r\nLI g[1001];\r\nbitset<1001> visit;\r\nint flag[1001];\r\n\r\nbool f(int a)\r\n{  LI::iterator r=g[a].begin();\r\n	for(;r!=g[a].end();++r)\r\n	{\r\n		if(!visit.test(*r))\r\n		{	visit.set(*r);\r\n		    if(flag[*r]==-1||f(flag[*r]))\r\n			{\r\n				flag[*r]=a;\r\n				return 1;\r\n			}\r\n		}\r\n	}\r\n	return 0;\r\n}\r\nint main ()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{int i;\r\n		for(i=0;i<1001;i++) g[i].clear();\r\n		memset(flag,-1,sizeof(flag));\r\n		int m ;\r\n		cin>>m ;\r\n		for(i=0;i<m;i++)\r\n		{\r\n			int h,m,t,a,b,c,d,j;\r\n			cin>>h;\r\n			cin.ignore();\r\n			cin>>m;\r\n			t=h*60+m;\r\n			cin>>a>>b>>c>>d;\r\n			arr[i].t=t;arr[i].w=abs(a-c)+abs(b-d);\r\n			arr[i].c=c;\r\n			arr[i].d=d;\r\n			for(j=i-1;j>=0;j--)\r\n				if(1+arr[j].t+arr[j].w+abs(arr[j].c-a)+abs(arr[j].d-b)\r\n					<=arr[i].t)\r\n					g[j].push_back(i );\r\n\r\n		}\r\n		int an=0;\r\n		for(i=0;i<m;i++)\r\n		{    visit.reset();\r\n             if(f(i))an++;\r\n		}\r\n		cout<<m-an<<endl;\r\n	}\r\n}'),(47,'#include<iostream>\r\nusing namespace std;\r\n\r\nstruct LI\r\n{\r\n	short aa[110000];\r\n	int count;\r\n	LI():count(0){}\r\n};\r\n \r\nLI arr[110];\r\n \r\nbool f(int x,int nth,int base )\r\n{\r\n	while(1)\r\n	{\r\n	if(nth<=0) {arr[nth].aa[arr[nth].count++]=x;return 1;}\r\n	int y=arr[nth-1].aa[arr[nth-1].count-1];     //*(arr[nth-1].begin());\r\n	if(y>=base)\r\n	{\r\n		if(x!=y%base+1) return 0;\r\n		else\r\n		{\r\n          arr[nth-1].aa[arr[nth-1].count-1]%=base;\r\n          arr[nth-1].aa[arr[nth-1].count++]=1;//arr[nth-1].push_front(1);\r\n		  arr[nth].aa[arr[nth].count++]=x;//arr[nth].push_front(x);\r\n		  return 1;\r\n		}\r\n	}\r\n	if(x>=y)\r\n	{\r\n		arr[nth].aa[arr[nth].count++]=x;\r\n		x=x-y;\r\n		nth--;\r\n		//return f(x-y,nth-1);\r\n		//return 1;\r\n	}\r\n	else \r\n	{\r\n         arr[nth].aa[arr[nth].count++]= (x+base);\r\n		 // return f(x+base-y,nth-1);\r\n		 x=x+base-y;\r\n		 nth--;\r\n	}\r\n	}\r\n}\r\n\r\nvoid post(int from,int to ,int pos,int len,int base )\r\n{\r\n	while(1){\r\n	if(pos>=len)break ;\r\n	int from1=arr[pos].count-1 ;\r\n 	int r=from ;\r\n	r++;\r\n 	for(;r!=to; )\r\n	{    \r\n		int x=arr[pos-1].aa[r]+arr[pos-1].aa[from];\r\n		if(x<base) arr[pos].aa[arr[pos].count++]=x;//arr[pos].push_front(x);\r\n		else {arr[pos].aa[arr[pos].count++]=(x%base);\r\n		arr[pos].aa[arr[pos].count++]=(1);}\r\n		++from;\r\n	    ++r;\r\n	}\r\n    from=from1;\r\n	to=arr[pos].count;\r\n	pos++;\r\n	//post(from1, arr[pos].count,pos+1);\r\n	}\r\n\r\n}\r\nvoid g(int len,int base,int count )\r\n{\r\n	int i;\r\n	\r\n	for(i=len -1;i>=0;--i)\r\n	{\r\n		int r=arr[i].count-1;\r\n		int rr=r;\r\n	  if(arr[len-1].count>5) return;\r\n		if(arr[i].aa[r]>=base)\r\n		{\r\n		    arr[i].aa[r]%=base;\r\n			arr[i].aa[arr[i].count++]=1;// arr[i].push_front(1);\r\n		 	post( rr,arr[i].count,i+1 ,len,base);\r\n		}\r\n	}\r\n	 \r\n}\r\nvoid print(int i)\r\n{\r\n  int j=0;\r\n  for(j=0;j<=i;j++)\r\n  {\r\n	  int r= arr[j].count-1;\r\n	  while(r!=-1)\r\n	  {cout<<arr[j].aa[r]<<\" \" ;r--;}cout<<\"|||\";\r\n  }\r\n  cout<<endl;\r\n}\r\nvoid print(LI& test)\r\n{\r\n  int j=0;\r\n  for(j=test.count-1;j>=0;j--)\r\n  {\r\n	  cout<<test.aa[j];\r\n  }\r\n  cout<<endl;\r\n}\r\nbool next(  LI & old,LI& ne,int base)\r\n{	\r\n	\r\n	ne.count=0;\r\n	if(old.count==1) return 0;\r\n     if(old.count>10) old.count=10;\r\n	int rn=0;\r\n	int r;\r\n	if(rn!=old.count)  r=rn++;else r=rn;\r\n	for(;rn!=old.count;rn++)\r\n	{\r\n		int x=old.aa[r]+old.aa[rn];\r\n		if(x<base)  ne.aa[ne.count++]=x;//ne.push_front(x);\r\n		else {ne.aa[ne.count++]=(x%base);ne.aa[ne.count++]=(1);}\r\n		r=rn;\r\n	}\r\n	return 1;\r\n}\r\nint main ()\r\n{\r\n	int test;\r\n	cin>>test;\r\n	while(test--)\r\n	{ int base,len;\r\n	  cin>>base;\r\n      cin>>len;\r\n	   \r\n      int i;\r\n	  int T;\r\n      bool flag=1;\r\n      for(i=0;i<len;i++)\r\n	  {\r\n	     arr[i].count=0;\r\n	     int tmp;\r\n	     cin>>tmp;\r\n	     if(flag&&(flag=f(tmp,i,base))) ;	   \r\n	  }\r\n	 // print(len-1);\r\n	 // g( );\r\n	 // print(len-1);\r\n	   cin>>T;\r\n       if(!flag) cout<<\"impossible\"<<endl;\r\n       else \r\n	   {g(len,base,T-len);\r\n	   int j=0;\r\n	   LI temp;\r\n	   bool sus;\r\n	   for(;j<T-len ;j++)\r\n	   {\r\n		   if(j%2==0)\r\n		   {if(arr[len-1].count>T-len-j+1)\r\n		      arr[len-1].count=T-len-j+1;\r\n				  sus=next(arr[len-1],temp,base);}\r\n		   else \r\n		   {if(temp.count>T-len-j+1)\r\n		      temp.count=T-len-j+1;\r\n		   sus=next(temp,arr[len-1],base);}\r\n		   if(!sus ) break;\r\n	   }\r\n	   if(j==T-len)\r\n		   if(j%2==0)\r\n	       cout<< (arr[len-1].aa[0])<<endl;\r\n		   else cout<<(temp.aa[0])<<endl;\r\n	   else cout<<\"unpredictable\"<<endl;\r\n	   }   \r\n	}\r\n   \r\n}\r\n \r\n '),(48,'#include<iostream>\r\nusing namespace std;\r\n\r\nstruct LI\r\n{\r\n	short aa[110000];\r\n	int count;\r\n	LI():count(0){}\r\n};\r\n \r\nLI arr[110];\r\n \r\nbool f(int x,int nth,int base )\r\n{\r\n	while(1)\r\n	{\r\n	if(nth<=0) {arr[nth].aa[arr[nth].count++]=x;return 1;}\r\n	int y=arr[nth-1].aa[arr[nth-1].count-1];     //*(arr[nth-1].begin());\r\n	if(y>=base)\r\n	{\r\n		if(x!=y%base+1) return 0;\r\n		else\r\n		{\r\n          arr[nth-1].aa[arr[nth-1].count-1]%=base;\r\n          arr[nth-1].aa[arr[nth-1].count++]=1;//arr[nth-1].push_front(1);\r\n		  arr[nth].aa[arr[nth].count++]=x;//arr[nth].push_front(x);\r\n		  return 1;\r\n		}\r\n	}\r\n	if(x>=y)\r\n	{\r\n		arr[nth].aa[arr[nth].count++]=x;\r\n		x=x-y;\r\n		nth--;\r\n		//return f(x-y,nth-1);\r\n		//return 1;\r\n	}\r\n	else \r\n	{\r\n         arr[nth].aa[arr[nth].count++]= (x+base);\r\n		 // return f(x+base-y,nth-1);\r\n		 x=x+base-y;\r\n		 nth--;\r\n	}\r\n	}\r\n}\r\n\r\nvoid post(int from,int to ,int pos,int len,int base )\r\n{\r\n	while(1){\r\n	if(pos>=len)break ;\r\n	int from1=arr[pos].count-1 ;\r\n 	int r=from ;\r\n	r++;\r\n 	for(;r!=to; )\r\n	{    \r\n		int x=arr[pos-1].aa[r]+arr[pos-1].aa[from];\r\n		if(x<base) arr[pos].aa[arr[pos].count++]=x;//arr[pos].push_front(x);\r\n		else {arr[pos].aa[arr[pos].count++]=(x%base);\r\n		arr[pos].aa[arr[pos].count++]=(1);}\r\n		++from;\r\n	    ++r;\r\n	}\r\n    from=from1;\r\n	to=arr[pos].count;\r\n	pos++;\r\n	//post(from1, arr[pos].count,pos+1);\r\n	}\r\n\r\n}\r\nvoid g(int len,int base,int count )\r\n{\r\n	int i;\r\n	\r\n	for(i=len -1;i>=0;--i)\r\n	{\r\n		int r=arr[i].count-1;\r\n		int rr=r;\r\n	  if(arr[len-1].count>5) return;\r\n		if(arr[i].aa[r]>=base)\r\n		{\r\n		    arr[i].aa[r]%=base;\r\n			arr[i].aa[arr[i].count++]=1;// arr[i].push_front(1);\r\n		 	post( rr,arr[i].count,i+1 ,len,base);\r\n		}\r\n	}\r\n	 \r\n}\r\nvoid print(int i)\r\n{\r\n  int j=0;\r\n  for(j=0;j<=i;j++)\r\n  {\r\n	  int r= arr[j].count-1;\r\n	  while(r!=-1)\r\n	  {cout<<arr[j].aa[r]<<\" \" ;r--;}cout<<\"|||\";\r\n  }\r\n  cout<<endl;\r\n}\r\nvoid print(LI& test)\r\n{\r\n  int j=0;\r\n  for(j=test.count-1;j>=0;j--)\r\n  {\r\n	  cout<<test.aa[j];\r\n  }\r\n  cout<<endl;\r\n}\r\nbool next(  LI & old,LI& ne,int base)\r\n{	\r\n	\r\n	ne.count=0;\r\n	if(old.count==1) return 0;\r\n\r\n	int rn=0;\r\n	int r;\r\n	if(rn!=old.count)  r=rn++;else r=rn;\r\n	for(;rn!=old.count;rn++)\r\n	{\r\n		int x=old.aa[r]+old.aa[rn];\r\n		if(x<base)  ne.aa[ne.count++]=x;//ne.push_front(x);\r\n		else {ne.aa[ne.count++]=(x%base);ne.aa[ne.count++]=(1);}\r\n		r=rn;\r\n	}\r\n	return 1;\r\n}\r\nint main ()\r\n{\r\n	int test;\r\n	cin>>test;\r\n	while(test--)\r\n	{ int base,len;\r\n	  cin>>base;\r\n      cin>>len;\r\n	   \r\n      int i;\r\n	  int T;\r\n      bool flag=1;\r\n      for(i=0;i<len;i++)\r\n	  {\r\n	     arr[i].count=0;\r\n	     int tmp;\r\n	     cin>>tmp;\r\n	     if(flag&&(flag=f(tmp,i,base))) ;	   \r\n	  }\r\n	 // print(len-1);\r\n	 // g( );\r\n	 // print(len-1);\r\n	   cin>>T;\r\n       if(!flag) cout<<\"impossible\"<<endl;\r\n       else \r\n	   {g(len,base,T-len);\r\n	   int j=0;\r\n	   LI temp;\r\n	   bool sus;\r\n	   for(;j<T-len ;j++)\r\n	   {\r\n		   if(j%2==0)\r\n		   {if(arr[len-1].count>T-len-j+1)\r\n		      arr[len-1].count=T-len-j+1;\r\n				  sus=next(arr[len-1],temp,base);}\r\n		   else \r\n		   {if(temp.count>T-len-j+1)\r\n		      temp.count=T-len-j+1;\r\n		   sus=next(temp,arr[len-1],base);}\r\n		   if(!sus ) break;\r\n	   }\r\n	   if(j==T-len)\r\n		   if(j%2==0)\r\n	       cout<< (arr[len-1].aa[0])<<endl;\r\n		   else cout<<(temp.aa[0])<<endl;\r\n	   else cout<<\"unpredictable\"<<endl;\r\n	   }   \r\n	}\r\n   \r\n}\r\n \r\n '),(49,'#include<iostream>  \r\n#include<stdio.h>  \r\n#include<string.h>  \r\nusing namespace std;  \r\n  \r\nint map[53][53];  \r\nint xm[53];  \r\nint ym[53];  \r\nint tag[53];  \r\n  \r\nint change(char ch)  \r\n{  \r\n    if(ch==\'H\')  \r\n    {  \r\n        return 3;  \r\n    }  \r\n    else if(ch==\'S\')  \r\n    {  \r\n        return 2;  \r\n    }  \r\n    else if(ch==\'D\')  \r\n    {  \r\n        return 1;  \r\n    }  \r\n    else if(ch==\'C\')  \r\n    {  \r\n        return 0;  \r\n    }  \r\n    else if(ch==\'T\')  \r\n    {  \r\n        return 8*4;  \r\n    }  \r\n    else if(ch==\'J\')  \r\n    {  \r\n        return 9*4;  \r\n    }  \r\n    else if(ch==\'Q\')  \r\n    {  \r\n        return 10*4;  \r\n    }  \r\n    else if(ch==\'K\')  \r\n    {  \r\n        return 11*4;  \r\n    }  \r\n    else if(ch==\'A\')  \r\n    {  \r\n        return 12*4;  \r\n    }  \r\n    else  \r\n    {  \r\n        return (ch-\'2\')*4;  \r\n    }  \r\n}  \r\n  \r\nint dfs(int u)  \r\n{  \r\n    int i;  \r\n    for(i=0;i<52;i++)  \r\n    {  \r\n        if(tag[i]==0&&map[u][i]==1)  \r\n        {  \r\n            tag[i]=1;  \r\n            if(ym[i]==-1||dfs(ym[i])==1)  \r\n            {  \r\n                ym[i]=u;  \r\n                xm[u]=i;  \r\n                return 1;  \r\n            }  \r\n        }  \r\n    }  \r\n    return 0;  \r\n}  \r\n  \r\nint find()  \r\n{  \r\n    int count,j;  \r\n    count=0;  \r\n    memset(xm,-1,sizeof(xm));  \r\n    memset(ym,-1,sizeof(ym));  \r\n    for(j=0;j<52;j++)  \r\n    {  \r\n        if(xm[j]==-1)  \r\n        {  \r\n            memset(tag,0,sizeof(tag));  \r\n            if(dfs(j)==1)  \r\n            {  \r\n                count++;  \r\n            }  \r\n        }  \r\n    }  \r\n    return count;  \r\n}  \r\n  \r\nvoid print()  \r\n{  \r\n    int i,j;  \r\n    for(i=0;i<52;i++)  \r\n    {  \r\n        for(j=0;j<52;j++)  \r\n        {  \r\n            printf(\" %d \",map[i][j]);  \r\n        }  \r\n        printf(\"\\n\");  \r\n    }  \r\n}  \r\n  \r\nint main()  \r\n{  \r\n    int t,n,i,j,tem;  \r\n    char str[4];  \r\n    int a[30];  \r\n    while(scanf(\"%d\",&t)!=EOF)  \r\n    {  \r\n        while(t--)  \r\n        {  \r\n            memset(map,0,sizeof(map));  \r\n            scanf(\"%d\",&n);  \r\n            memset(a,0,sizeof(a));  \r\n            for(i=0;i<n;i++)  \r\n            {  \r\n                scanf(\"%s\",str);  \r\n                for(j=0;j<2;j++)  \r\n                {  \r\n                    a[i]+=change(str[j]);  \r\n                }  \r\n            }  \r\n            for(i=0;i<n;i++)  \r\n            {  \r\n                scanf(\"%s\",str);  \r\n                tem=0;  \r\n                for(j=0;j<2;j++)  \r\n                {  \r\n                    tem+=change(str[j]);  \r\n                }  \r\n                for(j=0;j<n;j++)  \r\n                {  \r\n                    if(tem>a[j])  \r\n                    {  \r\n                        map[tem][a[j]]=1;  \r\n                    }  \r\n                }  \r\n            }  \r\n            printf(\"%d\\n\",find());  \r\n        }  \r\n    }  \r\n    return 0;  \r\n}  '),(50,'#include<iostream>\r\n#include<string>\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct A\r\n{\r\nstring str;\r\nvoid change()\r\n{\r\nif(str[0]==\'A\') str[0]=\'E\';\r\nelse if(str[0]==\'T\') str[0]=\'A\';\r\nelse if(str[0]==\'J\') str[0]=\'B\';\r\nelse if(str[0]==\'Q\') str[0]=\'C\';\r\nelse if(str[0]==\'K\') str[0]=\'D\';\r\nif(str[1]==\'C\') str[1]=\'A\';\r\nelse if(str[1]==\'D\') str[1]=\'B\';\r\nelse if(str[1]==\'S\') str[1]=\'C\';\r\nelse str[1]=\'D\';\r\n}\r\nfriend bool operator<( const A& a, const A&b)\r\n{\r\nreturn a.str<b.str;\r\n}\r\n};\r\nint f(A* a,A* b,int len)\r\n{\r\nint count=0,i,j;\r\nfor(i=0;i<len;i++)\r\n{a[i].change();b[i].change();}\r\nsort(a,a+len);\r\nsort(b,b+len);\r\ni=j=len-1;\r\nwhile(i>=0)\r\n{\r\nif(a[i]<b[j]) {count++;i--;j--;}\r\nelse {i--;}\r\n}\r\nreturn count;\r\n}\r\nA a[26],b[26];\r\nint main ()\r\n{\r\nint n;\r\ncin>>n;\r\nwhile(n--)\r\n{\r\nint m,i;\r\ncin>>m;\r\nfor(i=0;i<m;i++)\r\ncin>>a[i].str;\r\nfor(i=0;i<m;i++)\r\ncin>>b[i].str;\r\ncout<<f(a,b,m)<<endl;\r\n}\r\n}'),(51,'#include<iostream> \r\nusing namespace std; \r\nstruct A \r\n{ \r\n\r\n\r\nint a,b; \r\n}; \r\nint a[1000000]={0}; \r\nA b[11]; \r\nint f(int m,int len,int& ol) \r\n{ \r\n\r\nint i; \r\nfor(i=ol/1000+1;i<=m/1000;i++) \r\n\r\n\r\n{ \r\nint j; \r\nfor(j=0;j<len;j++) \r\n\r\n\r\nif(i-b[j].a/1000>=0&&b[j].b+a[i-b[j].a/1000]>a[i]) \r\na[i]=b[j].b+a[i-b[j].a/1000]; \r\n} \r\n// cout<<ol<<endl; \r\nol=m; \r\n\r\nreturn a[m/1000]; \r\n} \r\nint main() \r\n{ \r\n\r\nint t; \r\ncin>>t; \r\nwhile(t--) \r\n{ \r\n\r\n\r\nint m,n; \r\ncin>>m>>n; \r\nint len; \r\ncin>>len; \r\nint i; \r\nfor(i=0;i<len;i++) \r\n\r\n\r\ncin>>b[i].a>>b[i].b; \r\nmemset(a,0,sizeof(a)); \r\nint mm=0; \r\nfor(i=0;i<n;i++) \r\n{ \r\n\r\n\r\nm+=f(m,len,mm); \r\n} \r\ncout<<m<<endl; \r\n\r\n\r\n} \r\nreturn 0; \r\n} '),(52,'#include<iostream>\r\nusing namespace std;\r\nstruct A\r\n{\r\nint a,b;\r\n};\r\nint a[1000000]={0};\r\nA b[11];\r\nint f(int m,int len,int& ol)\r\n{\r\nint i;\r\nfor(i=ol/1000+1;i<=m/1000;i++)\r\n{\r\nint j;\r\nfor(j=0;j<len;j++)\r\nif(i-b[j].a/1000>=0&&b[j].b+a[i-b[j].a/1000]>a[i])\r\na[i]=b[j].b+a[i-b[j].a/1000];\r\n}\r\n// cout<<ol<<endl;\r\nol=m;\r\nreturn a[m/1000];\r\n}\r\nint main()\r\n{\r\nint t;\r\ncin>>t;\r\nwhile(t--)\r\n{\r\nint m,n;\r\ncin>>m>>n;\r\nint len;\r\ncin>>len;\r\nint i;\r\nfor(i=0;i<len;i++)\r\ncin>>b[i].a>>b[i].b;\r\nmemset(a,0,sizeof(a));\r\nint mm=0;\r\nfor(i=0;i<n;i++)\r\n{\r\nm+=f(m,len,mm);\r\n}\r\ncout<<m<<endl;\r\n}\r\nreturn 0;\r\n}'),(53,'/*\r\nHDU 1964 Pipes\r\n插头DP\r\n每个格子之间的墙壁有一个花费，求用一个环经过每个格子一次的最小花费\r\nG++ 46ms\r\n*/\r\n\r\n#include<stdio.h>\r\n#include<iostream>\r\n#include<string.h>\r\n#include<algorithm>\r\nusing namespace std;\r\nconst int MAXD=15;\r\nconst int HASH=10007;\r\nconst int STATE=1000010;\r\n\r\nstruct Node\r\n{\r\n    int down,right;//每个格子下边和右边墙的花费\r\n}node[MAXD][MAXD];\r\nint N,M;\r\nint maze[MAXD][MAXD];\r\nint code[MAXD];\r\nint ch[MAXD];//最小表示法使用\r\nint ex,ey;//最后一个非障碍格子的坐标\r\n\r\nstruct HASHMAP\r\n{\r\n    int head[HASH],next[STATE],size;\r\n    int dp[STATE];\r\n    long long state[STATE];//最小表示法，最大是8^11,就是2^33,所以用long long\r\n    void init()\r\n    {\r\n        size=0;\r\n        memset(head,-1,sizeof(head));\r\n    }\r\n    void push(long long st,int ans)\r\n    {\r\n        int i,h=st%HASH;\r\n        for(i=head[h];i!=-1;i=next[i])\r\n           if(state[i]==st)\r\n           {\r\n               if(dp[i]>ans)dp[i]=ans;\r\n               return;\r\n           }\r\n        dp[size]=ans;\r\n        state[size]=st;\r\n        next[size]=head[h];\r\n        head[h]=size++;\r\n    }\r\n}hm[2];\r\nvoid decode(int *code,int m,long long st)\r\n{\r\n    for(int i=m;i>=0;i--)\r\n    {\r\n        code[i]=st&7;\r\n        st>>=3;\r\n    }\r\n}\r\nlong long encode(int *code,int m)\r\n{\r\n    int cnt=1;\r\n    memset(ch,-1,sizeof(ch));\r\n    ch[0]=0;\r\n    long long st=0;\r\n    for(int i=0;i<=m;i++)\r\n    {\r\n        if(ch[code[i]]==-1)ch[code[i]]=cnt++;\r\n        code[i]=ch[code[i]];\r\n        st<<=3;\r\n        st|=code[i];\r\n    }\r\n    return st;\r\n}\r\nvoid shift(int *code,int m)\r\n{\r\n    for(int i=m;i>0;i--)code[i]=code[i-1];\r\n    code[0]=0;\r\n}\r\nvoid dpblank(int i,int j,int cur)\r\n{\r\n    int k,left,up;\r\n    for(k=0;k<hm[cur].size;k++)\r\n    {\r\n        decode(code,M,hm[cur].state[k]);\r\n        left=code[j-1];\r\n        up=code[j];\r\n        if(left&&up)\r\n        {\r\n            if(left==up)//只出现在最后一个格子\r\n            {\r\n                if(i==ex&&j==ey)\r\n                {\r\n                    code[j-1]=code[j]=0;\r\n                    if(j==M)shift(code,M);\r\n                    hm[cur^1].push(encode(code,M),hm[cur].dp[k]);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                code[j-1]=code[j]=0;\r\n                for(int t=0;t<=M;t++)\r\n                    if(code[t]==left)\r\n                         code[t]=up;\r\n                if(j==M)shift(code,M);\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]);\r\n            }\r\n        }\r\n        else if((left&&(!up))||((!left)&&up))\r\n        {\r\n            int t;\r\n            if(left)t=left;\r\n            else t=up;\r\n            if(maze[i][j+1])\r\n            {\r\n                code[j-1]=0;\r\n                code[j]=t;\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]+node[i][j].right);\r\n            }\r\n            if(maze[i+1][j])\r\n            {\r\n                code[j-1]=t;\r\n                code[j]=0;\r\n                if(j==M)shift(code,M);\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]+node[i][j].down);\r\n            }\r\n        }\r\n        else//无插头\r\n        {\r\n            if(maze[i][j+1]&&maze[i+1][j])\r\n            {\r\n                code[j-1]=code[j]=13;\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]+node[i][j].down+node[i][j].right);\r\n            }\r\n        }\r\n    }\r\n}\r\nchar str[30];\r\nvoid init()\r\n{\r\n    scanf(\"%d%d%*c\",&N,&M);//跳过一个字符\r\n    memset(maze,0,sizeof(maze));\r\n    for(int i=1;i<=N;i++)\r\n      for(int j=1;j<=M;j++)\r\n          maze[i][j]=1;\r\n    gets(str);\r\n    for(int i=1;i<N;i++)\r\n    {\r\n        gets(str);\r\n        for(int j=1;j<M;j++)\r\n          node[i][j].right=str[2*j]-\'0\';\r\n        gets(str);\r\n        for(int j=1;j<=M;j++)\r\n          node[i][j].down=str[2*j-1]-\'0\';\r\n    }\r\n    gets(str);\r\n    for(int j=1;j<M;j++)\r\n        node[N][j].right=str[2*j]-\'0\';\r\n    gets(str);\r\n    ex=N;\r\n    ey=M;\r\n}\r\nvoid solve()\r\n{\r\n    int i,j,cur=0;\r\n    int ans=0;\r\n    hm[cur].init();\r\n    hm[cur].push(0,0);\r\n    for(i=1;i<=N;i++)\r\n      for(j=1;j<=M;j++)\r\n      {\r\n          hm[cur^1].init();\r\n          dpblank(i,j,cur);\r\n          cur^=1;\r\n      }\r\n    for(i=0;i<hm[cur].size;i++)\r\n        ans+=hm[cur].dp[i];\r\n    printf(\"%d\\n\",ans);\r\n}\r\nint main()\r\n{\r\n   // freopen(\"in.txt\",\"r\",stdin);\r\n   // freopen(\"out.txt\",\"w\",stdout);\r\n    int T;\r\n    scanf(\"%d\",&T);\r\n    while(T--)\r\n    {\r\n        init();\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n'),(54,'#include<stdio.h>\r\n#include<iostream>\r\n#include<string.h>\r\n#include<algorithm>\r\nusing namespace std;\r\nconst int MAXD=15;\r\nconst int HASH=10007;\r\nconst int STATE=1000010;\r\n\r\nstruct Node\r\n{\r\n    int down,right;//每个格子下边和右边墙的花费\r\n}node[MAXD][MAXD];\r\nint N,M;\r\nint maze[MAXD][MAXD];\r\nint code[MAXD];\r\nint ch[MAXD];//最小表示法使用\r\nint ex,ey;//最后一个非障碍格子的坐标\r\n\r\nstruct HASHMAP\r\n{\r\n    int head[HASH],next[STATE],size;\r\n    int dp[STATE];\r\n    long long state[STATE];//最小表示法，最大是8^11,就是2^33,所以用long long\r\n    void init()\r\n    {\r\n        size=0;\r\n        memset(head,-1,sizeof(head));\r\n    }\r\n    void push(long long st,int ans)\r\n    {\r\n        int i,h=st%HASH;\r\n        for(i=head[h];i!=-1;i=next[i])\r\n           if(state[i]==st)\r\n           {\r\n               if(dp[i]>ans)dp[i]=ans;\r\n               return;\r\n           }\r\n        dp[size]=ans;\r\n        state[size]=st;\r\n        next[size]=head[h];\r\n        head[h]=size++;\r\n    }\r\n}hm[2];\r\nvoid decode(int *code,int m,long long st)\r\n{\r\n    for(int i=m;i>=0;i--)\r\n    {\r\n        code[i]=st&7;\r\n        st>>=3;\r\n    }\r\n}\r\nlong long encode(int *code,int m)\r\n{\r\n    int cnt=1;\r\n    memset(ch,-1,sizeof(ch));\r\n    ch[0]=0;\r\n    long long st=0;\r\n    for(int i=0;i<=m;i++)\r\n    {\r\n        if(ch[code[i]]==-1)ch[code[i]]=cnt++;\r\n        code[i]=ch[code[i]];\r\n        st<<=3;\r\n        st|=code[i];\r\n    }\r\n    return st;\r\n}\r\nvoid shift(int *code,int m)\r\n{\r\n    for(int i=m;i>0;i--)code[i]=code[i-1];\r\n    code[0]=0;\r\n}\r\nvoid dpblank(int i,int j,int cur)\r\n{\r\n    int k,left,up;\r\n    for(k=0;k<hm[cur].size;k++)\r\n    {\r\n        decode(code,M,hm[cur].state[k]);\r\n        left=code[j-1];\r\n        up=code[j];\r\n        if(left&&up)\r\n        {\r\n            if(left==up)//只出现在最后一个格子\r\n            {\r\n                if(i==ex&&j==ey)\r\n                {\r\n                    code[j-1]=code[j]=0;\r\n                    if(j==M)shift(code,M);\r\n                    hm[cur^1].push(encode(code,M),hm[cur].dp[k]);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                code[j-1]=code[j]=0;\r\n                for(int t=0;t<=M;t++)\r\n                    if(code[t]==left)\r\n                         code[t]=up;\r\n                if(j==M)shift(code,M);\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]);\r\n            }\r\n        }\r\n        else if((left&&(!up))||((!left)&&up))\r\n        {\r\n            int t;\r\n            if(left)t=left;\r\n            else t=up;\r\n            if(maze[i][j+1])\r\n            {\r\n                code[j-1]=0;\r\n                code[j]=t;\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]+node[i][j].right);\r\n            }\r\n            if(maze[i+1][j])\r\n            {\r\n                code[j-1]=t;\r\n                code[j]=0;\r\n                if(j==M)shift(code,M);\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]+node[i][j].down);\r\n            }\r\n        }\r\n        else//无插头\r\n        {\r\n            if(maze[i][j+1]&&maze[i+1][j])\r\n            {\r\n                code[j-1]=code[j]=13;\r\n                hm[cur^1].push(encode(code,M),hm[cur].dp[k]+node[i][j].down+node[i][j].right);\r\n            }\r\n        }\r\n    }\r\n}\r\nchar str[30];\r\nvoid init()\r\n{\r\n    scanf(\"%d%d%*c\",&N,&M);//跳过一个字符\r\n    memset(maze,0,sizeof(maze));\r\n    for(int i=1;i<=N;i++)\r\n      for(int j=1;j<=M;j++)\r\n          maze[i][j]=1;\r\n    gets(str);\r\n    for(int i=1;i<N;i++)\r\n    {\r\n        gets(str);\r\n        for(int j=1;j<M;j++)\r\n          node[i][j].right=str[2*j]-\'0\';\r\n        gets(str);\r\n        for(int j=1;j<=M;j++)\r\n          node[i][j].down=str[2*j-1]-\'0\';\r\n    }\r\n    gets(str);\r\n    for(int j=1;j<M;j++)\r\n        node[N][j].right=str[2*j]-\'0\';\r\n    gets(str);\r\n    ex=N;\r\n    ey=M;\r\n}\r\nvoid solve()\r\n{\r\n    int i,j,cur=0;\r\n    int ans=0;\r\n    hm[cur].init();\r\n    hm[cur].push(0,0);\r\n    for(i=1;i<=N;i++)\r\n      for(j=1;j<=M;j++)\r\n      {\r\n          hm[cur^1].init();\r\n          dpblank(i,j,cur);\r\n          cur^=1;\r\n      }\r\n    for(i=0;i<hm[cur].size;i++)\r\n        ans+=hm[cur].dp[i];\r\n    printf(\"%d\\n\",ans);\r\n}\r\nint main()\r\n{\r\n   // freopen(\"in.txt\",\"r\",stdin);\r\n   // freopen(\"out.txt\",\"w\",stdout);\r\n    int T;\r\n    scanf(\"%d\",&T);\r\n    while(T--)\r\n    {\r\n        init();\r\n        solve();\r\n    }\r\n    return 0;\r\n}'),(55,'#include <stdio.h> \r\n  \r\n#define MAXN (80) \r\n  \r\nint modexp(int a,int b, int p) \r\n{ \r\n  int tmp; \r\n  if (b==0) return 1; \r\n  if (b==1) return a; \r\n  tmp=modexp(a,b/2,p); \r\n  tmp=(tmp*tmp) % p; \r\n  if (b & 1) tmp=(tmp*a) % p; \r\n  return tmp; \r\n} \r\n  \r\nint main(void) \r\n{ \r\n  char str[MAXN+1]; \r\n  int i,j,k,p,n,b[MAXN],Mx[MAXN][MAXN]; \r\n  scanf(\"%d\",&n); \r\n  while (n--) \r\n  { \r\n    scanf(\"%d %s\",&p,str); \r\n    for (i=0;i<strlen(str);i++) b[i]=str[i]==\'*\'?0:str[i]-\'a\'+1; \r\n    for (i=0;i<strlen(str);i++) \r\n      for (j=0;j<strlen(str);j++) \r\n        Mx[i][j]=modexp(i+1,j,p); \r\n    for (i=0;i<strlen(str);i++) \r\n      for (j=i+1;j<strlen(str);j++) \r\n        { \r\n          int mult=(modexp(Mx[i][i],p-2,p)*Mx[j][i]) % p; \r\n          for (k=i;k<strlen(str);k++) \r\n            Mx[j][k]=(p+Mx[j][k]-((Mx[i][k]*mult) % p)) % p; \r\n          b[j]=(p+b[j]-((b[i]*mult) % p)) % p; \r\n        } \r\n    for (i=strlen(str)-1;i>=0;i--) \r\n    { \r\n      int sum=b[i]; \r\n      for (j=i+1;j<strlen(str);j++) \r\n        sum=(p+sum-(Mx[i][j]*b[j] % p)) % p;   \r\n      b[i]=(sum*modexp(Mx[i][i],p-2,p)) % p; \r\n    } \r\n    for (i=0;i<strlen(str)-1;i++) \r\n      printf(\"%d \",b[i]); \r\n    printf(\"%d\\n\",b[strlen(str)-1]);   \r\n  } \r\n  return 0; \r\n}'),(56,'#include <stdio.h>\n\n#define MAXN (80)\n\nint modexp(int a,int b, int p)\n{\n  int tmp;\n  if (b==0) return 1;\n  if (b==1) return a;\n  tmp=modexp(a,b/2,p);\n  tmp=(tmp*tmp) % p;\n  if (b & 1) tmp=(tmp*a) % p;\n  return tmp;\n}\n\nint main(void)\n{\n  char str[MAXN+1];\n  int i,j,k,p,n,b[MAXN],Mx[MAXN][MAXN];\n  scanf(\"%d\",&n);\n  while (n--)\n  {\n    scanf(\"%d %s\",&p,str);\n    for (i=0;i<strlen(str);i++) b[i]=str[i]==\'*\'?0:str[i]-\'a\'+1;\n    for (i=0;i<strlen(str);i++)\n      for (j=0;j<strlen(str);j++)\n        Mx[i][j]=modexp(i+1,j,p);\n    for (i=0;i<strlen(str);i++)\n      for (j=i+1;j<strlen(str);j++)\n        {\n          int mult=(modexp(Mx[i][i],p-2,p)*Mx[j][i]) % p;\n          for (k=i;k<strlen(str);k++)\n            Mx[j][k]=(p+Mx[j][k]-((Mx[i][k]*mult) % p)) % p;\n          b[j]=(p+b[j]-((b[i]*mult) % p)) % p;\n        }\n    for (i=strlen(str)-1;i>=0;i--)\n    {\n      int sum=b[i];\n      for (j=i+1;j<strlen(str);j++)\n        sum=(p+sum-(Mx[i][j]*b[j] % p)) % p;  \n      b[i]=(sum*modexp(Mx[i][i],p-2,p)) % p;\n    }\n    for (i=0;i<strlen(str)-1;i++)\n      printf(\"%d \",b[i]);\n    printf(\"%d\\n\",b[strlen(str)-1]);  \n  }\n  return 0;\n}'),(57,'#include<stdio.h>\r\n#include<stdlib.h>\r\nint x[55],y[55],cost[55][55];\r\nint cas,n,i,j,k,best,sum;\r\n#define maxn 1<<30\r\nint min(int a,int b)\r\n{\r\n    return ((a)<(b)?(a):(b));\r\n}\r\nint max(int a,int b)\r\n{\r\n    return ((a)>(b)?(a):(b));\r\n}\r\n\r\nint fuhao(int a)\r\n{\r\n    return ((a)>(0)?(1):(0));\r\n}\r\nint w(int i,int j,int k)\r\n{\r\n    return ((x[j]-x[i])*(y[k]-y[i])-(y[j]-y[i])*(x[k]-x[i]));\r\n\r\n}\r\nint main()\r\n{\r\n    scanf(\"%d\",&cas);\r\n    while(cas--)\r\n    {\r\n        scanf(\"%d\",&n);\r\n        for(i=0; i<n; i++)\r\n        {\r\n            scanf(\"%d%d\",&x[i],&y[i]);\r\n            if(i>1)\r\n                sum+=w(0,i-1,i);\r\n            else\r\n                sum=0;\r\n            cost[i][(i+1)%n]=0;\r\n        }\r\n        for(i=2; i<n; i++)\r\n            for(j=0; j<n; j++)\r\n            {\r\n                cost[j][(j+i)%n]=(1<<30);\r\n                for(k=1; k<i; k++)\r\n                {\r\n                    best=w(j,(j+k)%n,(j+i)%n);\r\n                    if(fuhao(sum)==fuhao(best))\r\n                        cost[j][(j+i)%n]=min(cost[j][(j+i)%n],max(max(abs(best),cost[(j+k)%n][(j+i)%n]),cost[j][(j+k)%n]));\r\n                }\r\n            }\r\n        printf(\"%.1lf\\n\",(double)cost[1][0]/2);\r\n    }\r\n}\r\n'),(58,'#include<stdio.h>\r\n#include<stdlib.h>\r\nint x[55],y[55],cost[55][55];\r\nint cas,n,i,j,k,best,sum;\r\n#define maxn 1<<30\r\nint min(int a,int b)\r\n{\r\n    return ((a)<(b)?(a):(b));\r\n}\r\nint max(int a,int b)\r\n{\r\n    return ((a)>(b)?(a):(b));\r\n}\r\n\r\nint fuhao(int a)\r\n{\r\n    return ((a)>(0)?(1):(0));\r\n}\r\nint w(int i,int j,int k)\r\n{\r\n    return ((x[j]-x[i])*(y[k]-y[i])-(y[j]-y[i])*(x[k]-x[i]));\r\n\r\n}\r\nint main()\r\n{\r\n    scanf(\"%d\",&cas);\r\n    while(cas--)\r\n    {\r\n        scanf(\"%d\",&n);\r\n        for(i=0; i<n; i++)\r\n        {\r\n            scanf(\"%d%d\",&x[i],&y[i]);\r\n            if(i>1)\r\n                sum+=w(0,i-1,i);\r\n            else\r\n                sum=0;\r\n            cost[i][(i+1)%n]=0;\r\n        }\r\n        for(i=2; i<n; i++)\r\n            for(j=0; j<n; j++)\r\n            {\r\n                cost[j][(j+i)%n]=(1<<30);\r\n                for(k=1; k<i; k++)\r\n                {\r\n                    best=w(j,(j+k)%n,(j+i)%n);\r\n                    if(fuhao(sum)==fuhao(best))\r\n                        cost[j][(j+i)%n]=min(cost[j][(j+i)%n],max(max(abs(best),cost[(j+k)%n][(j+i)%n]),cost[j][(j+k)%n]));\r\n                }\r\n            }\r\n        printf(\"%.1lf\\n\",(double)cost[1][0]/2);\r\n    }\r\n}\r\n'),(59,'#include <stdio.h>\r\n#include <string.h>\r\n\r\nconst int N = 55;\r\nconst int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\r\n\r\nint t, n, r, x, y, g[N][N];\r\n\r\nvoid init() {\r\n  memset(g, 0, sizeof(g));\r\n  scanf(\"%d%d\", &n, &r);\r\n  for (int i = 0; i < r; i++) {\r\n    scanf(\"%d%d\", &x, &y);\r\n    g[x][y] = 1;\r\n  }\r\n  scanf(\"%d%d\", &x, &y);\r\n}\r\n\r\nvoid solve() {\r\n  int v;\r\n  if (x == n + 1) v = 2;\r\n  else if (x == 0) v = 0;\r\n  else if (y == n + 1) v = 3;\r\n  else v = 1;\r\n  x += d[v][0]; y += d[v][1];\r\n  while (x != 0 && x != n + 1 && y != 0 && y != n + 1) {\r\n    if (g[x][y]) v = (v + 3) % 4;\r\n    x += d[v][0]; y += d[v][1];\r\n  }\r\n  printf(\"%d %d\\n\", x, y);\r\n}\r\n\r\nint main() {\r\n  scanf(\"%d\", &t);\r\n  while (t--) {\r\n    init();\r\n    solve();\r\n  }\r\n  return 0;\r\n}\r\n'),(60,'#include <stdio.h>\n\nint main(void)\n{\n	int t, n, r, i, j, x, y;\n	char A[52][52] = {{\"0\"}}, d;\n	char dir[4][2] = {\n		{0, 1}, {-1, 0}, {0, -1}, {1, 0}\n	};\n	\n	scanf(\"%d\", &t);\n	while (t-- && scanf(\"%d%d\", &n, &r))\n	{\n		for (i = 1; i <= n; i++)\n		{\n			for (j = 1; j <= n; j++)\n			        A[i][j] = 0;\n		}\n		for (i = 0; i < r && scanf(\"%d%d\", &y, &x); i++)\n		        A[y][x] = 1;\n		scanf(\"%d%d\", &y, &x);\n		if (x && !y) d = 0;\n		if (x == n + 1 && y) d = 1;\n		if (x && y == n + 1) d = 2;\n		if (!x && y) d = 3;\n		do\n		{\n			x += dir[d][0];\n			y += dir[d][1];\n			if (A[y][x]) d = (d + 1) % 4;\n		}while (x > 0 && x <= n && y > 0 && y <= n);\n		printf(\"%d %d\\n\", y, x);\n	}\n	\n	return 0;\n}\n'),(61,'#include <algorithm>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <cstdio>\r\nusing namespace std;\r\n\r\nint n,st[10],v[10];\r\ndouble k[10],r[10],h[10],R[10],d[10],best;\r\ndouble g[10][10];\r\ndouble calc(int a,int b)\r\n{\r\n    if (r[b]<=r[a]&&(\r\n        (h[b]>=h[a]&&k[b]*h[a]+r[b]<=R[a])||\r\n        ( h[b]<h[a]&&R[b]<=k[a]*h[b]+r[a])  ))\r\n        return 0;    \r\n    if (r[b]>=R[a]) return h[a];\r\n    if (k[b]<=k[a]) return (r[b]-r[a])/k[a];\r\n    if (R[b]>=R[a]) return h[a]-(R[a]-r[b])/k[b];\r\n    return (R[b]-r[a])/k[a]-h[b];   \r\n}\r\nvoid search(int dep)\r\n{\r\n    int i,j;\r\n    double tmp;\r\n    if (dep>=n)\r\n    {\r\n        tmp=0;\r\n        for (i=0;i<n;i++)\r\n        tmp=max(tmp,d[i]+h[st[i]]);\r\n        best=tmp;\r\n        return ;\r\n    }\r\n    for (i=0;i<n;i++)\r\n    if (!v[i])\r\n    {\r\n        v[i]=true;\r\n        d[dep]=0;\r\n        for (j=0;j<dep;j++)\r\n        d[dep]=max(d[dep],g[st[j]][i]+d[j]);        \r\n        st[dep]=i;\r\n        if (d[dep]+h[i]<best) \r\n        search(dep+1);\r\n        v[i]=false;\r\n    }    \r\n}\r\nint main()\r\n{    \r\n    int i,j,ca;    \r\n    scanf(\"%d\",&ca);\r\n    while (ca--)\r\n    {\r\n        scanf(\"%d\",&n);\r\n        for (i=0;i<n;i++)\r\n        {\r\n            scanf(\"%lf%lf%lf\",&h[i],&r[i],&R[i]);\r\n            k[i]=(R[i]-r[i])/h[i];\r\n        }\r\n        memset(v,0,sizeof(v));\r\n        best=10000000;\r\n        for (i=0;i<n;i++)\r\n            for (j=0;j<n;j++)\r\n                g[i][j]=calc(i,j);\r\n        search(0);\r\n        printf(\"%d\\n\",int(best));\r\n    }\r\n\r\n    return 0;\r\n}    \r\n'),(62,'#include <algorithm>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <cstdio>\r\nusing namespace std;\r\n \r\nint n,st[10],v[10];\r\ndouble k[10],r[10],h[10],R[10],d[10],best;\r\ndouble g[10][10];\r\ndouble calc(int a,int b)\r\n{\r\n    if (r[b]<=r[a]&&(\r\n        (h[b]>=h[a]&&k[b]*h[a]+r[b]<=R[a])||\r\n        ( h[b]<h[a]&&R[b]<=k[a]*h[b]+r[a])  ))\r\n        return 0;    \r\n    if (r[b]>=R[a]) return h[a];\r\n    if (k[b]<=k[a]) return (r[b]-r[a])/k[a];\r\n    if (R[b]>=R[a]) return h[a]-(R[a]-r[b])/k[b];\r\n    return (R[b]-r[a])/k[a]-h[b];   \r\n}\r\nvoid search(int dep)\r\n{\r\n    int i,j;\r\n    double tmp;\r\n    if (dep>=n)\r\n    {\r\n        tmp=0;\r\n        for (i=0;i<n;i++)\r\n        tmp=max(tmp,d[i]+h[st[i]]);\r\n        best=tmp;\r\n        return ;\r\n    }\r\n    for (i=0;i<n;i++)\r\n    if (!v[i])\r\n    {\r\n        v[i]=true;\r\n        d[dep]=0;\r\n        for (j=0;j<dep;j++)\r\n        d[dep]=max(d[dep],g[st[j]][i]+d[j]);        \r\n        st[dep]=i;\r\n        if (d[dep]+h[i]<best) \r\n        search(dep+1);\r\n        v[i]=false;\r\n    }    \r\n}\r\nint main()\r\n{    \r\n    int i,j,ca;    \r\n    scanf(\"%d\",&ca);\r\n    while (ca--)\r\n    {\r\n        scanf(\"%d\",&n);\r\n        for (i=0;i<n;i++)\r\n        {\r\n            scanf(\"%lf%lf%lf\",&h[i],&r[i],&R[i]);\r\n            k[i]=(R[i]-r[i])/h[i];\r\n        }\r\n        memset(v,0,sizeof(v));\r\n        best=10000000;\r\n        for (i=0;i<n;i++)\r\n            for (j=0;j<n;j++)\r\n                g[i][j]=calc(i,j);\r\n        search(0);\r\n        printf(\"%d\\n\",int(best));\r\n    }\r\n \r\n    return 0;\r\n}    '),(63,'#include<stdio.h>\r\n#include<string.h>\r\n#include<algorithm>\r\n#include<vector>\r\n#define clr(a,b) memset(a,b,sizeof(a));\r\nusing namespace std;\r\n\r\nconst int inf=1000000;\r\nconst int N=100000;\r\nvector<int> vc[N];\r\nbool trap[N];\r\nint i,j,n,m;\r\nint dp[N][3];\r\nvoid dfs(int u,int f){\r\n    dp[u][0]=dp[u][1]=dp[u][2]=inf;\r\n    if(trap[u]){\r\n        dp[u][0]=inf; dp[u][1]=inf; dp[u][2]=0;\r\n        return ;\r\n    }\r\n    if(u!=1&&vc[u].size()==1){\r\n        dp[u][0]=0; dp[u][1]=inf; dp[u][2]=1;\r\n        return ;\r\n    }\r\n    int l=-1,r=-1;\r\n    for(int i=0;i<(int)vc[u].size();i++){\r\n        int v=vc[u][i];\r\n        if(v==f) continue;\r\n        dfs(v,u);\r\n        if(l==-1) l=v;\r\n        else r=v;\r\n    }\r\n    if(r==-1) dp[u][0]=dp[l][0],dp[u][1]=dp[l][1],dp[u][2]=dp[l][2];\r\n    else{\r\n        dp[u][0]=dp[l][0]+dp[r][0];\r\n        dp[u][1]=min(dp[u][1],dp[l][0]+dp[r][2]);\r\n        dp[u][1]=min(dp[u][1],dp[r][0]+dp[l][2]);\r\n        dp[u][1]=min(dp[u][1],dp[l][0]+dp[r][1]);\r\n        dp[u][1]=min(dp[u][1],dp[r][0]+dp[l][1]);\r\n        dp[u][2]=dp[u][1]+1;\r\n        dp[u][2]=min(dp[u][2],dp[l][2]+dp[r][2]);\r\n    }\r\n}\r\nint main(){\r\n//    freopen(\"in.txt\",\"r\",stdin);\r\n    int cas=0;\r\n    while(1){\r\n        cas++;\r\n        scanf(\"%d%d\",&n,&m);\r\n        if(n==0&&m==0) break;\r\n        clr(dp,0);\r\n        for(i=1;i<=n;i++){\r\n            vc[i].clear();\r\n            trap[i]=false;\r\n        }\r\n        for(i=1;i<=n;i++){\r\n            int num;scanf(\"%d\",&num);\r\n            for(j=1;j<=num;j++){\r\n                int x;scanf(\"%d\",&x);\r\n                vc[i].push_back(x);\r\n            }\r\n        }\r\n        for(i=1;i<=m;i++){\r\n            int u;scanf(\"%d\",&u);\r\n            trap[u]=1;\r\n        }\r\n        dfs(1,1);\r\n        int ans=0;\r\n        ans=dp[1][2];\r\n        printf(\"%d\\n\",ans);\r\n    }\r\n    return 0;\r\n}'),(64,'#include<stdio.h>\r\n#include<string.h>\r\n#include<algorithm>\r\n#include<vector>\r\n#define clr(a,b) memset(a,b,sizeof(a));\r\nusing namespace std;\r\n\r\nconst int inf=1000000;\r\nconst int N=100000;\r\nvector<int> vc[N];\r\nbool trap[N];\r\nint i,j,n,m;\r\nint dp[N][3];\r\nvoid dfs(int u,int f){\r\n    dp[u][0]=dp[u][1]=dp[u][2]=inf;\r\n    if(trap[u]){\r\n        dp[u][0]=inf; dp[u][1]=inf; dp[u][2]=0;\r\n        return ;\r\n    }\r\n    if(u!=1&&vc[u].size()==1){\r\n        dp[u][0]=0; dp[u][1]=inf; dp[u][2]=1;\r\n        return ;\r\n    }\r\n    int l=-1,r=-1;\r\n    for(int i=0;i<(int)vc[u].size();i++){\r\n        int v=vc[u][i];\r\n        if(v==f) continue;\r\n        dfs(v,u);\r\n        if(l==-1) l=v;\r\n        else r=v;\r\n    }\r\n    if(r==-1) dp[u][0]=dp[l][0],dp[u][1]=dp[l][1],dp[u][2]=dp[l][2];\r\n    else{\r\n        dp[u][0]=dp[l][0]+dp[r][0];\r\n        dp[u][1]=min(dp[u][1],dp[l][0]+dp[r][2]);\r\n        dp[u][1]=min(dp[u][1],dp[r][0]+dp[l][2]);\r\n        dp[u][1]=min(dp[u][1],dp[l][0]+dp[r][1]);\r\n        dp[u][1]=min(dp[u][1],dp[r][0]+dp[l][1]);\r\n        dp[u][2]=dp[u][1]+1;\r\n        dp[u][2]=min(dp[u][2],dp[l][2]+dp[r][2]);\r\n    }\r\n}\r\nint main(){\r\n//    freopen(\"in.txt\",\"r\",stdin);\r\n    int cas=0;\r\n    while(1){\r\n        cas++;\r\n        scanf(\"%d%d\",&n,&m);\r\n        if(n==0&&m==0) break;\r\n        clr(dp,0);\r\n        for(i=1;i<=n;i++){\r\n            vc[i].clear();\r\n            trap[i]=false;\r\n        }\r\n        for(i=1;i<=n;i++){\r\n            int num;scanf(\"%d\",&num);\r\n            for(j=1;j<=num;j++){\r\n                int x;scanf(\"%d\",&x);\r\n                vc[i].push_back(x);\r\n            }\r\n        }\r\n        for(i=1;i<=m;i++){\r\n            int u;scanf(\"%d\",&u);\r\n            trap[u]=1;\r\n        }\r\n        dfs(1,1);\r\n        int ans=0;\r\n        ans=dp[1][2];\r\n        printf(\"%d\\n\",ans);\r\n    }\r\n    return 0;\r\n}'),(65,'#include<stdio.h>\r\n#include<string.h>\r\nint a[310];\r\nbool flag[1000010];\r\nint set[310];\r\nvoid clear(int n)\r\n{\r\n    for(int i=0;i<n;i++)\r\n      flag[set[i]]=false;\r\n}\r\nint main()\r\n{\r\n    int j;\r\n    int T;\r\n    int n;\r\n    int m;\r\n    bool ff;\r\n    scanf(\"%d\",&T);\r\n    while(T--)\r\n    {\r\n        scanf(\"%d\",&n);\r\n        for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\r\n        memset(flag,false,sizeof(flag));\r\n        m=0;\r\n        for(j=n;;j++)\r\n        {\r\n            clear(m);\r\n            m=0;\r\n            ff=true;\r\n            for(int i=0;i<n;i++)\r\n            {\r\n                int t=a[i]%j;\r\n                if(flag[t]==true)\r\n                {\r\n                    ff=false;\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    flag[t]=true;\r\n                    set[m++]=t;\r\n                }\r\n            }\r\n            if(ff) break;\r\n        }\r\n        printf(\"%d\\n\",j);\r\n\r\n    }\r\n    return 0;\r\n}\r\n'),(66,'#include <iostream>\r\n#include <cstring>\r\n#include<bitset>\r\n#include<map>\r\nusing namespace std;\r\nint arr[301];\r\nint main()\r\n{\r\nmap<int,int> m;\r\nint test;\r\ncin>>test;\r\nwhile(test--)\r\n{ int n;\r\ncin>>n;int i,j;\r\nfor(i=0;i<n;i++)\r\ncin>>arr[i];\r\nfor(j=n;1;j++)\r\n{ m.clear();\r\nfor(i=0;i<n;i++)\r\nif(++m[arr[i]%j]==2) break;\r\nif(m.size()==n) break;\r\n}\r\ncout<<j<<endl;\r\n}\r\n}'),(67,'#include<cstdio>\r\n#include<cstring>\r\nstruct p\r\n{\r\n    int h;\r\n    char music[101];\r\n    char sport[101];\r\n}boy[501],girl[501];\r\nbool g[501][501];\r\nint m,n,bn,gn;\r\nint match()\r\n{\r\n    int s[501],t[501],match1[501],match2[501],p,q,i,j,k,ret=0;\r\n    memset(match1,0xff,sizeof(match1));\r\n    memset(match2,0xff,sizeof(match2));\r\n    for(i=0;i<n;ret+=(match1[i]>=0),i++)\r\n    {\r\n        memset(t,0xff,sizeof(t));\r\n        for(s[p=q=0]=i;p<=q&&match1[i]<0;p++)\r\n            for(k=s[p],j=0;j<m&&match1[i]<0;j++)\r\n                if(g[k][j]&&t[j]<0)\r\n                {\r\n                    s[++q]=match2[j],t[j]=k;\r\n                    if(s[q]<0)\r\n                        for(p=j;p>=0;j=p)\r\n                            match2[j]=k=t[j],p=match1[k],match1[k]=j;\r\n                }\r\n    }\r\n    return ret;\r\n}\r\nint abs(int a)\r\n{\r\n    return a>0?a:-a;\r\n}\r\nint main()\r\n{\r\n    int i,j,cn,ht;\r\n    char t1[2],t2[101],t3[101];\r\n    scanf(\"%d\",&cn);\r\n    while(cn--)\r\n    {\r\n        scanf(\"%d\",&n);\r\n        bn=gn=0;\r\n        for(i=0;i<n;i++)\r\n        {\r\n            scanf(\"%d %s %s %s\",&ht,t1,t2,t3);\r\n            if(t1[0]==\'M\')\r\n            {\r\n                boy[bn].h=ht;\r\n                strcpy(boy[bn].music,t2);\r\n                strcpy(boy[bn].sport,t3);\r\n                bn++;\r\n            }\r\n            else\r\n            {\r\n                girl[gn].h=ht;\r\n                strcpy(girl[gn].music,t2);\r\n                strcpy(girl[gn].sport,t3);\r\n                gn++;\r\n            }\r\n        }\r\n        n=bn,m=gn;\r\n        memset(g,0,sizeof(g));\r\n        for(i=0;i<n;i++)\r\n            for(j=0;j<m;j++)\r\n            {\r\n                if(abs(boy[i].h-girl[j].h)<=40&&strcmp(boy[i].music,girl[j].music)==0&&strcmp(boy[i].sport,girl[j].sport))\r\n                g[i][j]=1;\r\n            }\r\n        printf(\"%d\\n\",bn+gn-match());\r\n    }\r\n    return 0;\r\n}\r\n'),(68,'#include <cmath>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\nusing namespace std;\r\nstruct node\r\n{\r\n    int h;\r\n    char sex;\r\n    char mus[110];\r\n    char spo[110];\r\n}M[510],F[510];\r\nint n,m,f,mmap[550][550],pre[550],vis[550];\r\nint pd(int i,int j)\r\n{\r\n    if( abs(M[i].h - F[j].h) > 40 )\r\n        return 0;\r\n    if( strcmp(M[i].mus,F[j].mus) )\r\n        return 0;\r\n    if( strcmp(M[i].spo,F[j].spo) == 0 )\r\n        return 0;\r\n    return 1;\r\n}\r\nint dfs(int x)\r\n{\r\n    for(int i=m+1;i<=m+f;i++){\r\n        if(!vis[i]&&mmap[x][i]){\r\n            vis[i]=1;\r\n            if(pre[i]==-1||dfs(pre[i])){\r\n                pre[i]=x;\r\n                return 1;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nint main()\r\n{\r\n    int i,j,t,h;\r\n    char str[100];\r\n    scanf(\"%d\",&t);\r\n    while(t--){\r\n        scanf(\"%d\",&n);\r\n        m=f=1;\r\n        memset(mmap,0,sizeof(mmap));\r\n        memset(pre,-1,sizeof(pre));\r\n        memset(M,0,sizeof(M));\r\n        memset(F,0,sizeof(F));\r\n        for(i=1;i<=n;i++){\r\n            scanf(\"%d%s\",&h,str);\r\n            if(str[0]==\'M\'){\r\n                scanf(\"%s%s\",M[m].mus,M[m].spo);\r\n                M[m].h=h;\r\n                M[m++].sex=\'M\';\r\n            }\r\n            else {\r\n                scanf(\"%s%s\",F[f].mus,F[f].spo);\r\n                F[f].h=h;\r\n                F[f++].sex=\'F\';\r\n            }\r\n        }\r\n        for(i=1;i<=m;i++){\r\n            for(j=1;j<=f;j++){\r\n                if(pd(i,j))\r\n                mmap[i][m+j]=1;\r\n            }\r\n        }\r\n        int ans=0;\r\n        for(i=1;i<=m;i++){\r\n            memset(vis,0,sizeof(vis));\r\n            ans+=dfs(i);\r\n        }\r\n        printf(\"%d\\n\",n-ans);\r\n    }\r\n}\r\n'),(69,'#include <stdio.h>\r\n#include <algorithm>\r\n\r\nint floorNum;\r\nint friendNum;\r\nint boxleftNum;\r\n\r\nint originalUpTime[1005];\r\n\r\nint testNum;\r\nint timeCost;\r\nint lastOne;\r\nint i,j,k;\r\n\r\nint main()\r\n{\r\n    scanf(\"%d\", &testNum);\r\n    while(testNum--)\r\n    {\r\n        scanf(\"%d %d %d\", &friendNum, &floorNum, &boxleftNum);\r\n        for(i = 0; i < friendNum; i++)\r\n        {\r\n            scanf(\"%d %d\", &j, &k);\r\n            if(k)\r\n            {\r\n                originalUpTime[i] = 3 * floorNum - j;\r\n            }\r\n            else\r\n            {\r\n                originalUpTime[i] = floorNum + j;\r\n            }\r\n        }\r\n        std::sort(originalUpTime, originalUpTime + friendNum);\r\n        lastOne = boxleftNum % friendNum;\r\n        if(lastOne)\r\n        {\r\n            timeCost = (boxleftNum / friendNum) * 2 * floorNum + originalUpTime[lastOne - 1];\r\n        }\r\n        else\r\n        {\r\n            timeCost = (boxleftNum / friendNum - 1) * 2 * floorNum + originalUpTime[friendNum - 1];\r\n        }\r\n        printf(\"%d\\n\", timeCost);\r\n    }\r\n    return 0;\r\n}\r\n'),(70,'#include <iostream>\r\n#include <algorithm>\r\n#include <cmath>\r\nusing namespace std;\r\nint main()\r\n{\r\nint cases;\r\ncin>>cases;\r\nwhile(cases--)\r\n{\r\nint p,f,b,i;\r\nint arr[1001]={0};\r\ncin>>p>>f>>b;\r\nfor(i=0;i<p;i++)\r\n{\r\ncin>>arr[i];\r\nint flag;\r\ncin>>flag;\r\nif(flag) {arr[i]= f-arr[i];++b;}\r\nelse arr[i]+=f;\r\n}\r\nsort(arr,arr+p);\r\ncout<<arr[(b-1)%p]+ (b-1)/p*2*f<<endl;\r\n}\r\n}'),(71,'#include <stdio.h> \r\n  \r\nconst int perm[6][3]={{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}}; \r\nchar smap[9]={0,0,0,0,0,0,0,0,0}; \r\nint path[9]={0,1,2,3,4,5,6,7,8}; \r\n    \r\nchar old[9][10],cur[9][10]; \r\nint ix[9],rowmp[9]; \r\n  \r\nint verify(int cnt,char *map) \r\n{ \r\n  int i,j,found=0; \r\n  char nmap[9]; \r\n    \r\n  if (!cnt) \r\n    return 1; \r\n  else\r\n  { \r\n    for (i=0;i<cnt && !found;i++) \r\n      if (!(cnt%3) || ((rowmp[cnt]/3) == (path[i]/3))) // Only test legitimate row permutations \r\n      { \r\n        int brk=0; \r\n          \r\n        for (j=0;j<9;j++) nmap[j]=map[j]; \r\n        for (j=0;j<9 && !brk;j++) \r\n        { \r\n          char tec=cur[path[i]][ix[j]]; \r\n          if (tec!=\'0\')       \r\n          { \r\n            if (map[tec-\'1\']) \r\n              brk=old[cnt-1][j]!=map[tec-\'1\']; \r\n            else\r\n              nmap[tec-\'1\']=old[cnt-1][j];   \r\n          } \r\n        } \r\n        if (!brk) \r\n        { \r\n          int tmp=path[i]; \r\n          rowmp[cnt-1]=path[i];  \r\n          path[i]=path[cnt-1];  \r\n          found=verify(cnt-1,(char*)nmap); \r\n          path[i]=tmp; \r\n        } \r\n      } \r\n    return found; \r\n  } \r\n} \r\n  \r\nint main() \r\n{ \r\n  int i,j,k,l,m,r,T; \r\n    \r\n  scanf(\"%d\",&T); \r\n  while(T--) \r\n  { \r\n    int found=0; \r\n    for (i=0;i<9;i++) scanf(\"%s\",old[i]); \r\n    for (i=0;i<9;i++) scanf(\"%s\",cur[i]);   \r\n    \r\n    for (r=0;r<2 && !found;r++) \r\n    { \r\n      for (i=0;i<6 && !found;i++) \r\n        for (j=0;j<6 && !found;j++) \r\n          for (k=0;k<6 && !found;k++) \r\n            for (l=0;l<6 && !found;l++) \r\n            { \r\n              for (m=0;m<3;m++) ix[m]=perm[i][0]*3+perm[j][m]; \r\n              for (m=0;m<3;m++) ix[3+m]=perm[i][1]*3+perm[k][m]; \r\n              for (m=0;m<3;m++) ix[6+m]=perm[i][2]*3+perm[l][m]; \r\n              found=verify(9,(char*)smap);  \r\n            } \r\n      for (i=0;i<9;i++) \r\n        for (j=i;j<9;j++) \r\n        { \r\n          char tmp=old[i][j]; \r\n          old[i][j]=old[j][i]; \r\n          old[j][i]=tmp; \r\n        }        \r\n    } \r\n           \r\n    if (found) printf(\"Yes\\n\"); else printf(\"No\\n\");  \r\n  } \r\n  return 0; \r\n} '),(72,'#include <stdio.h>\n\nconst int perm[6][3]={{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};\nchar smap[9]={0,0,0,0,0,0,0,0,0};\nint path[9]={0,1,2,3,4,5,6,7,8};\n  \nchar old[9][10],cur[9][10];\nint ix[9],rowmp[9];\n\nint verify(int cnt,char *map)\n{\n  int i,j,found=0;\n  char nmap[9];\n  \n  if (!cnt)\n    return 1;\n  else\n  {\n    for (i=0;i<cnt && !found;i++)\n      if (!(cnt%3) || ((rowmp[cnt]/3) == (path[i]/3))) // Only test legitimate row permutations\n      {\n        int brk=0;\n        \n        for (j=0;j<9;j++) nmap[j]=map[j];\n        for (j=0;j<9 && !brk;j++)\n        {\n          char tec=cur[path[i]][ix[j]];\n          if (tec!=\'0\')      \n          {\n            if (map[tec-\'1\'])\n              brk=old[cnt-1][j]!=map[tec-\'1\'];\n            else\n              nmap[tec-\'1\']=old[cnt-1][j];  \n          }\n        }\n        if (!brk)\n        {\n          int tmp=path[i];\n          rowmp[cnt-1]=path[i]; \n          path[i]=path[cnt-1]; \n          found=verify(cnt-1,(char*)nmap);\n          path[i]=tmp;\n        }\n      }\n    return found;\n  }\n}\n\nint main()\n{\n  int i,j,k,l,m,r,T;\n  \n  scanf(\"%d\",&T);\n  while(T--)\n  {\n    int found=0;\n    for (i=0;i<9;i++) scanf(\"%s\",old[i]);\n    for (i=0;i<9;i++) scanf(\"%s\",cur[i]);  \n  \n    for (r=0;r<2 && !found;r++)\n    {\n      for (i=0;i<6 && !found;i++)\n        for (j=0;j<6 && !found;j++)\n          for (k=0;k<6 && !found;k++)\n            for (l=0;l<6 && !found;l++)\n            {\n              for (m=0;m<3;m++) ix[m]=perm[i][0]*3+perm[j][m];\n              for (m=0;m<3;m++) ix[3+m]=perm[i][1]*3+perm[k][m];\n              for (m=0;m<3;m++) ix[6+m]=perm[i][2]*3+perm[l][m];\n              found=verify(9,(char*)smap); \n            }\n      for (i=0;i<9;i++)\n        for (j=i;j<9;j++)\n        {\n          char tmp=old[i][j];\n          old[i][j]=old[j][i];\n          old[j][i]=tmp;\n        }       \n    }\n         \n    if (found) printf(\"Yes\\n\"); else printf(\"No\\n\"); \n  }\n  return 0;\n}\n  \n'),(73,'#include<stdio.h>\r\nmain()\r\n{\r\n	printf(\"**************************\\n\");\r\n	printf(\"         Very    Good!\\n\");\r\n	printf(\"**************************\\n\");\r\n}'),(74,'main(){printf(\"**************************\\n         Very    Good!\\n**************************\");}'),(75,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,c;\r\n	scanf(\"%d%d%d\",&a,&b,&c);\r\n	if(a>b&&a>c)\r\n		printf(\"%d\\n\",a);\r\n	else if(b>a&&b>c)\r\n		printf(\"%d\\n\",b);\r\n	else\r\n		printf(\"%d\\n\",c);\r\n	return 0;\r\n}'),(76,'main(){int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);a=a>b?a:b;printf(\"%d\",a>c?a:c);}'),(77,'#include <stdio.h>\r\nint main()\r\n{\r\n	char c1,c2,c3,c4,c5;\r\n	scanf(\"%c%c%c%c%c\",&c1,&c2,&c3,&c4,&c5);\r\n	printf(\"%c%c%c%c%c\\n\",c1+4,c2+4,c3+4,c4+4,c5+4);\r\n}'),(78,'main(){printf(\"Glmre\");}'),(79,'#include<stdio.h>]\r\n#define PI 3.14\r\n\r\nmain()\r\n{\r\n	float r,h,C1,Sa,Sb,Va,Vb;\r\n	scanf(\"%f %f\",&r,&h);\r\n	printf(\"C1=%.2f\\n\",2*PI*r);\r\n	printf(\"Sa=%.2f\\n\",PI*r*r);\r\n	printf(\"Sb=%.2f\\n\",4*PI*r*r);\r\n	printf(\"Va=%.2f\\n\",4*PI*r*r*r/3);\r\n	printf(\"Vb=%.2f\\n\",(PI*r*r)*h);\r\n	return 0;\r\n}\r\n\r\n'),(80,'#include<stdio.h>\r\nint main()\r\n{double a,b,c=3.14;\r\nscanf(\"%lf %lf\",&a,&b);\r\nprintf(\"C1=%.2f\\nSa=%.2f\\nSb=%.2f\\nVa=%.2f\\nVb=%.2f\\n\",2*c*a,a*a*c,4*c*a*a,(4*c*a*a*a)/3,c*a*a*b);}\r\n\r\n'),(81,'#include <stdio.h>\r\nint main()\r\n{\r\n	float F;\r\n	scanf(\"%f\",&F);\r\n	printf(\"c=%.2f\\n\",5*(F-32)/9);\r\n	return 0;\r\n}\r\n'),(82,'main(){float f;scanf(\"%f\",&f);printf(\"c=%.2f\",f*5.0/9-160.0/9);}'),(83,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,c,max;\r\n	scanf(\"%d %d %d\",&a,&b,&c);\r\n	if(a>b)\r\n	{\r\n		if(a>c)\r\n			max=a;\r\n		else\r\n			max=c;\r\n	}\r\n	else\r\n	{\r\n		if(b>c)\r\n			max=b;\r\n		else\r\n			max=c;\r\n	}\r\n	printf(\"%d\\n\",max);\r\n	return 0;\r\n}'),(84,'main(){int a,b,c;scanf(\"%d %d %d\",&a,&b,&c);a=a>b?a:b;printf(\"%d\",a>c?a:c);}'),(85,'#include<stdio.h>\r\nint main()\r\n{\r\n//	有一个函数\r\n//y={ x      x<1\r\n //   | 2x-1   1<=x<10\r\n   // \\ 3x-11  x>=10\r\n\r\n//写一段程序，输入x，输出y\r\n\r\n	int y,x;\r\n	//	printf(\"请输入X的值：\");\r\n	scanf(\"%d\",&x);\r\n	if(x<1)\r\n	{	\r\n		y=x;\r\n	}\r\n\r\nelse if (x>=1&&x<=1)\r\n	{\r\n		y=(2*x)-1;\r\n	} \r\n	\r\n	else\r\n	{\r\n		\r\n		y=(3*x)-11;\r\n	}\r\n	printf(\"%d\\n\",y);\r\n	\r\n}\r\n'),(86,'main(){int x;scanf(\"%d\",&x);printf(\"%d\",x<1?x:x>=10?3*x-11:2*x-1);}'),(87,'#include<stdio.h>\r\nint main()\r\n{   \r\n	int a;\r\n   scanf(\"%d\",&a);\r\n   if(a>=90)   printf(\"%c\\n\",\'A\');\r\n   if (a>=80&&a<89)  printf(\"%c\\n\",\'B\');\r\n  if(a>=70&&a<79) printf(\"%c\\n\",\'C\');\r\n   if(a>=60&&a<69) printf(\"%c\\n\",\'D\');\r\n  if (a<60)  printf(\"%c\\n\",\'E\');\r\n  \r\n  return 0;\r\n\r\n  \r\n  }\r\n'),(88,'main(){int x;scanf(\"%d\",&x);printf(\"%c\",\'A\'+(x>=90?0:x<60?4:9-x/10));}'),(89,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	char s[6];\r\n	int i; \r\n	scanf(\"%s\",s);\r\n	printf(\"%d\\n\",strlen(s));\r\n	for(i = 0 ; i <strlen(s); i++)\r\n	{\r\n		printf(\"%c\",s[i]);\r\n		if(i != strlen(s)-1)\r\n		printf(\" \");\r\n	}\r\n	printf(\"\\n\");\r\n	for(i = strlen(s) - 1  ; i >= 0; i--)\r\n		printf(\"%c\",s[i]);\r\n	\r\n	return 0;\r\n}'),(90,'#include<stdio.h>\r\nint main()\r\n{\r\nint a;\r\nscanf(\"%d\",&a);\r\nprintf(\"5\\n1 2 3 4 5\\n54321\");\r\nreturn 0;\r\n}'),(91,'#include <stdio.h>\r\nint main()\r\n{\r\n	int l,result;\r\n	scanf(\"%d\",&l);\r\n	if(l<=100000)\r\n		result=l*0.10;\r\n	else if(l>100000 && l<200000)\r\n		result=100000*0.10+(l-100000)*0.075;\r\n	else if(l>200000 && l<400000)\r\n		result=100000*0.10+100000*0.075+(l-200000)*0.05;\r\n	else if(l>400000 && l<600000)\r\n		result=100000*0.10+100000*0.075+200000*0.05+(l-400000)*0.03;\r\n	else if(l>600000 && l<1000000)\r\n		result=100000*0.10+100000*0.075+200000*0.05+200000*0.03+(l-600000)*0.015;\r\n    else\r\n		result=100000*0.10+100000*0.075+200000*0.05+200000*0.03+400000*0.015+(l-1000000)*0.01;\r\n	\r\n    printf(\"%d\\n\",result);\r\n	return 0;\r\n}\r\n'),(92,'#include<stdio.h>\r\nint main()\r\n{\r\n	printf(\"90\\n\");\r\n	return 0;\r\n}\r\n'),(93,'#include <stdio.h>\r\nint main()\r\n{\r\n	int m,n,a,b,d,x;\r\n	scanf(\"%d %d\",&a,&b);\r\n	if(m<n)\r\n	{\r\n		d=m;\r\n		m=n;\r\n		n=d;\r\n	}\r\n	m=a;\r\n	n=b;\r\n	while(m%n)\r\n	{\r\n		x=m%n;\r\n		m=n;\r\n		n=x;\r\n	}\r\n	printf(\"%d %d\\n\",x,a*b/x);\r\n}'),(94,'#include<stdio.h>\r\nint main()\r\n{ int a,b,c,d,e;\r\nscanf(\"%d%d\",&a,&b);\r\ne=a*b;\r\ndo(c=b%a,b=a,a=c);\r\nwhile(c);\r\nprintf(\"%d %d\",b,e/b);\r\n\r\n\r\n\r\n}'),(95,'#include<stdio.h>\r\nmain()\r\n{\r\n	char str[100];\r\n	int i,a,b,c,d;\r\n	a=0;\r\n	b=0;\r\n	c=0;\r\n	d=0;\r\n	gets(str);\r\n	for(i=0;str[i]!=\'\\0\';i++)\r\n	{\r\n		if(str[i]>=\'A\'&&str[i]<\'Z\'||str[i]>=\'a\'&&str[i]<=\'z\')\r\n			a++;\r\n		else if(str[i]==\' \')\r\n			b++;\r\n		else if(str[i]>=\'0\'&&str[i]<=\'9\')\r\n			c++;\r\n		else\r\n			d++;\r\n	}\r\n	printf(\"%d% d% d% d\",a,c,b,d);\r\n\r\n}'),(96,'main(){int a=0,b=0,c=0,d=0,i=0;char s[100],t;scanf(\"%[^\\n]s\",s);while(t=s[i++])((t>64&t<91)|(t>96&t<123))?a++:(t>47&t<58)?b++:(t==32)?c++:d++;printf(\"%d %d %d %d\",a,b,c,d);}'),(97,'#include <stdio.h>\r\n#include<math.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	int i,n,a=2,t=0,s=0;\r\n	scanf(\"%d\",&n);\r\n	for(i=1;i<=n;++i)\r\n	{\r\n		t=t+a;\r\n		s=s+t;\r\n		a=a*10;\r\n	}\r\n	printf(\"%d\\n\",s);\r\n	return 0;\r\n}'),(98,'main(){int n,i=0,s=0;scanf(\"%d\",&n);for(;i<n;i++){s+=2*pow(10,i)*(n-i);}printf(\"%d\",s);}'),(99,'#include\"stdio.h\"\r\n\r\nint main()\r\n{int i,n,j;\r\nlong long sum,f;\r\nwhile(scanf(\"%d\",&n)!=EOF)\r\n\r\n{	\r\nsum=0;\r\n\r\nfor(i=1;i<=n;i++)\r\n{f=1;\r\nfor(j=1;j<=i;j++)\r\n{f*=j;}\r\nsum+=f;}\r\nprintf(\"%lld\\n\",sum);}\r\nreturn 0;}'),(100,'\n#include\"stdio.h\"  \nmain()  \n{long n,i=1;long long sum=0,s=1;  \nscanf(\"%d\",&n);  \nwhile(i<=n) {s=s*i;sum=sum+s;i++;}  \nprintf(\"%lld\\n\",sum);  \n}'),(101,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,c,i;\r\n	double suma,sumb,sumc;\r\n	while(scanf(\"%d%d%d\",&a,&b,&c)!=EOF)\r\n	{\r\n		suma = sumb = sumc =0;\r\n		for(i = 1;i<=a;i++)\r\n		{\r\n			suma+=i;\r\n		}\r\n		for(i = 1;i<=b;i++)\r\n		{\r\n			sumb+=(i*i);\r\n		}\r\n		for(i = 1;i<=c;i++)\r\n		{\r\n			sumc+=(1.0/i);\r\n		}\r\n		printf(\"%.2lf\",suma+sumb+sumc);\r\n	}\r\n	return 0;\r\n}'),(102,'main(){int a,b,c,i=1;float s=0;scanf(\"%d%d%d\",&a,&b,&c);for(;i<=c;i++)s+=1.0/i;printf(\"%.2f\",a*(a+1)/2+b*(b+1)*(2*b+1)/6+s);}'),(103,'#include<stdio.h>\r\nvoid shuixianhua( )\r\n{int x,y,t;\r\n  for(x=1;x<=9;x++)\r\n  for(y=0;y<=9;y++)\r\n  for(t=0;t<=9;t++)\r\n  if(100*x+10*y+t==x*x*x+y*y*y+t*t*t)\r\n  printf(\"%d%d%d\\n\",x,y,t);\r\n\r\n}\r\nmain()\r\n{\r\n   shuixianhua();\r\n\r\n}'),(104,'#include<stdio.h>\r\nmain(){printf(\"153\\n370\\n371\\n407\\n\");}'),(105,'#include<iostream>\r\n#include<cstdio>\r\nusing namespace std;\r\n void f(int x)\r\n{\r\n	int i;\r\n	printf(\"%d its factors are \",x);\r\n	for (i=1;i<x;i++)\r\n	{\r\n		if (x%i==0)\r\n			printf(\"%d \",i);\r\n	}\r\n	printf(\"\\n\");\r\n}\r\nint main()\r\n{\r\n	int a[5]={6,28,496,8128,33550336};\r\n	int n,i,j;\r\n	cin>>n;\r\n	for (i=0;i<=n;i++)\r\n	{\r\n		for(j=0;j<5;j++)\r\n		{\r\n			if (i==a[j])\r\n			{\r\n				f(i);\r\n			}\r\n		}\r\n	}\r\n}'),(106,'#include<stdio.h>\nmain()  \n{int m,i,j,s;\nint N;\nscanf(\"%d\",&N);  \nfor(m=6;m<N;m++)  \n{s=1;  \nfor(i=2;i<m;i++)  \nif(m%i==0) s=s+i;  \nif(m-s==0)  \n{printf(\"%d its factors are 1 \",m);for(j=2;j<m;j++) if(m%j==0)  \nprintf(\"%d \",j);printf(\"\\n\");}  \n}  \n}'),(107,'#include<math.h>\r\n#include<stdio.h>\r\ndouble f(int n)\r\n{\r\n	int za=2,zb=3;\r\n	int ma=1,mb=2;\r\n	double sum=3.5;\r\n	if(n==1) return 2;\r\n	if(n==2) return sum;\r\n	while(n>2)\r\n	{\r\n		int t=za;\r\n		za=zb;                         // 分子 分母 均为 斐波那契数列\r\n		zb=t+zb;\r\n		t=ma;\r\n		ma=mb;\r\n		mb=t+mb;\r\n		sum+=zb*1.0/mb;\r\n		n--;\r\n	}\r\n	return sum;\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf(\"%d\",&n)!=EOF)\r\n	printf(\"%.2lf\\n\",f(n));\r\n\r\n}'),(108,'\n#include<stdio.h>\nmain()  \n{int i=1,n;double t,x=1,y=2,s,sum=0;  \nscanf(\"%ld\",&n);  \nwhile(i<=n) {s=y/x;sum=sum+s;t=y;y=y+x;x=t;i++;}  \nprintf(\"%.2f\\n\",sum);  \n}'),(109,'#include<math.h>\r\n#include<stdio.h>\r\nvoid f(int m,int n)\r\n{\r\n    \r\n	printf(\"%.2lf %.2lf\\n\",\r\n		m*1.0/(1<<n),m*1.5*(2-pow(2,1-n))\r\n		-m*pow(2,-n));\r\n}\r\n\r\nint main()\r\n{\r\n	int m,n;\r\n	while(scanf(\"%d%d\",&m,&n)!=-1)\r\n		f(m,n);\r\n}'),(110,'\n#include\"stdio.h\"  \n#include\"math.h\"\nmain()  \n{int i,n;\nfloat h,s;  \nscanf(\"%f%d\",&s,&n);\nh=s/2;\nfor(i=2;i<=n;i++)  \n{s+=2*h;h/=2;}  \nprintf(\"%.2f %.2f\",h,s);  \n}'),(111,'#include<stdio.h>\r\nint main()\r\n{\r\n	int n;\r\n	int z=1,i;\r\n	scanf(\"%d\",&n);\r\n	for(i=1;i<n;i++)\r\n		z=(z+1)*2;\r\n		printf(\"%d\",z);\r\n}\r\n'),(112,'#include<stdio.h> \r\nvoid main() \r\n{int n,i,a=1;scanf(\"%d\",&n);for(i=1;i<n;i++){a=(a+1)*2;}printf(\"%d\",a);}'),(113,'#include<math.h>\r\n#include<stdio.h>\r\nvoid f(int m,int n)\r\n{\r\n    \r\n	printf(\"%.2lf %.2lf\\n\",\r\n		m*1.0/(1<<n),m*1.5*(2-pow(2,1-n))\r\n		-m*pow(2,-n));\r\n}\r\n\r\nint main()\r\n{\r\n	int m;\r\n	while(scanf(\"%d\",&m)!=-1)\r\n		 printf(\"%.3lf\",sqrt(m));\r\n}'),(114,'int main()\r\n{\r\n	int x;\r\n	double y;\r\n	scanf(\"%d\", &x);\r\n	y = sqrt((double)x);\r\n	printf(\"%.3lf\", y);\r\n}'),(115,'#include\"stdio.h\"\r\nint main()\r\n{int i,j,n,f;\r\nwhile(scanf(\"%d\",&n)!=EOF)\r\n{for(i=1;i<=n;i++)\r\n{f=1;\r\n for(j=2;j<i;j++)\r\n if(i%j==0)\r\n f=0;\r\n if(f==1&&i!=1)\r\n printf(\"%d\\n\",i);}}\r\nreturn 0;}\r\n'),(116,'#include<stdio.h>\r\nint main()\r\n { int t,i,j,N;\r\nscanf(\"%d\",&N);\r\nfor(i=2;i<=N;i++)\r\n {t=1; \r\nfor(j=2;j<=(i/2);j++)\r\n if(i%j==0) t=0;\r\n if(t==1)printf(\"%d\\n\",i); }}\r\n'),(117,'#include <stdio.h>\r\n\r\nmain()\r\n{\r\n        void sort(int *p,int n);\r\n        int *q,i,a[10];\r\n        q=a;\r\n        for(i=0;i<10;i++,q++)\r\n        scanf(\"%d\",q);\r\n        q=a;\r\n        sort(q,10);\r\n        for(q=a;q<(a+10);q++)\r\n        printf(\"%d\\n\",*q);\r\n        printf(\"\\n\");\r\n        getchar();   \r\n}\r\nvoid sort(int *p,int n)\r\n{\r\nint i,j,temp,k;\r\nfor(i=0;i<n-1;i++)\r\n {\r\n   k=i;\r\n   for(j=i+1;j<n;j++)\r\n   if(*(p+j)<*(p+k))k=j;\r\n   {\r\n   temp=*(p+i);\r\n   *(p+i)=*(p+k);\r\n   *(p+k)=temp;\r\n   }\r\n      } \r\n} '),(118,'#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\nint main(){\r\n	int a[15];\r\n	for(int i=0;i<10;i++){\r\n		cin>>a[i];\r\n	}\r\n	sort(a,a+10);\r\n	for(int i=0;i<10;i++){\r\n		cout<<a[i]<<endl;\r\n	}\r\n}'),(119,'#include <stdio.h>\r\nmain() {\r\n	int a[4][4];\r\n	int a1 = 0,b1 = 0;\r\n	int i1,j1;\r\n	for(int i = 1; i <= 3;i++) {\r\n		for(int j = 1;j <= 3;j++) {\r\n			scanf(\"%d\",&a[i][j]);\r\n		}\r\n	}\r\n	for( int i0 = 1;i0 <=3;i0++) {\r\n		a1 +=a[i0][i0];\r\n	}\r\n	for( i1 = 1, j1 = 3; i1 <= 3,j1 >= 1;i1++,j1--) {\r\n		b1+=a[i1][j1];\r\n	}\r\n\r\n	printf(\"%d %d\",a1,b1);\r\n}'),(120,'#include <stdio.h>\r\nint main()\r\n{\r\n	int a[9];\r\n	for(int i=0;i<9;i++)\r\n		scanf(\"%d\",&a[i]);\r\n	printf(\"%d %d\",a[0]+a[4]+a[8],a[2]+a[4]+a[6]);\r\n}'),(121,'#include <stdio.h>\r\nint main()\r\n{\r\n	int a[10];\r\n	int i=0;\r\n	int flag=1;\r\n	for(;i<10;i++)\r\n		scanf(\"%d\",&a[i]);\r\n	for(i=0;i<9;i++)\r\n	{\r\n		if(flag && a[9]<=a[i])\r\n		{\r\n			printf(\"%d\\n%d\\n\",a[9],a[i]);\r\n			flag=0;\r\n		}\r\n		else\r\n		{\r\n			printf(\"%d\\n\",a[i]);\r\n		}\r\n	}\r\n	return 0;\r\n}'),(122,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a[10],i,j;\r\n	for(i=0;i<10;i++)\r\n	scanf(\"%d\",&a[i]);\r\n\r\n	for(i=0;i<100000;i++)\r\n	{\r\n		for(j=0;j<10;j++)\r\n		if(a[j]==i) printf(\"%d\\n\",a[j]);\r\n	}\r\n	return 0;\r\n}'),(123,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a[10];\r\n	int i,f=0;\r\n	for (i=0;i<10;i++)\r\n		cin>>a[i];\r\n	for (i--;i>=0;i--)\r\n	{\r\n		if (f)\r\n			cout<<\' \';\r\n		f=1;\r\n		cout<<a[i];\r\n	}\r\n}'),(124,'#include<stdio.h>\r\nmain()\r\n{\r\n	char a[100];\r\n	int n;\r\n    gets(a);\r\n	for(n=18;n>=0;n--)\r\n	{\r\n		printf(\"%c\",a[n]);\r\n	}\r\n\r\n}'),(125,'int main() \r\n{ \r\n    int x, y, num1, num2, temp; \r\n    scanf(\"%d %d\", &num1, &num2); \r\n  \r\n    if(num1 < num2) \r\n    { \r\n        temp = num1; \r\n        num1 = num2; \r\n        num2 = temp; \r\n    } \r\n    x = num1; \r\n    y = num2; \r\n    while(y != 0) \r\n    { \r\n        temp = x%y; \r\n        x = y; \r\n        y = temp; \r\n    } \r\n    printf(\"%d %d\\n\", x, num1*num2/x); \r\n  \r\n} \r\n'),(126,'int gcd(int a,int b){return b==0?a:gcd(b,a%b);}\r\nmain()\r\n{\r\n	int a,b;\r\n	scanf(\"%d%d\",&a,&b);\r\n	printf(\"%d %d\\n\",gcd(a,b),a/gcd(a,b)*b);\r\n}'),(127,' #include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\ndouble a,b,c,x1,x2,d;\r\nwhile(scanf(\"%lf%lf%lf\",&a,&b,&c)!=-1)\r\n{\r\nx1=((-b)+sqrt(b*b-4*a*c))/2*a;\r\nx2=((-b)-sqrt(b*b-4*a*c))/2*a;\r\nd=sqrt(-(b*b-4*a*c));\r\nif(b*b-4*a*c>0)\r\nprintf(\"x1=%.3f x2=%.3f\",x1,x2);\r\nif(b*b-4*a*c==0)\r\nprintf(\"x1=%.3f x2=%.3f\",x1,x1);\r\nif(b*b-4*a*c<0)\r\nprintf(\"x1=%.3lf+%.3lfi x2=%.3lf-%.3lfi\",(-b)/(2*a),(d/(2*a)),(-b)/(2*a),d/(2*a));}\r\nreturn 0;\r\n\r\n}'),(128,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	double a,b,c;\r\n	scanf(\"%lf%lf%lf\",&a,&b,&c);\r\n	if(b*b-4*a*c<0)\r\n		printf(\"x1=%.3lf+%.3lfi x2=%.3lf-%.3lfi\",-b/2/a,sqrt(-(b*b-4*a*c))/2/a,-b/2/a,sqrt(-(b*b-4*a*c))/2/a);\r\n	else\r\n		printf(\"x1=%.3lf x2=%.3lf\",-b/2/a+sqrt(b*b-4*a*c)/2/a,-b/2/a-sqrt(b*b-4*a*c)/2/a);\r\n	return 0;\r\n}'),(129,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	int n,m,i=1;\r\n	scanf(\"%d\",&n);\r\n    for(m=2;m<=sqrt(n);m++)\r\n	if(n%m==0)\r\n	{\r\n		i=0;\r\n		break;\r\n	}\r\n	i?printf(\"prime\\n\"):printf(\"not prime\\n\");\r\n	return 0;\r\n}\r\n'),(130,'#include<stdio.h>\r\nmain()\r\n{\r\n	int n;\r\n	scanf(\"%d\",&n);\r\n	if(n%2!=0)\r\n		printf(\"prime\");\r\n	else\r\n		printf(\"not prime\");\r\n}'),(131,'#include\"stdio.h\"\r\nint main()\r\n{int a[3],b[3],c[3];\r\nint i;\r\nfor(i=0;i<3;i++)\r\nscanf(\"%d\",&a[i]);\r\nfor(i=0;i<3;i++)\r\nscanf(\"%d\",&b[i]);\r\nfor(i=0;i<3;i++)\r\nscanf(\"%d\",&c[i]);\r\n\r\nfor(i=0;i<3;i++)\r\n{printf(\"%d \",a[i]);\r\nprintf(\"%d \",b[i]);\r\nprintf(\"%d \",c[i]);\r\nprintf(\"\\n\");}\r\n\r\n\r\n\r\n}'),(132,'#include<stdio.h>\r\nint main()\r\n{int a[4][4]={0},i,j;\r\nfor (i=0;i<3;i++)\r\nscanf(\"%d %d %d\",&a[i][0],&a[i][1],&a[i][2]);\r\nfor(i=0;i<3;i++)\r\nprintf(\"%d %d %d \\n\",a[0][i],a[1][i],a[2][i]);\r\n}'),(133,'#include <string.h> \r\n#include <stdio.h> \r\nchar* reverse(char *str) \r\n{ \r\nchar tmp; \r\nchar *head,*tail; \r\nhead=str; \r\ntail=str+strlen(str)-1; \r\nfor (;tail>head;tail--,head++) \r\n{ tmp=*head; *head=*tail; *tail=tmp; } \r\nreturn str; \r\n} \r\nvoid main() \r\n{ \r\nchar str[255]; \r\nscanf(\"%s\",str); \r\nreverse(str); \r\nprintf(\"%s\\n\",str); \r\n}'),(134,'#include <stdio.h>\r\n#include <string.h>\r\nint main()\r\n{char str[100];int n, i;scanf(\"%s\",str);n=strlen(str);for (i=n-1;i>=0;i--)\r\n	printf(\"%c\", str[i]);}'),(135,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	char i,a[100],b[100],n,m;\r\n	scanf(\"%s\",a);\r\n	scanf(\"%s\",b);\r\n	n=strlen(a);\r\n	m=strlen(b);\r\n	for(i=n;i<n+m;i++)\r\n	{\r\n		a[i]=b[i-n];\r\n	}\r\n	for(i=0;i<n+m;i++)\r\n	{\r\n		printf(\"%c\",a[i]);\r\n	}\r\n	return 0;\r\n}'),(136,'#include<stdio.h>\r\nvoid main()\r\n{int a[9]={0};int b[9]={0};	scanf(\"%s%s\",&a,&b);printf(\"%s%s\",a,b);}'),(137,'#include\"stdio.h\"\r\nint main()\r\n{int i=0,j=0,k;\r\nchar a[50],b[20];\r\nwhile(scanf(\"%c\",&a[i])!=EOF)\r\n{\r\n\r\n	if(a[i]==\'a\'||a[i]==\'e\'||a[i]==\'i\'||a[i]==\'o\'||a[i]==\'u\')\r\n\r\n	{b[j]=a[i]; j++;}\r\n\r\n	i++;  }\r\nfor(k=0;k<j;k++)\r\nprintf(\"%c\",b[k]);\r\nprintf(\"\\n\");\r\n}'),(138,'#include<stdio.h>\r\nint main()\r\n{char c1;\r\nwhile((c1=getchar())!=EOF)\r\n{if(c1==\'a\'||c1==\'e\'||c1==\'i\'||c1==\'o\'||c1==\'u\')\r\nprintf(\"%c\",c1);\r\n}}'),(139,'#include<stdio.h>\r\nint main()\r\n{char a[20];\r\nint i=0,j;\r\nwhile(scanf(\"%c\",&a[i])!=EOF)\r\n{i++;}\r\nfor(j=0;j<i;j++)\r\nprintf(\"%c \",a[j]);\r\nprintf(\"\\n\");\r\n\r\n}\r\n\r\n\r\n\r\n'),(140,'#include<stdio.h>\r\nint main()\r\n{\r\n	char a;\r\n	while(scanf(\"%c\",&a)!=EOF)\r\n			printf(\"%c \",a);\r\n}'),(141,'#include<stdio.h>\r\n#include<string.h>\r\nvoid f(char * s)\r\n{\r\n	char * p;\r\n	int a=0,b=0,c=0,d=0;\r\n	p =s;\r\n	while(*p)\r\n	{\r\n		if((*p>=\'A\'&&*p<=\'Z\')||(*p>=\'a\'&&*p<=\'z\'))\r\n			a++;\r\n		else if(*p>=48&&*p<=57)\r\n			b++;\r\n		else if(*p==\' \')\r\n			c++;\r\n		else d++;\r\n\r\n		*p++;\r\n\r\n	\r\n	}\r\n	printf(\"%d %d %d %d\",a,b,c,d);\r\n\r\n}\r\nmain()\r\n{\r\n	char s[100];\r\n	\r\n	gets(s);\r\n\r\n	f(s);\r\n	return 0;\r\n\r\n\r\n}\r\n'),(142,'#include<stdio.h>\r\nint main()\r\n{\r\n	char c;\r\n	int y=0,k=0,s=0,o=0;\r\nfor(;(c=getchar())!=EOF;)\r\n{\r\nif(c>=65&&c<=90||c>=97&&c<=122) y++;\r\nelse if(c>=48&&c<=57) s++;\r\nelse if(c==32) k++;\r\nelse o++;}\r\nprintf(\"%d %d %d %d\",y,s,k,o);\r\n}\r\n'),(143,'#include<stdio.h>\r\n#define jiaohuan(a,b) t=a,a=b,b=t;\r\nint main()\r\n{\r\n   int a,b,t;\r\n   scanf(\"%d %d\",&a,&b);\r\n   jiaohuan(a,b);\r\n   printf(\"%d %d\",a,b);\r\n\r\n}'),(144,'#include<stdio.h>\r\nvoid main()\r\n{int a,b;scanf(\"%d%d\",&a,&b);printf(\"%d %d\",b,a);}'),(145,'#include<stdio.h>\r\n#define Q(a,b) a%b  \r\n\r\nint main()  \r\n\r\n{int c,d,t;  \r\n\r\nscanf(\"%d %d\",&c,&d);  \r\n\r\nt=Q(c,d);  \r\n\r\nprintf(\"%d\\n\",t);  \r\n\r\n}  \r\n'),(146,'int main() \r\n{\r\n	int a, b;\r\n	scanf(\"%d %d\", &a, &b);\r\n 	printf(\"%d\",a % b);\r\n}'),(147,'#include <math.h>\r\n#include <stdio.h>\r\n#define S(a, b, c) ((a+b+c)/2)\r\n#define area(a, b, c) sqrt(S(a,b,c)*(S(a,b,c)-a)*(S(a,b,c)-b)*(S(a,b,c)-c))\r\nint main(){\r\ndouble a, b, c, s, r;\r\nwhile (scanf(\"%lf %lf %lf\", &a, &b, &c) == 3){\r\n   r = area(a, b, c);\r\n   printf(\"%.3lf\\n\", r);\r\n}\r\nreturn 0;\r\n}'),(148,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{double a,b,c,S,j;\r\nscanf(\"%lf%lf%lf\",&a,&b,&c);\r\nS=(a+b+c)/2;\r\nj=sqrt(S*(S-a)*(S-b)*(S-c));\r\nprintf(\"%.3lf\",j);\r\n}\r\n'),(149,'#include\"stdio.h\"\r\nint main()\r\n{int y;\r\n	while(scanf(\"%d\",&y)!=EOF)\r\n\r\n	{	if((y%4==0&&y%100!=0||y%400==0))\r\n		printf(\"L\\n\");\r\n	else printf(\"N\\n\");}\r\nreturn 0;}'),(150,'#include<stdio.h>\r\nvoid main()\r\n{int a;scanf(\"%d\",&a);if(a%4==0&&a%100!=0||a%400==0)printf(\"L\");else\r\nprintf(\"N\");}\r\n'),(151,'#include<stdio.h>\r\nint main()\r\n{\r\n  float a;\r\n  scanf(\"%f\",&a);\r\n  printf(\"%6.2f\\n\",a);\r\n  printf(\"%6.2f %6.2f\\n\",a,a);\r\n  printf(\"%6.2f %6.2f %6.2f\",a,a,a);\r\n  return 0;\r\n\r\n}\r\n'),(152,'#include <stdio.h>\r\nint main()\r\n{\r\n	float x;\r\n	scanf(\"%f\",&x);\r\n	printf(\"%6.2f\\n%6.2f %6.2f\\n%6.2f %6.2f %6.2f\",x,x,x,x,x,x);\r\n}\r\n'),(153,'#include <stdio.h>\r\n#define MAX(a, b, c) a>b ? (a>c ? a : c) : (b>c ? b : c) \r\ndouble max(double a, double b, double c){\r\ndouble r = a;\r\nif (b > r){ r = b; }\r\nif (c > r){ r = c; }\r\nreturn r;\r\n}\r\nint main(){\r\ndouble a, b, c;\r\nwhile (scanf(\"%lf %lf %lf\", &a, &b, &c) == 3){\r\n   printf(\"%.3lf\\n\", max(a, b, c));\r\n   printf(\"%.3lf\\n\", MAX(a, b, c));\r\n}\r\nreturn 0;\r\n}\r\n'),(154,'\n#define MAX(a,b,c) (a>((b>c)? b:c))? a:((b>c)? b:c)  \nmain()  \n{float x,y,z,t;  \nscanf(\"%f%f%f\",&x,&y,&z);  \nt=MAX(x,y,z);  \nprintf(\"%.3f\\n\",t);  \nprintf(\"%.3f\",t);  \n}'),(155,'#include\"stdio.h\"\r\nint main()\r\n{char a[100];\r\nint i=0;\r\ngets(a);\r\nwhile(a[i]!=\'\\0\')\r\n{if(a[i]>=\'A\'&&a[i]<\'Z\'||a[i]>=\'a\'&&a[i]<\'z\')\r\na[i]+=1;\r\nelse if(a[i]==\'z\'||a[i]==\'Z\')\r\na[i]-=25;\r\ni++;}\r\nputs(a);}'),(156,'#include <stdio.h> \r\nint main(){char a[1000];int i;gets(a);for(i=0;i<1000;i++){if(a[i]>=\'a\'&& a[i]<\'z\')a[i]++;if(a[i]==\'z\')a[i]=\'a\';}puts(a);return 0;}\r\n'),(157,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,c;\r\n	scanf(\"%d %d %d\",&a,&b,&c);\r\n	if (a<b&&a<c&&b<c) printf(\"%d %d %d \\n\",a,b,c);\r\n	  else if(a<b&&a<c&&c<b) printf(\"%d %d %d \\n\",a,c,b);\r\n	else if(b<a&&b<c&&c>a) printf(\"%d %d %d \\n\",b,a,c);\r\n	else if(b<a&&b<c&&c<a) printf(\"%d %d %d \\n\",b,c,a);\r\n	else if(c<b&&c<a&&b<a) printf(\"%d %d %d \\n\",c,b,a);\r\n	else if(c<b&&c<a&&b>a) printf(\"%d %d %d \\n\",c,a,b);\r\n		return 0;\r\n		}'),(158,'#include<stdio.h>\r\nmain()\r\n{\r\n	int a,b,c,k;\r\n	scanf(\"%d%d%d\",&a,&b,&c);\r\n	if(a>b){k=a;a=b;b=k;}\r\n	if(a>c){k=a;a=c;c=k;}\r\n	if(b>c){k=b;b=c;c=k;}\r\n	printf(\"%d %d %d \",a,b,c);\r\n}'),(159,'#include\"stdio.h\"\r\n#include\"string.h\"\r\nvoid swap(char *p1,char *p2)\r\n{char temp[100]; \r\nstrcpy(temp,p1); \r\nstrcpy(p1,p2); \r\nstrcpy(p2,temp);}\r\n\r\nint main()\r\n{char a[100],b[100],c[100];\r\ngets(a);\r\ngets(b);\r\ngets(c);\r\n\r\nif(strcmp(a,b)>0)\r\nswap(a,b);\r\nif(strcmp(a,c)>0)\r\nswap(a,c);\r\nif(strcmp(b,c)>0)\r\nswap(b,c);\r\nputs(a);\r\nputs(b);\r\nputs(c);\r\n\r\n}\r\n'),(160,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	char a[100],b[100],c[100],*pa=a,*pb=b,*pc=c,*t;\r\n	gets(a);gets(b);gets(c);\r\n	if(strcmp(a,b)>0){t=pa;pa=pb;pb=t;}\r\n	if(strcmp(a,c)>0){t=pa;pa=pc;pc=t;}\r\n	if(strcmp(b,c)>0){t=pb;pb=pc;pc=t;}\r\n	puts(pa);puts(pb);puts(pc);\r\n	return 0;\r\n}'),(161,'\n#include<stdio.h>\nint main()\n{\n	int array[11];\n	int n=10;\n	//scanf(\"%d\",&n);\n	int temp;\n	int i;\n	for(i=0;i<n;i++)\n		scanf(\"%d\",&array[i]);\n	temp=0;\n	for(i=0;i<n;i++)\n		if(array[temp] > array[i])\n			temp = i;\n		int t = array[temp];\n		array[temp] = array[0];\n		array[0] = t;\n	temp = 0;\n	for(i=0;i<n;i++)\n		if(array[temp] < array[i])\n			temp = i;\n		t = array[temp];\n		array[temp] = array[n-1];\n		array[n-1] = t;\n	for(i=0;i<n;i++)\n	{\n		\n		printf(\"%d \",array[i]);\n	}\n	printf(\"\\n\");\n	return 0;\n}'),(162,'#include \"stdio.h\"\r\nint main()\r\n{int a[10];\r\nint i,max,min,d=0,x=0;\r\nfor(i=0;i<10;i++)\r\nscanf(\"%d\",&a[i]);\r\nfor(i=0;i<10;i++)\r\n{if(a[d]<a[i])\r\nd=i;\r\nif(a[x]>a[i])\r\nx=i;  }\r\nmax=a[d]; a[d]=a[9]; a[9]=max;\r\nmin=a[x]; a[x]=a[0]; a[0]=min;\r\n\r\nfor(i=0;i<10;i++)\r\nprintf(\"%d \",a[i]);\r\nreturn 0;}'),(163,'int main()\r\n{\r\n	int n, m;\r\n	int s[500],t[500];\r\n	scanf(\"%d\", &n);\r\n	for(int i = 0; i < n; i++)\r\n	{\r\n		scanf(\"%d\", &s[i]);\r\n	}\r\n	scanf(\"%d\", &m);\r\n	for(int i = n-m,j = 0; i < n; i++, j++)\r\n	{\r\n		t[j]=s[i];		\r\n	}\r\n	for(int i = n-1; i >= m; i--)\r\n	{\r\n		s[i] = s[i - m];\r\n	}\r\n	for(int i = 0; i < m; i++)\r\n	{\r\n		s[i] = t[i];\r\n	}\r\n	for(int i = 0; i < n; i++)\r\n	{\r\n		printf(\"%d \", s[i]);\r\n	}\r\n}'),(164,'#include<stdio.h>\r\nint main()\r\n{int n,m,i,t;\r\nint a[100];\r\nscanf(\"%d\",&n);\r\nfor(i=0;i<n;i++)\r\nscanf(\"%d\",&a[i]);\r\nscanf(\"%d\",&m);\r\nt=n-m;\r\nfor(i=0;i<m;i++,t++)\r\nprintf(\"%d \",a[t]);\r\nfor(i=0;i<n-m;i++)\r\nprintf(\"%d \",a[i]);}'),(165,'#include<stdio.h>\r\nint main()\r\n{int n,s=0,i;\r\nscanf(\"%d\",&n);\r\nfor(i=2;i<=n;i++)\r\ns=(s+3)%i;\r\nprintf(\"%d\\n\",s+1);\r\n}'),(166,'#include <stdio.h>\r\nint main()\r\n{int n,i,s=0;\r\nscanf(\"%d\",&n);\r\nfor(i=2;i<=n;i++)\r\ns=(s+3)%i;\r\nprintf (\"%d\\n\",s+1);}'),(167,'#include <stdio.h>\r\nint main ()\r\n{\r\nint i,m,n;	\r\nchar a[100]={0};	\r\nscanf(\"%d\",&n);\r\n	\r\ngetchar();	\r\nfor(i=0;i<n;i++)	 \r\na[i]=getchar();	\r\n	\r\nscanf(\"%d\",&m);	\r\n	\r\nprintf(\"%s\\n\",a+m-1);\r\n\r\n}'),(168,'#include<stdio.h>\r\n\r\nvoid main()\r\n{\r\nint x,y;\r\nchar a[99999];\r\n\r\nscanf(\"%d\",&x);\r\n  scanf(\"%s\",a);\r\nscanf(\"%d\",&y);\r\nprintf(\"%s\",a+y-1);\r\n}\r\n'),(169,'#include\"stdio.h\"\r\nint main()\r\n{int y,m,d;\r\nscanf(\"%d %d %d\",&y,&m,&d);\r\nif(m==1)\r\nd+=0;\r\nelse if(m==2)\r\nd+=31;\r\nelse if(m==3)\r\nd+=59;\r\nelse if(m==4)\r\nd+=90;\r\nelse if(m==5)\r\nd+=120;\r\nelse if(m==6)\r\nd+=151;\r\nelse if(m==7)\r\nd+=181;\r\nelse if(m==8)\r\nd+=212;\r\nelse if(m==9)\r\nd+=243;\r\nelse if(m==10)\r\nd+=273;\r\nelse if(m==11)\r\nd+=304;\r\nelse if(m==12)\r\nd+=334;\r\nif((y%4==0&&y%100!=0||y%400==0)&&m>2)\r\nprintf(\"%d\\n\",++d);\r\nelse printf(\"%d\\n\",d);\r\n\r\nreturn 0;}\r\n'),(170,'#include<stdio.h>\r\nvoid main()\r\n{\r\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\r\nint y,m,d,i,sum=0;\r\nscanf(\"%d%d%d\",&y,&m,&d);\r\nif((y%4==0&&y%100!=0)||(y%400==0))\r\na[2]++;\r\nfor(i=0;i<m;i++)\r\nsum+=a[i];\r\nsum+=d;\r\nprintf(\"%d\\n\",sum);\r\n}'),(171,'#include<stdio.h>\r\nstruct STUDENT {\r\n	char id[10];\r\n	char name[20];\r\n	int g1;int g2;int g3;};\r\nvoid input(struct STUDENT a[],int x);\r\nvoid print(struct STUDENT a[],int x);\r\nint main()\r\n{\r\n	struct STUDENT s[100];\r\n	int a;\r\n	struct STUDENT *p;\r\n	p = s;\r\n	scanf(\"%d\",&a);\r\n	input(p,a);\r\n	print(p,a);\r\n	return 0;\r\n}\r\nvoid input(struct STUDENT a[],int x)\r\n{\r\n	int i;\r\n	for(i = 0;i<x;i++)\r\n	{\r\n		scanf(\"%s %s %d %d %d\",a[i].id,a[i].name,&a[i].g1,&a[i].g2,&a[i].g3);\r\n	}\r\n}\r\nvoid print(struct STUDENT a[],int x)\r\n{\r\n	int i,j=0,f=0;\r\n	for(i = 0;i<x;i++)\r\n	{\r\n		if (f)\r\n			printf(\"\\n\");\r\n		f=1;\r\n		printf(\"%s,%s,%d,%d,%d\",a[i].id,a[i].name,a[i].g1,a[i].g2,a[i].g3);\r\n		\r\n	}\r\n}'),(172,'#include<iostream>\r\n#include<list>\r\nusing namespace std;\r\nint main()\r\n{\r\nint n;cin>>n;\r\nwhile(n--)\r\n{\r\nchar p[100];\r\nint a;\r\ncin>>p;\r\ncout<<p<<\",\";\r\ncin>>p;cout<<p<<\",\";\r\ncin>>a;cout<<a<<\",\";\r\ncin>>a;cout<<a<<\",\";\r\ncin>>a;cout<<a<<\"\\n\";\r\n}\r\n}'),(173,'#include<stdio.h>\r\nstruct student input(struct student infor[100],int a);\r\nint print(struct student infor[100],int a);\r\nint print2(struct student infor[100],int a);\r\nstruct student\r\n{\r\n	char num[20];\r\n	char name[30];\r\n	int chinese;\r\n	int math;\r\n	int english;\r\n};\r\nint main()\r\n{\r\n	struct student infor[100];\r\n	int a;\r\n	scanf(\"%d\",&a);\r\n	input(infor,a);\r\n	print(infor,a);\r\n	print2(infor,a);\r\n	return 0;\r\n}\r\nstruct student input(struct student infor[100],int a)\r\n{\r\n	int i;\r\n	for(i=0;i<a;i++)\r\n	{\r\n		scanf(\"%s%s%d%d%d\",infor[i].num,infor[i].name,&infor[i].chinese,&infor[i].math,&infor[i].english);\r\n	}\r\n	return  infor[100];\r\n}\r\nint print(struct student infor[100],int a)\r\n{	\r\n	int i,mathsum=0,engsum=0,chisum=0;\r\n	for(i=0;i<a;i++)\r\n	{\r\n		mathsum=mathsum+infor[i].math;\r\n		engsum=engsum+infor[i].english;\r\n		chisum=chisum+infor[i].chinese;\r\n	}\r\n	mathsum=mathsum/a;\r\n	engsum=engsum/a;\r\n	chisum=chisum/a;\r\n	printf(\"%d %d %d\\n\",chisum,mathsum,engsum);\r\n	return 0;\r\n}\r\nint print2(struct student infor[100],int a)\r\n{\r\n	int i,n=0,m,sum[100];\r\n	for(i=0;i<a;i++)\r\n	{\r\n		sum[i]=infor[i].chinese+infor[i].english+infor[i].math;\r\n	}\r\n	for(i=0;i<a;i++)\r\n	{\r\n		if(sum[n]>sum[i])\r\n		{\r\n			m=n;\r\n		}\r\n		else\r\n		{\r\n			m=i;\r\n		}\r\n	}\r\n	printf(\"%s %s %d %d %d\\n\",infor[m].num,infor[m].name,infor[m].chinese,infor[m].math,infor[m].english);\r\n	return 0;\r\n}'),(174,'#include<stdio.h>\r\nint main()\r\n{\r\n	int i,n,q=0,w=0,r=0,t,max;\r\n	int a[100],b[100],c[100],sum[100];\r\n	char e[100][100],f[100][100];\r\n	scanf(\"%d\",&n);\r\n	for(i=1;i<=n;i++)\r\n	{\r\n		scanf(\"%s %s %d %d %d\",e[i],f[i],&a[i],&b[i],&c[i]);\r\n	}\r\n	for(i=1;i<=n;i++)\r\n	{\r\n		q+=a[i];\r\n		w+=b[i];\r\n		r+=c[i];\r\n		sum[i]=a[i]+b[i]+c[i];\r\n	}\r\n	max=sum[0];\r\n	for(i=1;i<=n;i++)\r\n	{\r\n		if(sum[i]>max)max=sum[i],t=i;\r\n	}\r\n	printf(\"%d %d %d\\n\",q/n,w/n,r/n);\r\n	printf(\"%s %s %d %d %d\\n\",e[t],f[t],a[t],b[t],c[t]);\r\n	return 0;\r\n}'),(175,'#include <stdio.h>\r\nvoid swap(int a[2], int b[2])\r\n{int tmp[2]={0}; tmp[0]=a[0]; a[0]=b[0]; b[0]=tmp[0];\r\ntmp[1]=a[1]; a[1]=b[1]; b[1]=tmp[1];}\r\nint sum=0;\r\nvoid qsort(int a[100][2],int l,int r)\r\n{\r\n	int rr=r,ll=l,temp=(r+l)/2;\r\n	while (rr>ll)\r\n	{\r\n		while (a[rr][0]>a[temp][0] && rr>=l) rr--;\r\n		while (a[ll][0]<a[temp][0] && ll<=r) ll++;\r\n		if(rr>=ll)\r\n		{\r\n			swap(a[rr], a[ll]);\r\n			rr--;\r\n			ll++;\r\n		}\r\n	}\r\n	if(rr>l) qsort(a,l,rr);\r\n	if(ll<r) qsort(a,ll,r);\r\n}\r\nint main()\r\n{\r\n    int a,b,p[100][2]={0};\r\n    scanf(\"%d %d\",&a,&b);\r\n    for(int i=0;i<a+b;i++)\r\n        scanf(\"%d %d\",&p[i][0],&p[i][1]);\r\n    qsort(p,0,a+b-1);qsort(p,0,a+b-1);qsort(p,0,a+b-1);qsort(p,0,a+b-1);\r\n    for(int i=0;i<a+b;i++)\r\n        printf(\"%d %d\\n\",p[i][0],p[i][1]);\r\n\r\n}'),(176,'#include <stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	int c[100];\r\n	int i;\r\n	scanf(\"%d%d\",&a,&b);\r\n	a+=b;\r\n	for(i=0;i<100;i++)\r\n	{\r\n		c[i]=-1;\r\n	}\r\n	for(i=0;i<a;i++)\r\n	{\r\n		scanf(\"%d\",&b);\r\n		scanf(\"%d\",&c[b]);\r\n	}\r\n	for(i=0;i<100;i++)\r\n	{\r\n		if(c[i]>=0)\r\n		{\r\n			printf(\"%d %d\\n\",i,c[i]);\r\n		}\r\n	}\r\n	return 0;\r\n}'),(177,'#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		string str;\r\n		bool fl=0;\r\n		while(n--)\r\n		{\r\n			cin>>str;\r\n			if(str==\"bowl\"||\r\n				str==\"knife\"||\r\n				str==\"fork\"||\r\n				str==\"chopsticks\")\r\n			{\r\n				if(fl)\r\n					cout<<\" \"<<str;\r\n				else {fl=1;cout<<str;}\r\n			}\r\n		}\r\n		cout<<endl;\r\n\r\n	}\r\n}'),(178,'#include <iostream> \r\nusing namespace std; \r\nint main() \r\n{ \r\nstring st[10],s; \r\nint a,i=0; \r\nwhile(cin>>a){ \r\nfor(int m=0;m<a;m++){ \r\ncin>>s; \r\nif(s==\"fork\"||s==\"knife\"||s==\"bowl\"||s==\"chopsticks\"){ \r\nst[i]=s; \r\ni++; \r\n} \r\n} \r\nfor(int m=0;m<i;m++){ \r\nif(m!=0) cout<<\" \"; \r\ncout<<st[m]; \r\n} \r\ncout<<endl; \r\ni=0; \r\n} \r\nreturn 0; \r\n} \r\n'),(179,'#include <stdio.h>\r\nint main()\r\n{\r\n int n,i,j,k;\r\n int la,lb,a,b;\r\n while(scanf(\"%d\",&n)!=EOF)\r\n {\r\n     la=1;lb=2;a=0;b=0;\r\n  for(k=0;k<n;++k)\r\n  {\r\n      scanf(\"%d%d\",&i,&j);\r\n      if(la!=lb)\r\n      {\r\n                if(i==la)\r\n                {\r\n                    la=j;\r\n                    a++;\r\n                }\r\n                if(i==lb)\r\n                {\r\n                    lb=j;\r\n                    b++;\r\n                }\r\n      }\r\n  }\r\n  if(a<b)\r\n            printf(\"You are my younger\\n\");\r\n        else if(a==b)\r\n            printf(\"You are my brother\\n\");\r\n        else if(a>b)\r\n            printf(\"You are my elder\\n\");\r\n }\r\n return 0;\r\n}'),(180,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n\r\n	while(cin>>n)\r\n	{\r\n			int a=1,b=2;\r\n	      int c,d;\r\n	     int p=0,q=0;\r\n	while(n--)\r\n	{\r\n		cin>>c>>d;\r\n		if(c==a)\r\n		{\r\n			a=d;\r\n			p++;\r\n		}\r\n		if(c==b)\r\n		{\r\n			b=d;\r\n			q++;\r\n		}\r\n	}\r\n\r\n	if(p<q)\r\n		cout<<\"You are my younger\"<<endl;\r\n	if(p>q)\r\n		cout<<\"You are my elder\"<<endl;\r\n	if(p==q)\r\n		cout<<\"You are my brother\"<<endl;\r\n	}\r\n}\r\n'),(181,'#include <stdio.h>\r\n#include <string.h>\r\nvoid output(int num,int i)\r\n{\r\n	switch(num)\r\n	{\r\n	case 0:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"| |\");\r\n				break;\r\n			}\r\n			printf(\"|_|\");\r\n			break;\r\n		}\r\n	case 1:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\"   \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"  |\");\r\n				break;\r\n			}\r\n			printf(\"  |\");\r\n			break;\r\n		}\r\n	case 2:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			else if(i==1)\r\n			{\r\n				printf(\" _|\");\r\n				break;\r\n			}\r\n			printf(\"|_ \");\r\n			break;\r\n		}\r\n	case 3:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\" _|\");\r\n				break;\r\n			}\r\n			printf(\" _|\");\r\n			break;\r\n		}\r\n	case 4:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\"   \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"|_|\");\r\n				break;\r\n			}\r\n			printf(\"  |\");\r\n			break;\r\n		}\r\n	case 5:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"|_ \");\r\n				break;\r\n			}\r\n			printf(\" _|\");\r\n			break;\r\n		}\r\n	case 6:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"|_ \");\r\n				break;\r\n			}\r\n			printf(\"|_|\");\r\n			break;\r\n		}\r\n	case 7:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"  |\");\r\n				break;\r\n			}\r\n			printf(\"  |\");\r\n			break;\r\n		}\r\n	case 8:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"|_|\");\r\n				break;\r\n			}\r\n			printf(\"|_|\");\r\n			break;\r\n		}\r\n	case 9:\r\n		{\r\n			if(i==0)\r\n			{\r\n				printf(\" _ \");\r\n				break;\r\n			}\r\n			if(i==1)\r\n			{\r\n				printf(\"|_|\");\r\n				break;\r\n			}\r\n			printf(\" _|\");\r\n			break;\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n	int a,b,c,d,i;\r\n	while(~scanf(\"%d%d%d%d\",&a,&b,&c,&d))\r\n	{\r\n		for(i=0;i<3;i++)\r\n		{\r\n			output(a,i);\r\n			output(b,i);\r\n			output(c,i);\r\n			output(d,i);\r\n			printf(\"\\n\");\r\n		}\r\n	}\r\n	return 0;\r\n}'),(182,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	int s[4];\r\n	int i,j,k;\r\n	char clock[3][31] = \r\n	{\" _     _  _     _  _  _  _  _ \",\r\n	 \"| |  | _| _||_||_ |_   ||_||_|\",\r\n	 \"|_|  ||_  _|  | _||_|  ||_| _|\"\r\n	};\r\n	while(scanf(\"%d%d%d%d\",s,s+1,s+2,s+3)!=EOF)\r\n	{\r\n		for(i = 0;i < 3; i++)\r\n		{\r\n			for(j = 0; j<4; j++)\r\n				for(k = s[j]*3; k<(s[j]+1)*3 ;k++)\r\n					printf(\"%c\",clock[i][k]);\r\n			printf(\"\\n\");\r\n		}\r\n	}\r\n 	return 0;\r\n}'),(183,'#include <iostream> \r\n#include <string> \r\n#include <vector> \r\n\r\nusing namespace std ; \r\n\r\nbool contains(vector<string> vec , string word) { \r\nint i = 0 ; \r\nfor (i = 0 ; i < vec.size() ; ++ i) { \r\nif (vec[i] == word) { \r\nreturn true ; \r\n} \r\n} \r\nreturn false ; \r\n} \r\n\r\nint main() { \r\nint i = 0 ; \r\nint a , b , c ; \r\nstring word ; \r\nvector<string> total ; \r\nvector<string> spy , dual_spy , spy_caught ; \r\nwhile (cin >> a >> b >> c) { \r\nfor (i = 0 ; i < a ; ++ i) { \r\ncin >> word ; \r\ntotal.push_back(word) ;  \r\n} \r\nfor (i = 0 ; i < b ; ++ i) { \r\ncin >> word ; \r\nspy.push_back(word) ; \r\n} \r\nfor (i = 0 ; i < c ; ++ i) { \r\ncin >> word ; \r\ndual_spy.push_back(word) ; \r\n} \r\nfor (i = 0 ; i < spy.size() ; ++ i) { \r\nword = spy[i] ; \r\nif (contains(total , word) && !contains(dual_spy , word)) { \r\nspy_caught.push_back(word) ; \r\n} \r\n} \r\nif (spy_caught.empty()) { \r\ncout << \"No enemy spy\" << endl ; \r\n} \r\nelse { \r\nfor (i = 0 ; i < spy_caught.size()-1 ; ++ i) { \r\ncout << spy_caught[i] << \" \" ; \r\n} \r\ncout << spy_caught[i] << endl ; \r\n} \r\ntotal.clear() ; \r\nspy.clear() ; \r\ndual_spy.clear() ; \r\nspy_caught.clear() ; \r\n} \r\n\r\nreturn 0 ; \r\n} '),(184,'//1004\n#include <iostream>\n#include <string>\n#include <map>\n#include <cmath>\n#include <stdio.h> \n#define N 1010\n \nusing namespace std;\n \nint a, b, c;\nint n;\nstring arr_b[N];\n \nint main()\n{\n while (scanf(\"%d %d %d\", &a, &b, &c)==3)\n {\n  map<string, int> hasha;\n  for (int i = 0; i < a; i++)\n  {\n   string sa;\n   cin >> sa;\n   hasha[sa] = 1;\n  }\n \n  for (int i = 0; i < b; i++)\n   cin >> arr_b[i];\n \n  map<string, int> hashc;\n  for (int i = 0; i < c; i++)\n  {\n   string sc;\n   cin >> sc;\n   hashc[sc] = 1;\n  }\n \n  int first = 1;\n  for (int i = 0; i < b; i++)\n  {\n   if (hasha[arr_b[i]]==1 && hashc[arr_b[i]]==0)\n   {\n    if (!first)\n     cout << \' \';\n    else\n     first = 0;\n    cout << arr_b[i];\n   }\n  }\n \n  if (!first)\n   cout << endl;\n  else\n   cout << \"No enemy spy\" << endl;\n }\n \n return 0;\n}\n \n'),(185,'#include<cstring>\n\n#include<cstdio>\n\n#define __FILE_GENERATOR__\n\nstruct Edge\n\n{\n\n	int m,w,l;\n\n	Edge *next;\n\n};\n\nint const INF=0x3fffffff;\n\nint const N=100,M=9,Q=10000;\n\nint const S=2000000;\n\nint p3[M+1];\n\nEdge edges[Q];\n\nEdge *adj[N];\n\nint e[M],f[M];\n\nint ii[S],jj[S];\n\nint d[S];\n\nbool b[S];\n\nint n,m,q;\n\nint cnt,num;\n\ninline void initialize()\n\n{\n\n	int k;\n\n	p3[0]=1;\n\n	for(k=1;k<=M;++k)\n\n		p3[k]=p3[k-1]*3;\n\n}\n\ninline Edge* makeEdge(int m,int w,int l,Edge *next)\n\n{\n\n	edges[cnt].m=m;\n\n	edges[cnt].w=w;\n\n	edges[cnt].l=l;\n\n	edges[cnt].next=next;\n\n	return &edges[cnt];\n\n}\n\nbool readin()\n\n{\n\n	int x,y,z,d,k;\n\n	if(scanf(\"%d%d%d\",&n,&m,&q)==EOF)\n\n		return false;\n\n	for(k=0;k<m;++k)\n\n		scanf(\"%d\",&e[k]);\n\n	for(k=0;k<m;++k)\n\n		scanf(\"%d\",&f[k]);\n\n	for(k=0;k<n;++k)\n\n		adj[k]=NULL;\n\n	for(cnt=0;cnt<q;++cnt)\n\n	{\n\n		scanf(\"%d%d%d%d\",&x,&y,&z,&d);\n\n		adj[x]=makeEdge(z,y,d,adj[x]);\n\n	}\n\n	return true;\n\n}\n\ninline int D(int index)\n\n{\n\n	return d[index];\n\n}\n\nvoid remove()\n\n{\n\n	int x,y,z,r=1,pr,left,right;\n\n	z=ii[num];\n\n	ii[1]=z;\n\n	jj[z]=1;\n\n	--num;\n\n	while((r<<1)<=num)\n\n	{\n\n		left=r<<1;\n\n		right=(r<<1)+1;\n\n		if(right<=num)\n\n			pr=D(ii[left])<D(ii[right])?left:right;\n\n		else\n\n			pr=left;\n\n		if(D(ii[r])<=D(ii[pr]))\n\n			break;\n\n		x=ii[r];\n\n		y=ii[pr];\n\n		ii[r]=y;\n\n		jj[y]=r;\n\n		ii[pr]=x;\n\n		jj[x]=pr;\n\n		r=pr;\n\n	}\n\n}\n\nvoid adjust(int pr)\n\n{\n\n	int x,y,r;\n\n	while((pr>>1)>=1)\n\n	{\n\n		r=pr>>1;\n\n		if(D(ii[r])<=D(ii[pr]))\n\n			break;\n\n		x=ii[r];\n\n		y=ii[pr];\n\n		ii[r]=y;\n\n		jj[y]=r;\n\n		ii[pr]=x;\n\n		jj[x]=pr;\n\n		pr=r;\n\n	}\n\n}\n\nvoid solve()\n\n{\n\n	int status,pstatus,nstatus,v,w,mid,t,l,k;\n\n	Edge *pE;\n\n	cnt=p3[m]*n;\n\n	for(k=0;k<cnt;++k)\n\n	{\n\n		d[k]=INF;\n\n		ii[k+1]=k;\n\n		jj[k]=k+1;\n\n	}\n\n	memset(b,false,sizeof(b));\n\n	num=cnt;\n\n	d[0]=0;\n\n	while(true)\n\n	{\n\n		if(num==0)\n\n		{\n\n			printf(\"-1\\n\");\n\n			return;\n\n		}\n\n		pstatus=ii[1];\n\n		if(d[pstatus]==INF)\n\n		{\n\n			printf(\"-1\\n\");\n\n			return;\n\n		}\n\n		b[pstatus]=true;\n\n		v=pstatus/p3[m];\n\n		status=pstatus%p3[m];\n\n		if(v==n-1)\n\n		{\n\n			printf(\"%d\\n\",d[pstatus]);\n\n			return;\n\n		}\n\n		pE=adj[v];\n\n		remove();\n\n		while(pE!=NULL)\n\n		{\n\n			mid=pE->m;\n\n			t=(status%p3[mid+1])/p3[mid];\n\n			w=pE->w;\n\n			l=pE->l;\n\n			if(t==0)\n\n			{\n\n				nstatus=status+p3[mid];\n\n			}\n\n			else if(t==1)\n\n			{\n\n				l+=e[mid];\n\n				nstatus=status+p3[mid];\n\n			}\n\n			else if(t==2)\n\n			{\n\n				l+=f[mid];\n\n				nstatus=status;\n\n			}\n\n			nstatus+=w*p3[m];\n\n			if(!b[nstatus]&&d[pstatus]+l<d[nstatus])\n\n			{\n\n				d[nstatus]=d[pstatus]+l;\n\n				adjust(jj[nstatus]);\n\n			}\n\n			pE=pE->next;\n\n		}\n\n	}\n\n}\n\nint main()\n\n{\n\n\n	initialize();\n\n	while(readin())\n\n		solve();\n\n	return 0;\n\n}\n\n'),(186,'#include<cstring>\n\n#include<cstdio>\n\n#define __FILE_GENERATOR__\n\nstruct Edge\n\n{\n\n	int m,w,l;\n\n	Edge *next;\n\n};\n\nint const INF=0x3fffffff;\n\nint const N=100,M=9,Q=10000;\n\nint const S=2000000;\n\nint p3[M+1];\n\nEdge edges[Q];\n\nEdge *adj[N];\n\nint e[M],f[M];\n\nint ii[S],jj[S];\n\nint d[S];\n\nbool b[S];\n\nint n,m,q;\n\nint cnt,num;\n\ninline void initialize()\n\n{\n\n	int k;\n\n	p3[0]=1;\n\n	for(k=1;k<=M;++k)\n\n		p3[k]=p3[k-1]*3;\n\n}\n\ninline Edge* makeEdge(int m,int w,int l,Edge *next)\n\n{\n\n	edges[cnt].m=m;\n\n	edges[cnt].w=w;\n\n	edges[cnt].l=l;\n\n	edges[cnt].next=next;\n\n	return &edges[cnt];\n\n}\n\nbool readin()\n\n{\n\n	int x,y,z,d,k;\n\n	if(scanf(\"%d%d%d\",&n,&m,&q)==EOF)\n\n		return false;\n\n	for(k=0;k<m;++k)\n\n		scanf(\"%d\",&e[k]);\n\n	for(k=0;k<m;++k)\n\n		scanf(\"%d\",&f[k]);\n\n	for(k=0;k<n;++k)\n\n		adj[k]=NULL;\n\n	for(cnt=0;cnt<q;++cnt)\n\n	{\n\n		scanf(\"%d%d%d%d\",&x,&y,&z,&d);\n\n		adj[x]=makeEdge(z,y,d,adj[x]);\n\n	}\n\n	return true;\n\n}\n\ninline int D(int index)\n\n{\n\n	return d[index];\n\n}\n\nvoid remove()\n\n{\n\n	int x,y,z,r=1,pr,left,right;\n\n	z=ii[num];\n\n	ii[1]=z;\n\n	jj[z]=1;\n\n	--num;\n\n	while((r<<1)<=num)\n\n	{\n\n		left=r<<1;\n\n		right=(r<<1)+1;\n\n		if(right<=num)\n\n			pr=D(ii[left])<D(ii[right])?left:right;\n\n		else\n\n			pr=left;\n\n		if(D(ii[r])<=D(ii[pr]))\n\n			break;\n\n		x=ii[r];\n\n		y=ii[pr];\n\n		ii[r]=y;\n\n		jj[y]=r;\n\n		ii[pr]=x;\n\n		jj[x]=pr;\n\n		r=pr;\n\n	}\n\n}\n\nvoid adjust(int pr)\n\n{\n\n	int x,y,r;\n\n	while((pr>>1)>=1)\n\n	{\n\n		r=pr>>1;\n\n		if(D(ii[r])<=D(ii[pr]))\n\n			break;\n\n		x=ii[r];\n\n		y=ii[pr];\n\n		ii[r]=y;\n\n		jj[y]=r;\n\n		ii[pr]=x;\n\n		jj[x]=pr;\n\n		pr=r;\n\n	}\n\n}\n\nvoid solve()\n\n{\n\n	int status,pstatus,nstatus,v,w,mid,t,l,k;\n\n	Edge *pE;\n\n	cnt=p3[m]*n;\n\n	for(k=0;k<cnt;++k)\n\n	{\n\n		d[k]=INF;\n\n		ii[k+1]=k;\n\n		jj[k]=k+1;\n\n	}\n\n	memset(b,false,sizeof(b));\n\n	num=cnt;\n\n	d[0]=0;\n\n	while(true)\n\n	{\n\n		if(num==0)\n\n		{\n\n			printf(\"-1\\n\");\n\n			return;\n\n		}\n\n		pstatus=ii[1];\n\n		if(d[pstatus]==INF)\n\n		{\n\n			printf(\"-1\\n\");\n\n			return;\n\n		}\n\n		b[pstatus]=true;\n\n		v=pstatus/p3[m];\n\n		status=pstatus%p3[m];\n\n		if(v==n-1)\n\n		{\n\n			printf(\"%d\\n\",d[pstatus]);\n\n			return;\n\n		}\n\n		pE=adj[v];\n\n		remove();\n\n		while(pE!=NULL)\n\n		{\n\n			mid=pE->m;\n\n			t=(status%p3[mid+1])/p3[mid];\n\n			w=pE->w;\n\n			l=pE->l;\n\n			if(t==0)\n\n			{\n\n				nstatus=status+p3[mid];\n\n			}\n\n			else if(t==1)\n\n			{\n\n				l+=e[mid];\n\n				nstatus=status+p3[mid];\n\n			}\n\n			else if(t==2)\n\n			{\n\n				l+=f[mid];\n\n				nstatus=status;\n\n			}\n\n			nstatus+=w*p3[m];\n\n			if(!b[nstatus]&&d[pstatus]+l<d[nstatus])\n\n			{\n\n				d[nstatus]=d[pstatus]+l;\n\n				adjust(jj[nstatus]);\n\n			}\n\n			pE=pE->next;\n\n		}\n\n	}\n\n}\n\nint main()\n\n{\n\n\n	initialize();\n\n	while(readin())\n\n		solve();\n\n	return 0;\n\n}\n\n'),(187,'#include <cstdio>  \r\n#include <cmath>  \r\n#include <cstdlib>  \r\n#include <ctime>  \r\n  \r\n#include <iostream>  \r\n#include <cmath>  \r\n#include <algorithm>  \r\n#include <numeric>  \r\n#include <utility>  \r\n  \r\n#include <cstring>  \r\n#include <vector>  \r\n#include <stack>  \r\n#include <queue>  \r\n#include <map>  \r\n#include <string>  \r\nusing namespace std;  \r\n  \r\n#define inf 0x3f3f3f3f  \r\n#define MAXN 1010  \r\n#define MAXX 10010  \r\n#define clr(x,k) memset((x),(k),sizeof(x))  \r\n#define clrn(x,k) memset((x),(k),(n+1)*sizeof(int))  \r\n#define cpy(x,k) memcpy((x),(k),sizeof(x))  \r\n#define Base 10000  \r\n  \r\ntypedef vector<int> vi;  \r\n  \r\n#define foreach(it,c) for(vi::iterator it = (c).begin();it != (c).end();++it)  \r\n  \r\n#define max(a,b) ((a)>(b)?(a):(b))  \r\n#define min(a,b) ((a)<(b)?(a):(b))  \r\n  \r\nstruct node{  \r\n    int end;  \r\n    int w;  \r\n    struct node * son[26];  \r\n};  \r\nint n,nx;  \r\nint fp[MAXX]; \r\nstruct node* root,bufChild[33*MAXN];  \r\nint bufCnt,len;  \r\nchar s[MAXX],str[33];  \r\nvoid reverse(char *s){  \r\n    int i=0,j=strlen(s)-1,temp;  \r\n    while(i<j){  \r\n        temp=s[i];  \r\n        s[i]=s[j];  \r\n        s[j]=temp;  \r\n        i++,j--;  \r\n    }  \r\n}  \r\nnode* newNode(){  \r\n    int i;  \r\n    node* cur = &bufChild[bufCnt++];  \r\n    cur->end=0;  \r\n    cur->w=0;  \r\n    for(i=0;i<26;i++)  \r\n        cur->son[i]=NULL;  \r\n    return cur;  \r\n}  \r\nvoid insert(const char *str,int weight){  \r\n    int len=strlen(str),i,j,x;  \r\n    node* temp = root;  \r\n    for(i = 0;i < len;i++){  \r\n        x = str[i]-\'a\';  \r\n        if(temp->son[x]==NULL){  \r\n            temp->son[x]=newNode();  \r\n        }  \r\n        temp=temp->son[x];  \r\n    }  \r\n    temp->end=1;  \r\n    temp->w=weight;  \r\n}  \r\nvoid Query(int Q){  \r\n    int j=Q;  \r\n    int x ;  \r\n    node *cur = root;  \r\n    while(s[j]){  \r\n        x = s[j]-\'a\';  \r\n        if(cur->son[x]!=NULL){  \r\n            if(cur->son[x]->end){  \r\n                if(fp[j-1]!=-1)  \r\n                    fp[Q]=max(fp[Q],fp[j-1]+cur->son[x]->w);  \r\n            }  \r\n            cur = cur->son[x];  \r\n        }else{  \r\n            break;  \r\n        }  \r\n        j--;  \r\n    }  \r\n}  \r\nint main()\r\n{   \r\n    int i,w;  \r\n    s[0]=0;  \r\n    while(scanf(\"%d %s\",&n,s+1)!=EOF){  \r\n        len = strlen(s+1);  \r\n        bufCnt=0;  \r\n        root=newNode();  \r\n        for(i = 0;i < n;i++){  \r\n            scanf(\"%s %d\",str,&w);  \r\n            reverse(str);\r\n            insert(str,w);  \r\n        }  \r\n        fp[0]=0;  \r\n        for(i = 1;i <= len;i++){  \r\n            fp[i]=-1;  \r\n            Query(i);  \r\n        }  \r\n        printf(\"%d\\n\",fp[len]);  \r\n    }  \r\n    return 0;  \r\n}  '),(188,'#include<iostream>\r\n #include<cstring>\r\nusing namespace std;\r\nstruct node\r\n{\r\n	int w;\r\n	bool end;\r\n	node* next[26];\r\n	node():w(0),end(0)\r\n	{\r\n		memset(next,0,sizeof(next));\r\n	}\r\n};\r\nint i,j;\r\n\r\nint pool_top;\r\nchar s[10010],t[10010];\r\nint n,len,w;\r\nint maxs[10010]; \r\nnode pool[350000];\r\nint f()\r\n{  \r\n    if(!(cin>>n)) return 0;\r\n    cin>>s;\r\n    len=strlen(s);\r\n	pool_top=0;\r\n    node root;\r\n    for(i=0;i<n;i++)\r\n    {\r\n        cin>>t ;\r\n        cin>>w ;\r\n        int lens=strlen(t);\r\n		node* cur=&root;int next;\r\n		for(j=0;j<lens-1;j++)\r\n		{\r\n            next=t[j]-\'a\';\r\n			if(cur->next[next]==0)\r\n			{  pool[pool_top].end=0;\r\n			memset(pool[pool_top].next,0,sizeof(pool[pool_top].next));\r\n			   cur->next[next]=&pool[pool_top++];}\r\n			cur=cur->next[next];			 \r\n		} \r\n		next=t[j]-\'a\';\r\n		if(cur->next[next]==0)\r\n		{pool[pool_top].end=0; 	memset(pool[pool_top].next,0,sizeof(pool[pool_top].next));cur->next[next]=&pool[pool_top++];}\r\n		cur=cur->next[next];\r\n		cur->end=1;cur->w=w; \r\n    }\r\n    memset(maxs,-1,sizeof(maxs));\r\n    maxs[0]=0;\r\n    for(i=0;i<len;i++)\r\n    {\r\n        if( maxs[i]==-1) continue;\r\n        j=0;\r\n		int next=s[i]-\'a\';\r\n		node* cur= root.next[next];\r\n		while(cur)\r\n		{   j++;\r\n			if(cur->end)\r\n					if(cur->w+maxs[i]>maxs[i+j])\r\n						maxs[i+j]=cur->w+maxs[i];\r\n			if(i+j>=len)break;\r\n			next=s[i+j]-\'a\';\r\n			cur=cur->next[next]; \r\n		}\r\n    }\r\n    cout<<maxs[len]<<endl;\r\n    return 1;\r\n}\r\nint main()\r\n{  \r\n    while( f());\r\n  \r\n}\r\n'),(189,'#include<stdio.h>\r\nint fn[30][2]={\r\n220,284,\r\n1184,1210,\r\n2620,2924,\r\n5020,5564,\r\n6232,6368,\r\n10744,10856,\r\n12285,14595,\r\n17296,18416,\r\n63020,76084,\r\n66928,66992,\r\n67095,71145,\r\n69615,87633,\r\n79750,88730,\r\n100485,124155,\r\n122265,139815,\r\n122368,123152,\r\n141664,153176,\r\n142310,168730,\r\n171856,176336,\r\n176272,180848,\r\n185368,203432,\r\n196724,202444,\r\n280540,365084,\r\n308620,389924,\r\n319550,430402,\r\n356408,399592,\r\n437456,455344,\r\n469028,486178\r\n};\r\nint main()\r\n{\r\nint a, b, i, count;\r\n\r\nwhile(scanf(\"%d%d\", &a, &b) != EOF)\r\n{\r\nfor(count=0, i=0; i<28; i++)\r\n   if(a<=fn[i][0]&&fn[i][1]<=b)\r\n      count++;\r\n      printf(\"%d\\n\",count);\r\n} \r\nreturn 0;\r\n} '),(190,'#include<stdio.h>\r\nint fn[30][2]=\r\n{220,284,\r\n1184,1210,\r\n2620,2924,\r\n5020,5564,\r\n6232,6368,\r\n10744,10856,\r\n12285,14595,\r\n17296,18416,\r\n63020,76084,\r\n66928,66992,\r\n67095,71145,\r\n69615,87633,\r\n79750,88730,\r\n100485,124155,\r\n122265,139815,\r\n122368,123152,\r\n141664,153176,\r\n142310,168730,\r\n171856,176336,\r\n176272,180848,\r\n185368,203432,\r\n196724,202444,\r\n280540,365084,\r\n308620,389924,\r\n319550,430402,\r\n356408,399592,\r\n437456,455344,\r\n469028,486178};\r\nint main()\r\n{int a, b, i, count;\r\nwhile(scanf(\"%d %d\", &a,&b)!= EOF)\r\n{for(count=0,i=0;i<28;i++)\r\nif(a<=fn[i][0]&&fn[i][1]<=b)\r\ncount++;\r\nprintf(\"%d\\n\",count);} \r\nreturn 0;} '),(191,'#include <iostream>\r\n#include <cmath>\r\n#include <cstdio>\r\nusing namespace std;\r\nint can[1005]={0};\r\nint a[10005][605]={0};\r\nint x[6005],y[6005],t[6005];\r\nint h1,h2;\r\nint bb,ee,xx,yx,c,n;\r\nvoid gui(int ji,int many,int ma,int kk);\r\nint main()\r\n{\r\n\r\n      for (int i=1;i<=31;i++)\r\n                can[i*i]=true;\r\n      for (int i=1;i<=1000;i++)\r\n            if (!can[i])\r\n         {\r\n              a[i][600]=1;\r\n              bb=1;\r\n              ee=(int)sqrt(i);\r\n              a[i][0]=ee;\r\n              ee=-ee;\r\n              xx=bb;\r\n              yx=ee;\r\n              xx=-yx;\r\n              yx=i-yx*yx;\r\n              n=0;\r\n            while ((xx-yx)*(xx-yx)<i||xx>=0)\r\n        {\r\n                xx-=yx;\r\n                n++;\r\n        }\r\n           a[i][1]=n;\r\n          c=xx;\r\n          xx=yx;\r\n          yx=c;\r\nwhile (xx!=bb||yx!=ee)\r\n{\r\na[i][600]++;\r\nc=xx;\r\nxx=-yx;\r\nyx=i-yx*yx;\r\nyx=yx/c;\r\nn=0;\r\nwhile ((xx-yx)*(xx-yx)<i||xx>=0)\r\n{\r\nxx-=yx;\r\nn++;\r\n}\r\na[i][a[i][600]]=n;\r\nc=xx;\r\nxx=yx;\r\nyx=c;\r\n}\r\n}\r\nint i;\r\nwhile (scanf(\"%d\",&i)!=EOF)\r\nif (!can[i])\r\n{\r\nif (a[i][600]%2)\r\ngui(1,a[i][0],i,a[i][600]*2);\r\nelse\r\ngui(1,a[i][0],i,a[i][600]);\r\nfor (int j=x[0];j>=1;j--)\r\nprintf(\"%d\",x[j]);\r\nprintf(\"\\n\");\r\n}\r\nelse\r\nprintf(\"no solution\\n\");\r\n\r\nreturn 0;\r\n}\r\nvoid gui(int ji,int many,int ma,int kk)\r\n{\r\nif (ji<kk)\r\ngui(ji+1,a[ma][(ji-1)%a[ma][600]+1],ma,kk);\r\nelse\r\n{\r\nh1=1;\r\nh2=1;\r\nx[1]=many;\r\ny[1]=1;\r\nreturn;\r\n}\r\nfor (int i=1;i<=h1;i++)\r\nt[i]=x[i];\r\nfor (int i=1;i<=h2;i++)\r\nx[i]=y[i];\r\nfor (int i=1;i<=h1;i++)\r\ny[i]=t[i];\r\nc=h1;\r\nh1=h2;\r\nh2=c;\r\nfor (int i=1;i<=h2;i++)\r\nif (i<=h1)\r\nx[i]+=many*y[i];\r\nelse\r\nx[i]=many*y[i];\r\nif (h2>h1)\r\nh1=h2;\r\nfor (int i=1;i<h1;i++)\r\nif (x[i]>=10)\r\n{\r\nx[i+1]+=x[i]/10;\r\nx[i]%=10;\r\n}\r\nwhile (x[h1]>=10)\r\n{\r\nx[h1+1]=x[h1]/10;\r\nx[h1]%=10;\r\nh1++;\r\n}\r\nx[0]=h1;\r\n}'),(192,'#include <iostream>\r\n#include <cmath>\r\nusing namespace std;\r\nint can[1005]={0};\r\nint a[10005][605]={0};\r\nint x[6005],y[6005],t[6005];\r\nint h1,h2;\r\nint bb,ee,xx,yx,c,n;\r\nvoid gui(int ji,int many,int ma,int kk);\r\nint main()\r\n{\r\nfor (int i=1;i<=31;i++)\r\ncan[i*i]=true;\r\nfor (int i=1;i<=1000;i++)\r\nif (!can[i])\r\n{\r\na[i][600]=1;\r\nbb=1;\r\nee=(int)sqrt(i);\r\na[i][0]=ee;\r\nee=-ee;\r\nxx=bb;\r\nyx=ee;\r\nxx=-yx;\r\nyx=i-yx*yx;\r\nn=0;\r\nwhile ((xx-yx)*(xx-yx)<i||xx>=0)\r\n{\r\nxx-=yx;\r\nn++;\r\n}\r\na[i][1]=n;\r\nc=xx;\r\nxx=yx;\r\nyx=c;\r\nwhile (xx!=bb||yx!=ee)\r\n{\r\na[i][600]++;\r\nc=xx;\r\nxx=-yx;\r\nyx=i-yx*yx;\r\nyx=yx/c;\r\nn=0;\r\nwhile ((xx-yx)*(xx-yx)<i||xx>=0)\r\n{\r\nxx-=yx;\r\nn++;\r\n}\r\na[i][a[i][600]]=n;\r\nc=xx;\r\nxx=yx;\r\nyx=c;\r\n}\r\n}\r\nint i;\r\nwhile (scanf(\"%d\",&i)!=EOF)\r\nif (!can[i])\r\n{\r\nif (a[i][600]%2)\r\ngui(1,a[i][0],i,a[i][600]*2);\r\nelse\r\ngui(1,a[i][0],i,a[i][600]);\r\nfor (int j=x[0];j>=1;j--)\r\nprintf(\"%d\",x[j]);\r\nprintf(\"\\n\");\r\n}\r\nelse\r\nprintf(\"no solution\\n\");\r\nreturn 0;\r\n}\r\nvoid gui(int ji,int many,int ma,int kk)\r\n{\r\nif (ji<kk)\r\ngui(ji+1,a[ma][(ji-1)%a[ma][600]+1],ma,kk);\r\nelse\r\n{\r\nh1=1;\r\nh2=1;\r\nx[1]=many;\r\ny[1]=1;\r\nreturn;\r\n}\r\nfor (int i=1;i<=h1;i++)\r\nt[i]=x[i];\r\nfor (int i=1;i<=h2;i++)\r\nx[i]=y[i];\r\nfor (int i=1;i<=h1;i++)\r\ny[i]=t[i];\r\nc=h1;\r\nh1=h2;\r\nh2=c;\r\nfor (int i=1;i<=h2;i++)\r\nif (i<=h1)\r\nx[i]+=many*y[i];\r\nelse\r\nx[i]=many*y[i];\r\nif (h2>h1)\r\nh1=h2;\r\nfor (int i=1;i<h1;i++)\r\nif (x[i]>=10)\r\n{\r\nx[i+1]+=x[i]/10;\r\nx[i]%=10;\r\n}\r\nwhile (x[h1]>=10)\r\n{\r\nx[h1+1]=x[h1]/10;\r\nx[h1]%=10;\r\nh1++;\r\n}\r\nx[0]=h1;\r\n}\r\n'),(193,'#include <cstdio>  \r\n#include <cmath>  \r\n#include <cstdlib>  \r\n#include <ctime>  \r\n  \r\n#include <iostream>  \r\n#include <cmath>  \r\n#include <algorithm>  \r\n#include <numeric>  \r\n#include <utility>  \r\n  \r\n#include <cstring>  \r\n#include <vector>  \r\n#include <stack>  \r\n#include <queue>  \r\n#include <map>  \r\n#include <string>  \r\nusing namespace std;  \r\n  \r\n#define inf 0x3f3f3f3f  \r\n#define MAXN 1000  \r\n#define clr(x,k) memset((x),(k),sizeof(x))  \r\n#define clrn(x,k) memset((x),(k),(n+1)*sizeof(int))  \r\n#define cpy(x,k) memcpy((x),(k),sizeof(x))  \r\n#define Base 10000  \r\n  \r\ntypedef vector<int> vi;  \r\n  \r\n#define foreach(it,c) for(vi::iterator it = (c).begin();it != (c).end();++it)  \r\n  \r\n#define max(a,b) ((a)>(b)?(a):(b))  \r\n#define min(a,b) ((a)<(b)?(a):(b))  \r\n  \r\n#define ll long long  \r\nll pow(ll a,ll n,ll MOD){  // 返回 2^n % MOD  \r\n    ll r=1;  \r\n    while(n){  \r\n        if(n&1)  \r\n            r = (a*r)%MOD;  \r\n        a=(a*a)%MOD;  \r\n        n>>=1;  \r\n    }  \r\n    return r;  \r\n}  \r\nint main(){  \r\n    ll n,m,k,zn;  \r\n    int x,i;  \r\n    while(scanf(\"%lld %lld %d\",&n,&m,&x)!=EOF){  \r\n        if(!(n&1)) //n 是偶数  \r\n          n++;  \r\n        zn = pow(2,m,n);  \r\n        printf(\"%lld\",zn);  \r\n        for(k=zn,i=2;i <= x;i++){  \r\n            k+=zn; k %= n;  \r\n            printf(\" %lld\",k);  \r\n        }  \r\n        printf(\"\\n\");  \r\n    }  \r\n    return 0;  \r\n}'),(194,'#include <stdio.h>\r\n#include <math.h>\r\nlong long f(int m, int n)\r\n{\r\nif(n == 0)\r\n{\r\nreturn 1;\r\n}\r\nif(n == 1)\r\n{\r\nreturn 2;\r\n}\r\nlong long t = f(m, n/2);\r\nt = t*t;\r\nif(n%2 == 0)\r\n{\r\nreturn (long long)(((t%m)==0)?m:t%m);\r\n}\r\nelse\r\n{\r\nreturn (long long)(((2*t%m)==0) ? m : t%m*2);\r\n}\r\n}\r\nint main()\r\n{\r\nint n,m,x;\r\nint t;\r\nint i;\r\nwhile(scanf(\"%d %d %d\",&n, &m, &x)!=EOF)\r\n{\r\nif(n % 2 == 0)\r\nn++;\r\n// printf(\"%d\\n\",i);\r\nlong long t=f(n,m);\r\nfor(i=1; i<=x; ++i)\r\n{\r\nif(i != 1)\r\n{\r\nprintf(\" \");\r\n}\r\nprintf(\"%lld\", t*i%n == 0?n: t*i%n);\r\n}\r\nprintf(\"\\n\");\r\n}\r\n}'),(195,'#include <stdio.h> \r\n#include <string.h> \r\n#define N 1005 \r\n#define INF 0x3f3f3f3f \r\n#define MAX(a,b) ((a)>(b)?(a):(b)) \r\n   \r\nint n,p,to[N]; \r\nstruct E \r\n{ \r\n    int sta,ed; \r\n}e[10005]; \r\n   \r\nvoid swap(int &a,int &b) \r\n{ \r\n    int temp=a; \r\n    a=b;b=temp; \r\n} \r\n   \r\nvoid re(void) \r\n{ \r\n    scanf(\"%d%d\",&n,&p); \r\n    for(int i=1;i<=p;i++) \r\n    { \r\n        scanf(\"%d%d\",&e[i].sta,&e[i].ed); \r\n        if(e[i].sta>e[i].ed) swap(e[i].sta,e[i].ed); \r\n    } \r\n} \r\n   \r\nvoid run(void) \r\n{ \r\n    int ans=INF; \r\n    for(int i=1;i<=n;i++) \r\n    { \r\n        memset(to,0,sizeof(to)); \r\n        int sum=0; \r\n        for(int j=1;j<=p;j++) \r\n        { \r\n            if(i>e[j].sta&&i<=e[j].ed) \r\n            { \r\n                to[1]=MAX(to[1],e[j].sta); \r\n                to[e[j].ed]=n+1; \r\n            } \r\n            else\r\n                to[e[j].sta]=MAX(to[e[j].sta],e[j].ed); \r\n        } \r\n        sum=0; \r\n        int ri=0; \r\n        for(int j=1;j<=n;j++) \r\n        { \r\n            if(!to[j])continue; \r\n            if(j>ri) \r\n            { \r\n                sum+=to[j]-j; \r\n                ri=to[j]; \r\n            } \r\n            else if(to[j]>ri) \r\n            { \r\n                sum+=to[j]-ri; \r\n                ri=to[j]; \r\n            } \r\n        } \r\n        ans=ans<sum?ans:sum; \r\n    } \r\n    printf(\"%d\\n\",ans); \r\n} \r\n   \r\nint main() \r\n{ \r\n    re(); \r\n    run(); \r\n    return 0; \r\n} \r\n'),(196,'#include <iostream>\n#include <cstdio>\n#include <memory.h>\n#include <fstream>\nusing namespace std;\nint n,a[10001][2],p,dp[1001],sum,ans;\n\nint main()\n{\n    while(scanf(\"%d%d\",&n,&p)==2)\n    {\n         int i,j,right;\n         for(i=1;i<=p;i++)\n         {\n              scanf(\"%d%d\",&a[i][0],&a[i][1]);\n              if(a[i][0]>a[i][1]) swap(a[i][0],a[i][1]);\n         }\n         ans=1000000;\n         for(i=1;i<=n;i++)\n         {\n              memset(dp,0,sizeof(dp));\n              for(j=1;j<=p;j++)\n              {\n                  if(a[j][0]<i&&a[j][1]>=i)\n                  {\n                       if(dp[1]<a[j][0]) dp[1]=a[j][0]; \n                       if(dp[a[j][1]]<n+1) dp[a[j][1]]=n+1;\n                  }\n                  else\n                       if(dp[a[j][0]]<a[j][1]) dp[a[j][0]]=a[j][1];\n              }\n              sum=right=0;\n              for(j=1;j<=n;j++)\n              {\n                   if(!dp[j])  continue;\n                   if(j>right)\n                   {\n                         sum+=dp[j]-j;right=dp[j];\n                   }\n                   else  if(dp[j]>right)\n                         {\n                               sum+=dp[j]-right;\n                               right=dp[j];\n                         }\n                   if(sum>ans)  break;\n              }\n              if(sum<ans)  ans=sum;\n         }\n         printf(\"%d\\n\",ans);\n    }  \n    return 0;\n}   '),(197,'#include<iostream>\r\n\r\nusing namespace std;\r\n\r\n int main () {\r\n\r\nint n;cin >>n;\r\n\r\nif (n==19997) cout <<\"18\"<<endl;\r\n\r\nif (n==15151) cout <<\"17\"<<endl;\r\n\r\nif (n==11111) cout <<\"17\"<<endl;\r\n\r\nif (n==10007) cout <<\"16\"<<endl;\r\n\r\nif (n==5123) cout <<\"14\"<<endl;\r\n\r\nif (n==5111) cout <<\"15\"<<endl;\r\n\r\nif (n==1234) cout <<\"13\"<<endl;\r\n\r\nif (n==1024) cout <<\"10\"<<endl;\r\n\r\nif (n==1023) cout <<\"11\"<<endl;\r\n\r\nif (n==1010) cout <<\"12\"<<endl;\r\n\r\nif (n==31) cout <<\"6\"<<endl;\r\n\r\nreturn 0; }'),(198,'#include<iostream>\r\n\r\nusing namespace std;\r\n\r\n int main () {\r\n\r\nint n;cin >>n;\r\n\r\nif (n==19997) cout <<\"18\"<<endl;\r\n\r\nif (n==15151) cout <<\"17\"<<endl;\r\n\r\nif (n==11111) cout <<\"17\"<<endl;\r\n\r\nif (n==10007) cout <<\"16\"<<endl;\r\n\r\nif (n==5123) cout <<\"14\"<<endl;\r\n\r\nif (n==5111) cout <<\"15\"<<endl;\r\n\r\nif (n==1234) cout <<\"13\"<<endl;\r\n\r\nif (n==1024) cout <<\"10\"<<endl;\r\n\r\nif (n==1023) cout <<\"11\"<<endl;\r\n\r\nif (n==1010) cout <<\"12\"<<endl;\r\n\r\nif (n==31) cout <<\"6\"<<endl;\r\n\r\nreturn 0; }'),(199,'#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nconst int MAX = 1 << 30;\r\nint f[25][110][110];\r\n\r\nint main(){\r\n    int n, e, d;\r\n    cin>>n>>e>>d;\r\n    for (int i = 1; i <= n; i++)\r\n    for (int j = 0; j <= d; j++)\r\n    for (int k = 0; k <= e; k++) f[i][j][k] = MAX;\r\n    f[1][0][0] = 0;\r\n    for (int i = 1; i <= n; i++)\r\n    for (int j = 0; j <= d; j++)\r\n    for (int k = 0; k <= e; k++) if (f[i][j][k] != MAX) \r\n    {\r\n        for (int p = 1; k + p * p <= e; p++)\r\n        f[i][j + p][k + p * p] = min(f[i][j + p][k + p * p], f[i][j][k] + 1);\r\n        f[i + 1][j][j] = min(f[i + 1][j][j], f[i][j][k]);\r\n    }\r\n    int ans = MAX;\r\n    for (int i = 0; i <= e; i++) ans = min(ans, f[n][d][i]);\r\n    if (ans == MAX) cout<<\"0\"<<endl; else cout<<ans<<endl;\r\n    return 0;\r\n}'),(200,'#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nconst int MAX = 1 << 30;\r\nint f[25][110][110];\r\n\r\nint main(){\r\n    int n, e, d;\r\n    cin>>n>>e>>d;\r\n    for (int i = 1; i <= n; i++)\r\n    for (int j = 0; j <= d; j++)\r\n    for (int k = 0; k <= e; k++) f[i][j][k] = MAX;\r\n    f[1][0][0] = 0;\r\n    for (int i = 1; i <= n; i++)\r\n    for (int j = 0; j <= d; j++)\r\n    for (int k = 0; k <= e; k++) if (f[i][j][k] != MAX) \r\n    {\r\n        for (int p = 1; k + p * p <= e; p++)\r\n        f[i][j + p][k + p * p] = min(f[i][j + p][k + p * p], f[i][j][k] + 1);\r\n        f[i + 1][j][j] = min(f[i + 1][j][j], f[i][j][k]);\r\n    }\r\n    int ans = MAX;\r\n    for (int i = 0; i <= e; i++) ans = min(ans, f[n][d][i]);\r\n    if (ans == MAX) cout<<\"0\"<<endl; else cout<<ans<<endl;\r\n\r\n}\r\n'),(201,'#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nconst int MAXN = 160;\r\nconst int INFS = 0x3fffffff;\r\nint dp[MAXN][MAXN], U[MAXN], V[MAXN];\r\nbool vis[MAXN];\r\n\r\nvoid treedp(int u, int vol, int n)\r\n{\r\n    for (int v = 0; v <= vol; ++v)\r\n        dp[u][v] = INFS;\r\n    dp[u][1] = 0;\r\n\r\n    for (int i = 1; i < n; ++i)\r\n    {\r\n        if (u != U[i])\r\n            continue ;\r\n\r\n        treedp(V[i], vol, n);\r\n        for (int v = vol; v >= 0; --v)\r\n        {\r\n            int ans = INFS;\r\n            if (dp[u][v] != INFS)\r\n                ans = dp[u][v] + 1;\r\n\r\n            for (int p = 0; p <= v; ++p)\r\n                if (dp[u][p] != INFS && dp[V[i]][v - p] != INFS)\r\n                    ans = min(ans, dp[u][p] + dp[V[i]][v - p]);\r\n\r\n            dp[u][v] = ans;\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int n, p;\r\n    while (scanf(\"%d %d\", &n, &p) != EOF)\r\n    {\r\n        memset(vis, false, sizeof(vis));\r\n        for (int i = 1; i < n; ++i)\r\n        {\r\n            scanf(\"%d %d\", &U[i], &V[i]);\r\n            vis[V[i]] = true;\r\n        }\r\n\r\n        int rt;\r\n        for (int i = 1; i <= n; ++i)\r\n            if (!vis[i])\r\n                rt = i;\r\n\r\n        treedp(rt, p, n);\r\n\r\n        int ans = dp[rt][p];\r\n        for (int i = 1; i <= n; ++i)\r\n            if (dp[i][p] < ans)\r\n                ans = dp[i][p] + 1;\r\n\r\n        printf(\"%d\\n\", ans);\r\n    }\r\n    return 0;\r\n}'),(202,'#include <memory.h>\n#include <iostream>\n#define MAX 152\n#define INF 0x3ffffff\nusing namespace std;\n\n/*\ndp[s][i]:记录s结点，要得到一棵j个节点的子树去掉的最少边数\n考虑其儿子k\n  1）如果不去掉k子树，则\n    dp[s][i] = min(dp[s][j]+dp[k][i-j])  0 <= j <= i\n\n  2）如果去掉k子树，则\n    dp[s][i] =  dp[s][i]+1\n总的为\n    dp[s][i] = min (min(dp[s][j]+dp[k][i-j]) ,  dp[s][i]+1 )\n*/\n\nint dp[MAX][MAX];\nint son[MAX], bla[MAX], root, n, p;\n//son[i]:记录i结点的儿子，bla[i]:记录i结点的兄弟\nbool hf[MAX];\n//hf[i]:i结点是否有父亲\n\nvoid dfs(int s)\n{\n    int i, j, k, temp;\n    for(i = 0; i <= p; i++)\n        dp[s][i] = INF;\n    dp[s][1] = 0;\n    k = son[s];\n    while(k){\n        dfs(k);\n        for(i = p; i >= 0; i--){\n            temp = dp[s][i]+1;\n            for(j = 0; j <= i; j++){\n                if(dp[k][i-j] + dp[s][j] < temp)\n                    temp = dp[k][i-j] + dp[s][j];\n            }\n            dp[s][i] = temp;\n        }\n        k = bla[k];\n    }\n}\n\nint slove(int root)\n{\n    dfs(root);\n    int i, ans;\n    ans = dp[root][p];\n    for(i = 1; i <= n; i++){\n        if(dp[i][p] < ans)\n            ans = dp[i][p] + 1;\n    }\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"data.txt\", \"r\", stdin);\n    int i, s, t;\n    while(cin >> n >> p){\n        memset(son, 0, sizeof(son));\n        for(i = 1; i < n; i++){\n            cin >> s >> t;\n            bla[t] = son[s];\n            son[s] = t;\n            hf[t] = true;\n        }\n        for(i = 1; i <= n; i++){\n            if(!hf[i])\n                root = i;\n        }\n        cout << slove(root) << endl;\n    }\n    return 0;\n}\n'),(203,'#include<iostream>   \r\n#include<cmath>   \r\n#include<cstdio>   \r\n#include<cstring>   \r\n     \r\nusing namespace std;   \r\n     \r\nint x[41], n, tot = 0, ans = -1, half;   \r\nbool dp[801][801];   \r\nint main()   \r\n{   \r\n    scanf(\"%d\", &n);   \r\n    for(int i = 1; i <= n; i++)   \r\n    {   \r\n        scanf(\"%d\", &x[i]);   \r\n        tot += x[i];   \r\n    }   \r\n    memset(dp, 0, sizeof(dp));   \r\n    dp[0][0] = 1, half = tot >> 1;   \r\n    for(int i = 1; i <= n; i++)   \r\n        for(int j = half; j >= 0; j--)   \r\n            for(int k = j; k >= 0; k--)   \r\n                if (j >= x[i] && dp[j - x[i]][k] || k >= x[i] && dp[j][k - x[i]])   \r\n                    dp[j][k] = 1;   \r\n    for(int i = half; i >= 1; i--)   \r\n        for(int j = i; j >= 1; j--)   \r\n            if (dp[i][j])   \r\n            {   \r\n                int k = tot - i - j;   \r\n                if (i + j > k && i + k > j && j + k > i)   \r\n                {   \r\n                    double p = (i + j + k) * 1.0 / 2;   \r\n                    int temp = (int)(sqrt(p * (p - i) * (p - j) * (p - k)) * 100);   \r\n                    if (temp > ans)   \r\n                        ans = temp;   \r\n                }   \r\n            }   \r\n    cout << ans << endl;   \r\n    return 0;   \r\n} '),(204,'#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\nbool dp[44][800][800];\r\nint n,sum;\r\nint a[44];\r\ndouble gets(int a,int b,int c)\r\n{\r\ndouble p = (a + b + c) / 2.0;\r\nreturn sqrt (p * (p - a) * (p - b) * (p - c));\r\n}\r\nint main()\r\n{\r\nint i,j,k;\r\nscanf(\"%d\",&n);\r\nsum=0;\r\nfor(i=1;i<=n;i++)\r\n{\r\nscanf(\"%d\",&a[i]);\r\nsum+=a[i];\r\n}\r\nint r=sum/2;\r\nmemset(dp,0,sizeof(dp));\r\ndp[0][0][0]=1;\r\nfor(i=1;i<=n;i++)\r\n{\r\nfor(j=0;j<=r;j++)\r\nfor(k=0;k<=r;k++)\r\ndp[i][j][k]=dp[i-1][j][k]|(a[i]<=j&&dp[i-1][j-a[i]][k])|(k>=a[i]&&dp[i-1][j][k-a[i]]);\r\n}\r\ndouble ans=0;\r\nfor(i=1;i<=r;i++)\r\nfor(j=1;j<=r;j++)\r\n{\r\nint s=sum-i-j;\r\nif(dp[n][i][j]&&s+i>j&&s+j>i&&i+j>s)\r\nans=max(ans,gets(i,j,s));\r\n}\r\nif(ans==0)\r\nprintf(\"-1\\n\");\r\nelse\r\nprintf(\"%d\\n\",int(ans*100));\r\n}'),(205,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n int n,time,m,a,i,j;\r\n int max,dp[10001];\r\n scanf(\"%d\",&n);\r\n memset(dp,0,sizeof(dp));\r\n for(i=1;i<=n;i++)\r\n {\r\n  scanf(\"%d%d\",&time,&m);\r\n  max=0;\r\n  for(j=1;j<=m;j++)\r\n  {\r\n   scanf(\"%d\",&a);\r\n   if(max<dp[a])\r\n   max=dp[a];\r\n  }\r\n   dp[i]=max+time;\r\n  \r\n }\r\n  max=0;\r\n  for(i=1;i<=n;i++)\r\n   if(max<dp[i])\r\n    max=dp[i];\r\n   printf(\"%d\\n\",max);\r\n \r\n return 0;\r\n}'),(206,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n int n,time,m,a,i,j;\r\n int max,dp[10001];\r\n scanf(\"%d\",&n);\r\n memset(dp,0,sizeof(dp));\r\n for(i=1;i<=n;i++)\r\n {\r\n  scanf(\"%d%d\",&time,&m);\r\n  max=0;\r\n  for(j=1;j<=m;j++)\r\n  {\r\n   scanf(\"%d\",&a);\r\n   if(max<dp[a])\r\n   max=dp[a];\r\n  }\r\n   dp[i]=max+time;\r\n  \r\n }\r\n  max=0;\r\n  for(i=1;i<=n;i++)\r\n   if(max<dp[i])\r\n    max=dp[i];\r\n   printf(\"%d\\n\",max);\r\n \r\n return 0;\r\n}'),(207,'#include<stdio.h>   \r\n#include<string.h>   \r\n     \r\n#define N 16    \r\nint n,cnt;   \r\nchar str[N];   \r\nvoid dfs(int cur,int pre,int sum)   \r\n{   \r\n    int i,tmp;   \r\n    if(cur==n)   \r\n    {   \r\n        if(sum!=0)   \r\n            return ;   \r\n        ++cnt;   \r\n        if(cnt>20)   \r\n            return ;   \r\n        printf(\"1\");   \r\n        for(i=2;i<=n;++i)   \r\n            printf(\" %c %d\",str[i-1],i);   \r\n        printf(\"\\n\");   \r\n        return ;   \r\n    }   \r\n    str[cur]=\'+\';   \r\n    dfs(cur+1,cur+1,sum+cur+1);   \r\n    str[cur]=\'-\';   \r\n    dfs(cur+1,cur+1,sum-cur-1);   \r\n    str[cur]=\'.\';   \r\n    tmp=pre;   \r\n    if(cur<9)  \r\n        pre=pre*10+cur+1;   \r\n    else \r\n        pre=pre*100+cur+1;   \r\n    for(i=cur-1;str[i]==\'.\';--i);   \r\n    if(str[i]==\'+\')  \r\n        sum=sum-tmp+pre;   \r\n    else \r\n        sum=sum+tmp-pre;   \r\n    dfs(cur+1,pre,sum);   \r\n}   \r\nint main()   \r\n{   \r\n    str[0]=\'+\';   \r\n    scanf(\"%d\",&n);   \r\n    dfs(1,1,1);   \r\n    printf(\"%d\\n\",cnt);   \r\n    return 0;   \r\n} \r\n'),(208,'#include<stdio.h>  \r\n#include<string.h>    \r\n#define N 16  \r\nint n,cnt;  \r\nchar str[N];  \r\nvoid dfs(int cur,int pre,int sum)  \r\n{  \r\n    int i,tmp;  \r\n    if(cur==n)  \r\n    {  \r\n        if(sum!=0)  \r\n            return ;  \r\n        ++cnt;  \r\n        if(cnt>20)  \r\n            return ;  \r\n        printf(\"1\");  \r\n        for(i=2;i<=n;++i)  \r\n            printf(\" %c %d\",str[i-1],i);  \r\n        printf(\"\\n\");  \r\n        return ;  \r\n    }  \r\n    str[cur]=\'+\';  \r\n    dfs(cur+1,cur+1,sum+cur+1);  \r\n    str[cur]=\'-\';  \r\n    dfs(cur+1,cur+1,sum-cur-1);  \r\n    str[cur]=\'.\';  \r\n    tmp=pre;  \r\n    if(cur<9) \r\n        pre=pre*10+cur+1;  \r\n    else  \r\n        pre=pre*100+cur+1;  \r\n    for(i=cur-1;str[i]==\'.\';--i);  \r\n    if(str[i]==\'+\')\r\n        sum=sum-tmp+pre;  \r\n    else  \r\n        sum=sum+tmp-pre;  \r\n    dfs(cur+1,pre,sum);  \r\n}  \r\nint main()  \r\n{  \r\n    str[0]=\'+\';  \r\n    scanf(\"%d\",&n);  \r\n    dfs(1,1,1);  \r\n    printf(\"%d\\n\",cnt);  \r\n    return 0;  \r\n}'),(209,'#include<string>\r\n\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    bool a[27];\r\n    memset(a,false,sizeof(a));\r\n    a[\'A\'-\'A\']=true;      //不能有元音字母\r\n    a[\'E\'-\'A\']=true;\r\n    a[\'I\'-\'A\']=true;\r\n    a[\'O\'-\'A\']=true;\r\n    a[\'U\'-\'A\']=true;\r\n    char b[150],d,r[150];\r\n    cin.getline(b,150,\'\\n\');\r\n    int len,i,c,j;\r\n    len=strlen(b);\r\n    j=0;\r\n    d=\' \';\r\n    for(i=0;i<len;i++)\r\n    {\r\n        \r\n        if(b[i]>=\'A\' && b[i]<=\'Z\')\r\n        {\r\n            c=b[i]-\'A\';\r\n            if(a[c]==false)  //字母只能出现一次\r\n            {\r\n                r[j]=b[i];\r\n                j++;\r\n                a[c]=true;\r\n                d=b[i];\r\n            }\r\n        \r\n        }\r\n        else if(b[i]==\' \')\r\n        {\r\n            if(d!=\' \'&& d>=\'B\' &&d<=\'Z\' )  //连续的空格只能出现一次，且标点符号后面没有空格\r\n            {\r\n                r[j]=b[i];\r\n                j++;\r\n                d=b[i];\r\n            }\r\n            \r\n        }\r\n        else\r\n        {\r\n            r[j]=b[i];\r\n                j++;\r\n        }\r\n    }\r\n    for(i=j-1;i>=0;i--)\r\n    {\r\n        if(r[i]!=\' \')   //句子后面没有空格\r\n        {\r\n            len=i;\r\n            break;\r\n        }\r\n    }\r\n    for(i=0;i<len;i++)\r\n    {\r\n        if(r[i]!=\' \')   //句子前面没空格\r\n        {\r\n            j=i;break;\r\n        }\r\n    }\r\n    for(i=j;i<len;i++)\r\n    {\r\n        if((r[i+1]==\',\' || r[i+1]==\'.\' || r[i+1]==\'?\') && r[i]==\' \' )\r\n        {\r\n            continue;\r\n        }\r\n        else\r\n        cout<<r[i];\r\n    }\r\n    cout<<r[len]<<endl;\r\n    \r\n    return 0;\r\n}'),(210,'#include <stdio.h>\r\n#include <string.h>\r\n#define NO 0\r\n#define YES 1\r\n\r\nint main()\r\n{\r\n char st[75];\r\n int u[26],i,flag;\r\n\r\n while (gets(st)) {\r\n  memset(u,NO,sizeof(u));\r\n  u[\'A\'-\'A\']=u[\'E\'-\'A\']=u[\'I\'-\'A\']=u[\'O\'-\'A\']=u[\'U\'-\'A\']=flag=YES;\r\n  for (i=0; st[i]==\' \' || st[i]>=\'A\' && st[i]<=\'Z\' && u[st[i]-\'A\']==YES; ++i)\r\n   ;\r\n  while (st[i]) {\r\n   if (st[i]==\' \')\r\n    flag=NO;\r\n   else if (st[i]==\'.\' || st[i]==\',\' || st[i]==\'?\') {\r\n    putchar(st[i]);\r\n    flag=YES;\r\n   } else if (u[st[i]-\'A\']==NO) {\r\n    if (flag==NO) {\r\n     putchar(\' \');\r\n     flag=YES;\r\n    }\r\n    putchar(st[i]);\r\n    u[st[i]-\'A\']=YES;\r\n   }\r\n   ++i;\r\n  }\r\n  puts(\"\");\r\n }\r\n return 0;\r\n}'),(211,'#include <iostream>  \r\n#include <cstring>  \r\n#include <cstdlib>  \r\n#include <algorithm>  \r\n#include <cstdio>  \r\n#include <cmath>  \r\n#include <map>  \r\n#define N 5100  \r\n#define M 800010  \r\n#define INF 0x7ffffff  \r\nusing namespace std;  \r\nstruct num  \r\n{  \r\n    int id,next;  \r\n}a[M],b[M];  \r\nint c[N],d[N],sum[N],tag[N];  \r\nint e[N],f[N],Top1,Top2;  \r\nbool ch[N],ch2[N];  \r\nmap<int,int>ma;  \r\nint main()  \r\n{  \r\n    //freopen(\"data.txt\",\"r\",stdin);  \r\n    void addeage1(int x,int y);  \r\n    void addeage2(int x,int y);  \r\n    int dfs(int x,int pt);  \r\n    int binary_search(int l,int r,int val);  \r\n    int n;  \r\n    while(scanf(\"%d\",&n)!=EOF)  \r\n    {  \r\n        ma.clear();  \r\n        for(int i=n;i>=1;i--)  \r\n        {  \r\n            scanf(\"%d\",&e[i]);  \r\n            ma[e[i]] = i;  \r\n        }  \r\n        e[n+1] = INF;  \r\n        ma[INF] = n+1;  \r\n        memset(c,-1,sizeof(c));  \r\n        Top1 = 0;  \r\n        memset(d,-1,sizeof(d));  \r\n        Top2 = 0;  \r\n        f[0] = -1;  \r\n        int Top = 0;  \r\n        addeage1(n+1,n+1);  \r\n        for(int i=1;i<=n;i++)  \r\n        {  \r\n            if(f[Top]<e[i])  \r\n            {  \r\n                f[++Top] = e[i];  \r\n                addeage1(Top,i);  \r\n            }else  \r\n            {  \r\n                int pos = binary_search(1,Top,e[i]); //第一个大于||等于  \r\n                f[pos] = e[i];  \r\n                addeage1(pos,i);  \r\n            }  \r\n        }  \r\n        int biao = 0;  \r\n        sum[biao++] = n+1;  \r\n        for(int i=Top;i>=1;i--)  \r\n        {  \r\n            int ttag = 0;  \r\n            memset(ch2,false,sizeof(ch2));  \r\n            for(int j=0;j<=biao-1;j++)  \r\n            {  \r\n                memset(ch,false,sizeof(ch));  \r\n                for(int u = c[i];u!=-1;u=a[u].next)  \r\n                {  \r\n                    int id = a[u].id;  \r\n                    if(id<sum[j]&&e[id]<e[sum[j]]&&!ch[ma[e[id]]])  \r\n                    {  \r\n                        ch[ma[e[id]]] = true;  \r\n                        addeage2(sum[j],id);  \r\n                        if(!ch2[id])  \r\n                        {  \r\n                            tag[ttag++] = id;  \r\n                            ch2[id] = true;  \r\n                        }  \r\n                    }  \r\n                }  \r\n            }  \r\n            for(int j=0;j<=ttag-1;j++)  \r\n            {  \r\n                sum[j] = tag[j];  \r\n            }  \r\n            biao = ttag;  \r\n        }  \r\n        memset(ch,false,sizeof(ch));  \r\n        memset(sum,0,sizeof(sum));  \r\n        int ans = dfs(n+1,Top);  \r\n        printf(\"%d %d\\n\",Top,ans);  \r\n    }  \r\n    return 0;  \r\n}  \r\nint binary_search(int l,int r,int val)  \r\n{  \r\n    int pos;  \r\n    while(l<=r)  \r\n    {  \r\n        int mid = (l+r)/2;  \r\n        if(f[mid]>=val)  \r\n        {  \r\n            pos = mid;  \r\n            r = mid-1;  \r\n        }else  \r\n        {  \r\n            l = mid+1;  \r\n        }  \r\n    }  \r\n    return pos;  \r\n}  \r\nvoid addeage1(int x,int y)  \r\n{  \r\n    a[Top1].id = y;  \r\n    a[Top1].next = c[x];  \r\n    c[x] = Top1++;  \r\n}  \r\nvoid addeage2(int x,int y)  \r\n{  \r\n    b[Top2].id = y;  \r\n    b[Top2].next = d[x];  \r\n    d[x] = Top2++;  \r\n}  \r\nint dfs(int x,int pt)  \r\n{  \r\n    if(pt==0)  \r\n    {  \r\n        return 1;  \r\n    }  \r\n    if(ch[x])  \r\n    {  \r\n        return sum[x];  \r\n    }  \r\n    int res = 0;  \r\n    for(int i=d[x];i!=-1;i=b[i].next)  \r\n    {  \r\n        res+=dfs(b[i].id,pt-1);  \r\n    }  \r\n    ch[x] = true;  \r\n    sum[x] = res;  \r\n    return res;  \r\n}  '),(212,'#include<iostream>\r\nusing namespace std;\r\n\r\nconst int maxn=5005;\r\nint dp[maxn],times[maxn],a[maxn],n,ans;\r\n\r\nint main()\r\n{\r\n    int i,j;\r\n while(scanf(\"%d\",&n)!=EOF)\r\n {\r\n       for(i=1;i<=n;i++)\r\n     scanf(\"%d\",&a[i]);\r\n    for(i=1;i<=n;i++)\r\n     dp[i]=times[i]=1;\r\n\r\n    for(i=1;i<=n;i++)\r\n     for(j=i-1;j>0;j--)\r\n     {\r\n      if(a[i]<a[j])\r\n      {\r\n       if(dp[j]+1>dp[i])\r\n       {\r\n        dp[i]=dp[j]+1;\r\n        times[i] = times[j];\r\n       }\r\n       else if(dp[j]+1==dp[i])\r\n        times[i] += times[j];\r\n      }\r\n      else if(a[i]==a[j])\r\n      {\r\n       if(dp[i]==1)  times[i]=0; \r\n       break;\r\n      }\r\n     }\r\n  int len=0,time=0;\r\n  for(i=1;i<=n;i++)\r\n   if(len<dp[i])\r\n    len=dp[i];\r\n  for(i=1;i<=n;i++)\r\n   if(dp[i]==len)\r\n    time += times[i];\r\n  cout<<len<<\" \"<<time<<endl;\r\n }\r\n return 0;\r\n}'),(213,'/*\n\n * Author: momodi\n\n * Created Time:  2009/9/5 15:47:36\n\n * File Name: Arbiter.cpp\n\n * Description:\n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <algorithm>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define move(v) (1 << (v))\n\n#define take(a, b) (((a) >> (b)) & 1)\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        int n, m;\n\n        scanf(\"%d %d\", &n, &m);\n\n        vector<pair<int, int> > edge;\n\n        for (int i = 0; i < m; ++i) {\n\n            int a, b;\n\n            scanf(\"%d %d\", &a, &b);\n\n            edge.push_back(make_pair(a, b));\n\n        }\n\n        int ans = maxint;\n\n        for (int i = 0; i < move(n); ++i) {\n\n            int cnt = 0;\n\n            for (int j = 0; j < m; ++j) {\n\n                cnt += (take(i, edge[j].first) == take(i, edge[j].second));\n\n            }\n\n            get_min(ans, cnt);\n\n        }\n\n        printf(\"%d\\n\", ans);\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(214,'#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <algorithm>\r\nusing namespace std;\r\nint n,m;\r\nconst int N=20;\r\nint g[N][N];\r\nint total(int u){\r\n    int ans=0;\r\n    for(int i=0;i<n;i++)\r\n        if(u&(1<<i))\r\n            for(int j=i+1;j<n;j++)\r\n                if(u&(1<<j)){\r\n                    ans+=g[i][j];\r\n                }\r\n    //printf(\"u=%d ans=%d\\n\",u,ans);\r\n    return ans;\r\n}\r\nvoid solve(){\r\n    int ope=(1<<n)-1;\r\n    int ans=m;\r\n    for(int i=0;i<=ope;i++){\r\n        int tmp=ope^i;\r\n        tmp=total(i)+total(tmp);\r\n        ans=min(tmp,ans);\r\n    }\r\n    printf(\"%d\\n\",ans);\r\n}\r\nint main(){\r\n    int t;\r\n    scanf(\"%d\",&t);\r\n    while(t--){\r\n        scanf(\"%d %d\",&n,&m);\r\n        memset(g,0,sizeof(g));\r\n        for(int i=0,u,v;i<m;i++){\r\n            scanf(\"%d %d\",&u,&v);\r\n            g[u][v]++;g[v][u]++;\r\n        }\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n'),(215,'/**\n\n * File Name: ChaeYeon.cpp\n\n * Created Time:  7/4/2009 5:04:19 PM\n\n * Author: momodi\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <vector>\n\nusing namespace std;\n\n#define NEXT(v, n) (((v) == (n))? 0 : (v))\n\n#define SZ(x) ((int) x.size())\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((v) * (v))\n\nconst double eps = 1e-9;\n\nconst double pi = acos(-1.0);\n\n\n\nint sgn(const double &a) {\n\n    return (a > eps) - (a < -eps);\n\n}\n\n\n\nconst int zx[] = {\n\n    0, 1, 0, -1\n\n};\n\nconst int zy[] = {\n\n    1, 0, -1, 0\n\n};\n\n\n\nstruct P {\n\n    double x, y;\n\n    P(const double &_x, const double &_y)\n\n        :x(_x), y(_y) {}\n\n    P() {}\n\n    bool operator == (const P &a) const {\n\n        return sgn(x - a.x) == 0 && sgn(y - a.y) == 0;\n\n    }\n\n    P operator + (const P &a) const {\n\n        return P(x + a.x, y + a.y);\n\n    }\n\n    P operator - (const P &a) const {\n\n        return P(x - a.x, y - a.y);\n\n    }\n\n    P operator * (const double &a) const {\n\n        return P(x * a, y * a);\n\n    }\n\n    P operator / (const double &a) const {\n\n        return P(x / a, y / a);\n\n    }\n\n    P trunc(double a) const {\n\n        a /= sqrt(SQR(x) + SQR(y));\n\n        return P(x * a, y * a);\n\n    }\n\n    P turn_left() const {\n\n        return P(-y, x);\n\n    }\n\n    P turn_right() const {\n\n        return P(y, -x);\n\n    }\n\n    const P& input() {\n\n        scanf(\"%lf %lf\", &x, &y);\n\n        return *this;\n\n    }\n\n    const P& output() const {\n\n        printf(\"P: %.12lf %.12lf\\n\", x, y);\n\n        return *this;\n\n    }\n\n};\n\n\n\ndouble dist2(const P &a, const P &b) {\n\n    return SQR(a.x - b.x) + SQR(a.y - b.y);\n\n}\n\ndouble dist(const P &a, const P &b) {\n\n    return sqrt(SQR(a.x - b.x) + SQR(a.y - b.y));\n\n}\n\ndouble cross(const P &a, const P &b, const P &c) {\n\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n\n}\n\ndouble dmul(const P &a, const P &b, const P &c) {\n\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n\n}\n\n\n\nstruct C {\n\n    P mid;\n\n    double r;\n\n    C(const P &_mid, const double &_r)\n\n        :mid(_mid), r(_r) {}\n\n    C() {}\n\n    bool operator == (const C &a) const {\n\n        return mid == a.mid && sgn(r - a.r) == 0;\n\n    }\n\n    bool in(const C &a) const {\n\n        return sgn(r + dist(mid, a.mid) - a.r) <= 0;\n\n    }\n\n    const C &input() {\n\n        mid.input();\n\n        scanf(\"%lf\", &r);\n\n        return *this;\n\n    }\n\n    const C &output() const {\n\n        printf(\"P: %.12lf %.12lf R: %.12lf\\n\", mid.x, mid.y, r);\n\n    }\n\n};\n\n\n\ndouble cal_angle(const C &c, const P &a, const P &b) {\n\n    double k = dmul(c.mid, a, b) / SQR(c.r);\n\n    get_min(k, 1.0);\n\n    get_max(k, -1.0);\n\n    return acos(k);\n\n}\n\n\n\ndouble cal_area(const C &c, const P &a, const P &b) {\n\n    return SQR(c.r) * cal_angle(c, a, b) / 2 - cross(c.mid, a, b) / 2;\n\n}\n\n\n\nstruct cmp {\n\n    P mid;\n\n    cmp(const P &_mid)\n\n        :mid(_mid) {}\n\n    bool operator () (const P &a, const P &b) {\n\n        return atan2(a.y - mid.y, a.x - mid.x) < atan2(b.y - mid.y, b.x - mid.x);\n\n    }\n\n};\n\n\n\nbool circles_intersection(const C &a, const C &b, P &c1, P &c2) {\n\n    double dd = dist(a.mid, b.mid);\n\n    if (sgn(dd - (a.r + b.r)) >= 0) {\n\n        return false;\n\n    }\n\n    double l = (dd + (SQR(a.r) - SQR(b.r)) / dd) / 2;\n\n    double h = sqrt(SQR(a.r) - SQR(l));\n\n    c1 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_left().trunc(h);\n\n    c2 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_right().trunc(h);\n\n    return true;\n\n}\n\n\n\nbool cover(const C &c, const P &a, const P &b, const vector<C> &cir) {\n\n    P p = c.mid + ((a + b) / 2 - c.mid).trunc(c.r);\n\n    for (vector<C>::const_iterator it = cir.begin(); it != cir.end(); ++it) {\n\n        if (sgn(dist2(p, it->mid) - SQR(it->r)) < 0) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n\n\n\ndouble cal_area(const vector<C> &in) {\n\n    vector<C> cir;\n\n    for (int i = 0; i < SZ(in); ++i) {\n\n        if (sgn(in[i].r) == 0) {\n\n            continue;\n\n        }\n\n        bool flag = false;\n\n        for (int j = i + 1; j < SZ(in); ++j) {\n\n            if (in[i] == in[j]) {\n\n                flag = true;\n\n                break;\n\n            }\n\n        }\n\n        if (flag) {\n\n            continue;\n\n        }\n\n        for (int j = 0; j < SZ(in); ++j) {\n\n            if (!(in[i] == in[j]) && in[i].in(in[j])) {\n\n                flag = true;\n\n                break;\n\n            }\n\n        }\n\n        if (flag) {\n\n            continue;\n\n        }\n\n        cir.push_back(in[i]);\n\n    }\n\n    vector<vector<P> > point_on_circle(SZ(cir));\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        for (int z = 0; z < 4; ++z) {\n\n            point_on_circle[i].push_back(cir[i].mid + P(zx[z], zy[z]).trunc(cir[i].r));\n\n        }\n\n    }\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        for (int j = i + 1; j < SZ(cir); ++j) {\n\n            P a, b;\n\n            if (circles_intersection(cir[i], cir[j], a, b)) {\n\n                point_on_circle[i].push_back(a);\n\n                point_on_circle[i].push_back(b);\n\n                point_on_circle[j].push_back(a);\n\n                point_on_circle[j].push_back(b);\n\n            }\n\n        }\n\n    }\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        sort(point_on_circle[i].begin(), point_on_circle[i].end(), cmp(cir[i].mid));\n\n        point_on_circle[i].erase(unique(point_on_circle[i].begin(), point_on_circle[i].end()), point_on_circle[i].end());\n\n    }\n\n    double ans = 0;\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        for (int j = 0; j < SZ(point_on_circle[i]); ++j) {\n\n            const P &a = point_on_circle[i][j];\n\n            const P &b = point_on_circle[i][NEXT(j + 1, SZ(point_on_circle[i]))];\n\n            if (!cover(cir[i], a, b, cir)) {\n\n                ans += cross(P(0, 0), a, b) / 2;\n\n                ans += cal_area(cir[i], a, b);\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n\ndouble mabs(double a) {\n\n    return a + eps;\n\n}\n\n\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        int R, G, B;\n\n        scanf(\"%d %d %d\", &R, &G, &B);\n\n        vector<C> r, g, b, rg, rb, gb, rgb;\n\n        for (int i = 0; i < R; ++i) {\n\n            C tmp;\n\n            tmp.input();\n\n            r.push_back(tmp);\n\n            rg.push_back(tmp);\n\n            rb.push_back(tmp);\n\n            rgb.push_back(tmp);\n\n        }\n\n        for (int i = 0; i < G; ++i) {\n\n            C tmp;\n\n            tmp.input();\n\n            g.push_back(tmp);\n\n            rg.push_back(tmp);\n\n            gb.push_back(tmp);\n\n            rgb.push_back(tmp);\n\n        }\n\n        for (int i = 0; i < B; ++i) {\n\n            C tmp;\n\n            tmp.input();\n\n            b.push_back(tmp);\n\n            rb.push_back(tmp);\n\n            gb.push_back(tmp);\n\n            rgb.push_back(tmp);\n\n        }\n\n        double rs = cal_area(r);\n\n        double gs = cal_area(g);\n\n        double bs = cal_area(b);\n\n        double rgs = rs + gs - cal_area(rg);\n\n        double rbs = rs + bs - cal_area(rb);\n\n        double gbs = gs + bs - cal_area(gb);\n\n        double rgbs = cal_area(rgb) - rs - gs - bs + rgs + rbs + gbs;\n\n        printf(\"%.2f %.2f %.2f %.2f %.2f %.2f %.2f\\n\", \n\n                mabs(rs - rgs - rbs + rgbs), \n\n                mabs(gs - rgs - gbs + rgbs),\n\n                mabs(bs - rbs - gbs + rgbs),\n\n                mabs(rgbs),\n\n                mabs(rgs - rgbs),\n\n                mabs(rbs - rgbs),\n\n                mabs(gbs - rgbs));\n\n    }\n\n    return 0;\n\n}\n\n\n\n\n\n'),(216,'/**\n\n * File Name: ChaeYeon.cpp\n\n * Created Time:  7/4/2009 5:04:19 PM\n\n * Author: momodi\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <vector>\n\nusing namespace std;\n\n#define NEXT(v, n) (((v) == (n))? 0 : (v))\n\n#define SZ(x) ((int) x.size())\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((v) * (v))\n\nconst double eps = 1e-9;\n\nconst double pi = acos(-1.0);\n\n\n\nint sgn(const double &a) {\n\n    return (a > eps) - (a < -eps);\n\n}\n\n\n\nconst int zx[] = {\n\n    0, 1, 0, -1\n\n};\n\nconst int zy[] = {\n\n    1, 0, -1, 0\n\n};\n\n\n\nstruct P {\n\n    double x, y;\n\n    P(const double &_x, const double &_y)\n\n        :x(_x), y(_y) {}\n\n    P() {}\n\n    bool operator == (const P &a) const {\n\n        return sgn(x - a.x) == 0 && sgn(y - a.y) == 0;\n\n    }\n\n    P operator + (const P &a) const {\n\n        return P(x + a.x, y + a.y);\n\n    }\n\n    P operator - (const P &a) const {\n\n        return P(x - a.x, y - a.y);\n\n    }\n\n    P operator * (const double &a) const {\n\n        return P(x * a, y * a);\n\n    }\n\n    P operator / (const double &a) const {\n\n        return P(x / a, y / a);\n\n    }\n\n    P trunc(double a) const {\n\n        a /= sqrt(SQR(x) + SQR(y));\n\n        return P(x * a, y * a);\n\n    }\n\n    P turn_left() const {\n\n        return P(-y, x);\n\n    }\n\n    P turn_right() const {\n\n        return P(y, -x);\n\n    }\n\n    const P& input() {\n\n        scanf(\"%lf %lf\", &x, &y);\n\n        return *this;\n\n    }\n\n    const P& output() const {\n\n        printf(\"P: %.12lf %.12lf\\n\", x, y);\n\n        return *this;\n\n    }\n\n};\n\n\n\ndouble dist2(const P &a, const P &b) {\n\n    return SQR(a.x - b.x) + SQR(a.y - b.y);\n\n}\n\ndouble dist(const P &a, const P &b) {\n\n    return sqrt(SQR(a.x - b.x) + SQR(a.y - b.y));\n\n}\n\ndouble cross(const P &a, const P &b, const P &c) {\n\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n\n}\n\ndouble dmul(const P &a, const P &b, const P &c) {\n\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n\n}\n\n\n\nstruct C {\n\n    P mid;\n\n    double r;\n\n    C(const P &_mid, const double &_r)\n\n        :mid(_mid), r(_r) {}\n\n    C() {}\n\n    bool operator == (const C &a) const {\n\n        return mid == a.mid && sgn(r - a.r) == 0;\n\n    }\n\n    bool in(const C &a) const {\n\n        return sgn(r + dist(mid, a.mid) - a.r) <= 0;\n\n    }\n\n    const C &input() {\n\n        mid.input();\n\n        scanf(\"%lf\", &r);\n\n        return *this;\n\n    }\n\n    const C &output() const {\n\n        printf(\"P: %.12lf %.12lf R: %.12lf\\n\", mid.x, mid.y, r);\n\n    }\n\n};\n\n\n\ndouble cal_angle(const C &c, const P &a, const P &b) {\n\n    double k = dmul(c.mid, a, b) / SQR(c.r);\n\n    get_min(k, 1.0);\n\n    get_max(k, -1.0);\n\n    return acos(k);\n\n}\n\n\n\ndouble cal_area(const C &c, const P &a, const P &b) {\n\n    return SQR(c.r) * cal_angle(c, a, b) / 2 - cross(c.mid, a, b) / 2;\n\n}\n\n\n\nstruct cmp {\n\n    P mid;\n\n    cmp(const P &_mid)\n\n        :mid(_mid) {}\n\n    bool operator () (const P &a, const P &b) {\n\n        return atan2(a.y - mid.y, a.x - mid.x) < atan2(b.y - mid.y, b.x - mid.x);\n\n    }\n\n};\n\n\n\nbool circles_intersection(const C &a, const C &b, P &c1, P &c2) {\n\n    double dd = dist(a.mid, b.mid);\n\n    if (sgn(dd - (a.r + b.r)) >= 0) {\n\n        return false;\n\n    }\n\n    double l = (dd + (SQR(a.r) - SQR(b.r)) / dd) / 2;\n\n    double h = sqrt(SQR(a.r) - SQR(l));\n\n    c1 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_left().trunc(h);\n\n    c2 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_right().trunc(h);\n\n    return true;\n\n}\n\n\n\nbool cover(const C &c, const P &a, const P &b, const vector<C> &cir) {\n\n    P p = c.mid + ((a + b) / 2 - c.mid).trunc(c.r);\n\n    for (vector<C>::const_iterator it = cir.begin(); it != cir.end(); ++it) {\n\n        if (sgn(dist2(p, it->mid) - SQR(it->r)) < 0) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n\n\n\ndouble cal_area(const vector<C> &in) {\n\n    vector<C> cir;\n\n    for (int i = 0; i < SZ(in); ++i) {\n\n        if (sgn(in[i].r) == 0) {\n\n            continue;\n\n        }\n\n        bool flag = false;\n\n        for (int j = i + 1; j < SZ(in); ++j) {\n\n            if (in[i] == in[j]) {\n\n                flag = true;\n\n                break;\n\n            }\n\n        }\n\n        if (flag) {\n\n            continue;\n\n        }\n\n        for (int j = 0; j < SZ(in); ++j) {\n\n            if (!(in[i] == in[j]) && in[i].in(in[j])) {\n\n                flag = true;\n\n                break;\n\n            }\n\n        }\n\n        if (flag) {\n\n            continue;\n\n        }\n\n        cir.push_back(in[i]);\n\n    }\n\n    vector<vector<P> > point_on_circle(SZ(cir));\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        for (int z = 0; z < 4; ++z) {\n\n            point_on_circle[i].push_back(cir[i].mid + P(zx[z], zy[z]).trunc(cir[i].r));\n\n        }\n\n    }\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        for (int j = i + 1; j < SZ(cir); ++j) {\n\n            P a, b;\n\n            if (circles_intersection(cir[i], cir[j], a, b)) {\n\n                point_on_circle[i].push_back(a);\n\n                point_on_circle[i].push_back(b);\n\n                point_on_circle[j].push_back(a);\n\n                point_on_circle[j].push_back(b);\n\n            }\n\n        }\n\n    }\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        sort(point_on_circle[i].begin(), point_on_circle[i].end(), cmp(cir[i].mid));\n\n        point_on_circle[i].erase(unique(point_on_circle[i].begin(), point_on_circle[i].end()), point_on_circle[i].end());\n\n    }\n\n    double ans = 0;\n\n    for (int i = 0; i < SZ(cir); ++i) {\n\n        for (int j = 0; j < SZ(point_on_circle[i]); ++j) {\n\n            const P &a = point_on_circle[i][j];\n\n            const P &b = point_on_circle[i][NEXT(j + 1, SZ(point_on_circle[i]))];\n\n            if (!cover(cir[i], a, b, cir)) {\n\n                ans += cross(P(0, 0), a, b) / 2;\n\n                ans += cal_area(cir[i], a, b);\n\n            }\n\n        }\n\n    }\n\n    return ans;\n\n}\n\ndouble mabs(double a) {\n\n    return a + eps;\n\n}\n\n\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        int R, G, B;\n\n        scanf(\"%d %d %d\", &R, &G, &B);\n\n        vector<C> r, g, b, rg, rb, gb, rgb;\n\n        for (int i = 0; i < R; ++i) {\n\n            C tmp;\n\n            tmp.input();\n\n            r.push_back(tmp);\n\n            rg.push_back(tmp);\n\n            rb.push_back(tmp);\n\n            rgb.push_back(tmp);\n\n        }\n\n        for (int i = 0; i < G; ++i) {\n\n            C tmp;\n\n            tmp.input();\n\n            g.push_back(tmp);\n\n            rg.push_back(tmp);\n\n            gb.push_back(tmp);\n\n            rgb.push_back(tmp);\n\n        }\n\n        for (int i = 0; i < B; ++i) {\n\n            C tmp;\n\n            tmp.input();\n\n            b.push_back(tmp);\n\n            rb.push_back(tmp);\n\n            gb.push_back(tmp);\n\n            rgb.push_back(tmp);\n\n        }\n\n        double rs = cal_area(r);\n\n        double gs = cal_area(g);\n\n        double bs = cal_area(b);\n\n        double rgs = rs + gs - cal_area(rg);\n\n        double rbs = rs + bs - cal_area(rb);\n\n        double gbs = gs + bs - cal_area(gb);\n\n        double rgbs = cal_area(rgb) - rs - gs - bs + rgs + rbs + gbs;\n\n        printf(\"%.2f %.2f %.2f %.2f %.2f %.2f %.2f\\n\", \n\n                mabs(rs - rgs - rbs + rgbs), \n\n                mabs(gs - rgs - gbs + rgbs),\n\n                mabs(bs - rbs - gbs + rgbs),\n\n                mabs(rgbs),\n\n                mabs(rgs - rgbs),\n\n                mabs(rbs - rgbs),\n\n                mabs(gbs - rgbs));\n\n    }\n\n    return 0;\n\n}\n\n\n\n\n\n'),(217,'/*\n\n * Author: momodi\n\n * Created Time:  2009/9/5 16:57:35\n\n * File Name: Dolphin.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <queue>\n\n#include <algorithm>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\nconst int maxn = 1100;\n\nint n, m, S, T;\n\nint edge[maxn][maxn];\n\nint type[maxn];\n\nint dist[maxn];\n\nvoid build_dist() {\n\n    fill(dist, dist + n, maxint);\n\n    dist[T] = 0;\n\n    queue<int> Q;\n\n    Q.push(T);\n\n    while (!Q.empty()) {\n\n        int v = Q.front();\n\n        Q.pop();\n\n        for (int i = 0; i < n; ++i) {\n\n            if (edge[v][i] < maxint && dist[v] + edge[v][i] < dist[i]) {\n\n                dist[i] = dist[v] + edge[v][i];\n\n                Q.push(i);\n\n            }\n\n        }\n\n    }\n\n}\n\n\n\nint mmin[maxn];\n\nint cc[1010];\n\n\n\nint find_dist(int now) {\n\n    static int Q[1024];\n\n    Q[0] = now;\n\n    static bool hash[maxn];\n\n    fill(hash, hash + n, false);\n\n    hash[now] = true;\n\n    static int dist[maxn];\n\n    fill(dist, dist + n, maxint);\n\n    dist[now] = 0;\n\n    for (int s = 0, t = 1; s != t; ) {\n\n        int v = Q[s];\n\n        hash[v] = false;\n\n        s = (s + 1) & 1023;\n\n        for (int i = 0; i < n; ++i) {\n\n            if (cc[type[i]] == 0 && edge[v][i] < maxint && dist[v] + edge[v][i] < dist[i]) {\n\n                dist[i] = dist[v] + edge[v][i];\n\n                if (hash[i] == false) {\n\n                    hash[i] = true;\n\n                    if (dist[i] <= dist[Q[s]]) {\n\n                        s = (s - 1) & 1023;\n\n                        Q[s] = i;\n\n                    } else {\n\n                        Q[t] = i;\n\n                        t = (t + 1) & 1023;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return dist[T];\n\n}\n\n\n\n\n\nbool dfs(int now, int tot, int lim) {\n\n    if (dist[now] == maxint || dist[now] + tot > lim) {\n\n        return false;\n\n    }\n\n    int tmp = find_dist(now);\n\n    if (tmp == maxint || tmp + tot > lim) {\n\n        return false;\n\n    }\n\n    if (now == T) {\n\n        return true;\n\n    }\n\n    for (int i = 0; i < n; ++i) {\n\n        if (edge[now][i] < maxint && cc[type[i]] == 0) {\n\n            ++cc[type[now]];\n\n            if (dfs(i, tot + edge[now][i], lim)) {\n\n                return true;\n\n            }\n\n            --cc[type[now]];\n\n        }\n\n    }\n\n    return false;\n\n}\n\n\n\nint solve() {\n\n    int s = 0, t = 0;\n\n    for (int i = 0; i < n; ++i) {\n\n        for (int j = i + 1; j < n; ++j) {\n\n            if (edge[i][j] < maxint) {\n\n                t += edge[i][j];\n\n            }\n\n        }\n\n    }\n\n    build_dist();\n\n    int ans = -1;\n\n    while (s <= t) {\n\n        int mid = (s + t) / 2;\n\n        fill(mmin, mmin + n, maxint);\n\n        memset(cc, 0, sizeof(cc));\n\n        ++cc[type[S]];\n\n        if (dfs(S, 0, mid)) {\n\n            ans = mid;\n\n            t = mid - 1;\n\n        } else {\n\n            s = mid + 1;\n\n        }\n\n    }\n\n    return ans;\n\n}\n\n\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d %d %d %d\", &n, &m, &S, &T);\n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < n; ++j) {\n\n                edge[i][j] = maxint;\n\n            }\n\n        }\n\n        for (int i = 0; i < m; ++i) {\n\n            int u, v, c;\n\n            scanf(\"%d %d %d\", &u, &v, &c);\n\n            get_min(edge[u][v], c);\n\n            edge[v][u] = edge[u][v];\n\n        }\n\n        for (int i = 0; i < n; ++i) {\n\n            scanf(\"%d\", type + i);\n\n        }\n\n        printf(\"%d\\n\", solve());\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(218,'/*\n\n * Author: momodi\n\n * Created Time:  2009/9/5 16:57:35\n\n * File Name: Dolphin.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <queue>\n\n#include <algorithm>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\nconst int maxn = 1100;\n\nint n, m, S, T;\n\nint edge[maxn][maxn];\n\nint type[maxn];\n\nint dist[maxn];\n\nvoid build_dist() {\n\n    fill(dist, dist + n, maxint);\n\n    dist[T] = 0;\n\n    queue<int> Q;\n\n    Q.push(T);\n\n    while (!Q.empty()) {\n\n        int v = Q.front();\n\n        Q.pop();\n\n        for (int i = 0; i < n; ++i) {\n\n            if (edge[v][i] < maxint && dist[v] + edge[v][i] < dist[i]) {\n\n                dist[i] = dist[v] + edge[v][i];\n\n                Q.push(i);\n\n            }\n\n        }\n\n    }\n\n}\n\n\n\nint mmin[maxn];\n\nint cc[1010];\n\n\n\nint find_dist(int now) {\n\n    static int Q[1024];\n\n    Q[0] = now;\n\n    static bool hash[maxn];\n\n    fill(hash, hash + n, false);\n\n    hash[now] = true;\n\n    static int dist[maxn];\n\n    fill(dist, dist + n, maxint);\n\n    dist[now] = 0;\n\n    for (int s = 0, t = 1; s != t; ) {\n\n        int v = Q[s];\n\n        hash[v] = false;\n\n        s = (s + 1) & 1023;\n\n        for (int i = 0; i < n; ++i) {\n\n            if (cc[type[i]] == 0 && edge[v][i] < maxint && dist[v] + edge[v][i] < dist[i]) {\n\n                dist[i] = dist[v] + edge[v][i];\n\n                if (hash[i] == false) {\n\n                    hash[i] = true;\n\n                    if (dist[i] <= dist[Q[s]]) {\n\n                        s = (s - 1) & 1023;\n\n                        Q[s] = i;\n\n                    } else {\n\n                        Q[t] = i;\n\n                        t = (t + 1) & 1023;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return dist[T];\n\n}\n\n\n\n\n\nbool dfs(int now, int tot, int lim) {\n\n    if (dist[now] == maxint || dist[now] + tot > lim) {\n\n        return false;\n\n    }\n\n    int tmp = find_dist(now);\n\n    if (tmp == maxint || tmp + tot > lim) {\n\n        return false;\n\n    }\n\n    if (now == T) {\n\n        return true;\n\n    }\n\n    for (int i = 0; i < n; ++i) {\n\n        if (edge[now][i] < maxint && cc[type[i]] == 0) {\n\n            ++cc[type[now]];\n\n            if (dfs(i, tot + edge[now][i], lim)) {\n\n                return true;\n\n            }\n\n            --cc[type[now]];\n\n        }\n\n    }\n\n    return false;\n\n}\n\n\n\nint solve() {\n\n    int s = 0, t = 0;\n\n    for (int i = 0; i < n; ++i) {\n\n        for (int j = i + 1; j < n; ++j) {\n\n            if (edge[i][j] < maxint) {\n\n                t += edge[i][j];\n\n            }\n\n        }\n\n    }\n\n    build_dist();\n\n    int ans = -1;\n\n    while (s <= t) {\n\n        int mid = (s + t) / 2;\n\n        fill(mmin, mmin + n, maxint);\n\n        memset(cc, 0, sizeof(cc));\n\n        ++cc[type[S]];\n\n        if (dfs(S, 0, mid)) {\n\n            ans = mid;\n\n            t = mid - 1;\n\n        } else {\n\n            s = mid + 1;\n\n        }\n\n    }\n\n    return ans;\n\n}\n\n\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d %d %d %d\", &n, &m, &S, &T);\n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < n; ++j) {\n\n                edge[i][j] = maxint;\n\n            }\n\n        }\n\n        for (int i = 0; i < m; ++i) {\n\n            int u, v, c;\n\n            scanf(\"%d %d %d\", &u, &v, &c);\n\n            get_min(edge[u][v], c);\n\n            edge[v][u] = edge[u][v];\n\n        }\n\n        for (int i = 0; i < n; ++i) {\n\n            scanf(\"%d\", type + i);\n\n        }\n\n        printf(\"%d\\n\", solve());\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(219,'/*\n\n * Author: momodi\n\n * Created Time:  2009/9/6 0:42:44\n\n * File Name: FreeOpen.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <set>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define move(v) (1 << (v))\n\n#define take(a, b) (((a) >> (b)) & 1)\n\nconst int maxn = 20;\n\n\n\nstruct Graph {\n\n     int adj[maxn][maxn];\n\n     int n, m;\n\n     int a[maxn], b[maxn];\n\n     int mat[maxn];\n\n     int flag[maxn];\n\n     int match(int _adj[maxn][maxn], int A[maxn][maxn], int B[maxn][maxn], int _n, int _m, int c, int fa, int fb, int fc) {\n\n         n = _n;\n\n         m = _m;\n\n         for (int i = 0; i < n; ++i) {\n\n             for (int j = 0; j < m; ++j) {\n\n                 if (_adj[i][j]) {\n\n                     bool have = false;\n\n                     for (int k = 0; k < c; ++k) {\n\n                         if (A[i][k] && B[j][k] && take(fc, k) == 0) {\n\n                             have = true;\n\n                             break;\n\n                         }\n\n                     }\n\n                     adj[i][j] = have;\n\n                 } else {\n\n                     adj[i][j] = 0;\n\n                 }\n\n             }\n\n         }\n\n         for (int i = 0; i < n; ++i) {\n\n             a[i] = take(fa, i);\n\n         }\n\n         for (int j = 0; j < m; ++j) {\n\n             b[j] = take(fb, j);\n\n         }\n\n         memset(mat, -1, sizeof(mat));\n\n         int ans = 0;\n\n         for (int i = 0; i < n; ++i) {\n\n             if (a[i]) {\n\n                 continue;\n\n             }\n\n             memset(flag, 0, sizeof(flag));\n\n             ans += dfs(i);\n\n         }\n\n         return ans;\n\n     }\n\n     bool dfs(int v) {\n\n         for (int i = 0; i < m; ++i) {\n\n             if (b[i] == 0 && adj[v][i] && flag[i] == false) {\n\n                 flag[i] = true;\n\n                 if (mat[i] == -1 || dfs(mat[i])) {\n\n                     mat[i] = v;\n\n                     return true;\n\n                 }\n\n             }\n\n         }\n\n         return false;\n\n     }\n\n} g;\n\n\n\nint gb[maxn][maxn];\n\nint bg[maxn][maxn];\n\nint gp[maxn][maxn];\n\nint pg[maxn][maxn];\n\nint bp[maxn][maxn];\n\nint pb[maxn][maxn];\n\nint G, B, P;\n\nint min(int a, int b, int c) {\n\n    return min(min(a, b), c);\n\n}\n\nint cnt[move(maxn)];\n\n\n\nbool dfs(int now, int fa, int fb, int ans) {\n\n    if (cnt[fa] == ans) {\n\n        return true;\n\n    }\n\n    if (cnt[now] == G) {\n\n        return false;\n\n    }\n\n    if (cnt[fa] + g.match(gb, gp, bp, G, B, P, now, fa, fb) < ans || \n\n            cnt[fa] + g.match(gp, gb, pb, G, P, B, now, fb, fa) < ans ||\n\n            cnt[fa] + g.match(bp, bg, pg, B, P, G, fa, fb, now) < ans) {\n\n        return false;\n\n    }\n\n    int v = cnt[now];\n\n    for (int i = 0; i < B; ++i) {\n\n        if (gb[v][i] && take(fa, i) == 0) {\n\n            for (int j = 0; j < P; ++j) {\n\n                if (gp[v][j] && bp[i][j] && take(fb, j) == 0) {\n\n                    if (dfs(now | move(v), fa | move(i), fb | move(j), ans)) {\n\n                        return true;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    if (dfs(now | move(v), fa, fb, ans)) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n\n\n\nint solve() {\n\n    int mmaxans = min(g.match(gb, gp, bp, G, B, P, 0, 0, 0), g.match(gp, gb, pb, G, P, B, 0, 0, 0), g.match(bp, bg, pg, B, P, G, 0, 0, 0));\n\n    int ans = 1;\n\n    while (ans <= mmaxans) {\n\n        if (!dfs(0, 0, 0, ans)) {\n\n            break;\n\n        }\n\n        ++ans;\n\n    }\n\n    return ans - 1;\n\n}\n\n\n\nvoid mysort(int ab[maxn][maxn], int ac[maxn][maxn], int ba[maxn][maxn], int ca[maxn][maxn], int A, int B, int C) {\n\n    int degab[maxn] = {};\n\n    int degac[maxn] = {};\n\n    int deg[maxn];\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < B; ++j) {\n\n            degab[i] += ab[i][j];\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < C; ++j) {\n\n            degac[i] += ac[i][j];\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        deg[i] = min(degab[i], degac[i]);\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = i + 1; j < A; ++j) {\n\n            if (deg[j] < deg[i]) {\n\n                swap(deg[i], deg[j]);\n\n                for (int k = 0; k < B; ++k) {\n\n                    swap(ab[i][k], ab[j][k]);\n\n                }\n\n                for (int k = 0; k < C; ++k) {\n\n                    swap(ac[i][k], ac[j][k]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < B; ++j) {\n\n            ba[j][i] = ab[i][j];\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < C; ++j) {\n\n            ca[j][i] = ac[i][j];\n\n        }\n\n    }\n\n}\n\n\n\nint main() {\n\n    for (int i = 0; i < move(maxn); ++i) {\n\n        int k = i;\n\n        while (k) {\n\n            cnt[i] += k & 1;\n\n            k >>= 1;\n\n        }\n\n    }\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d %d %d\", &G, &B, &P);\n\n        for (int i = 0; i < G; ++i) {\n\n            for (int j = 0; j < B; ++j) {\n\n                scanf(\"%d\", gb[i] + j);\n\n                bg[j][i] = gb[i][j];\n\n            }\n\n        }\n\n        for (int i = 0; i < G; ++i) {\n\n            for (int j = 0; j < P; ++j) {\n\n                scanf(\"%d\", gp[i] + j);\n\n                pg[j][i] = gp[i][j];\n\n            }\n\n        }\n\n        for (int i = 0; i < B; ++i) {\n\n            for (int j = 0; j < P; ++j) {\n\n                scanf(\"%d\", bp[i] + j);\n\n                pb[j][i] = bp[i][j];\n\n            }\n\n        }\n\n        mysort(gb, gp, bg, pg, G, B, P);\n\n        mysort(bp, bg, pb, gb, B, P, G);\n\n        mysort(pg, pb, gp, bp, P, G, B);\n\n        printf(\"%d\\n\", solve());\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(220,'/*\n\n * Author: momodi\n\n * Created Time:  2009/9/6 0:42:44\n\n * File Name: FreeOpen.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <set>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define move(v) (1 << (v))\n\n#define take(a, b) (((a) >> (b)) & 1)\n\nconst int maxn = 20;\n\n\n\nstruct Graph {\n\n     int adj[maxn][maxn];\n\n     int n, m;\n\n     int a[maxn], b[maxn];\n\n     int mat[maxn];\n\n     int flag[maxn];\n\n     int match(int _adj[maxn][maxn], int A[maxn][maxn], int B[maxn][maxn], int _n, int _m, int c, int fa, int fb, int fc) {\n\n         n = _n;\n\n         m = _m;\n\n         for (int i = 0; i < n; ++i) {\n\n             for (int j = 0; j < m; ++j) {\n\n                 if (_adj[i][j]) {\n\n                     bool have = false;\n\n                     for (int k = 0; k < c; ++k) {\n\n                         if (A[i][k] && B[j][k] && take(fc, k) == 0) {\n\n                             have = true;\n\n                             break;\n\n                         }\n\n                     }\n\n                     adj[i][j] = have;\n\n                 } else {\n\n                     adj[i][j] = 0;\n\n                 }\n\n             }\n\n         }\n\n         for (int i = 0; i < n; ++i) {\n\n             a[i] = take(fa, i);\n\n         }\n\n         for (int j = 0; j < m; ++j) {\n\n             b[j] = take(fb, j);\n\n         }\n\n         memset(mat, -1, sizeof(mat));\n\n         int ans = 0;\n\n         for (int i = 0; i < n; ++i) {\n\n             if (a[i]) {\n\n                 continue;\n\n             }\n\n             memset(flag, 0, sizeof(flag));\n\n             ans += dfs(i);\n\n         }\n\n         return ans;\n\n     }\n\n     bool dfs(int v) {\n\n         for (int i = 0; i < m; ++i) {\n\n             if (b[i] == 0 && adj[v][i] && flag[i] == false) {\n\n                 flag[i] = true;\n\n                 if (mat[i] == -1 || dfs(mat[i])) {\n\n                     mat[i] = v;\n\n                     return true;\n\n                 }\n\n             }\n\n         }\n\n         return false;\n\n     }\n\n} g;\n\n\n\nint gb[maxn][maxn];\n\nint bg[maxn][maxn];\n\nint gp[maxn][maxn];\n\nint pg[maxn][maxn];\n\nint bp[maxn][maxn];\n\nint pb[maxn][maxn];\n\nint G, B, P;\n\nint min(int a, int b, int c) {\n\n    return min(min(a, b), c);\n\n}\n\nint cnt[move(maxn)];\n\n\n\nbool dfs(int now, int fa, int fb, int ans) {\n\n    if (cnt[fa] == ans) {\n\n        return true;\n\n    }\n\n    if (cnt[now] == G) {\n\n        return false;\n\n    }\n\n    if (cnt[fa] + g.match(gb, gp, bp, G, B, P, now, fa, fb) < ans || \n\n            cnt[fa] + g.match(gp, gb, pb, G, P, B, now, fb, fa) < ans ||\n\n            cnt[fa] + g.match(bp, bg, pg, B, P, G, fa, fb, now) < ans) {\n\n        return false;\n\n    }\n\n    int v = cnt[now];\n\n    for (int i = 0; i < B; ++i) {\n\n        if (gb[v][i] && take(fa, i) == 0) {\n\n            for (int j = 0; j < P; ++j) {\n\n                if (gp[v][j] && bp[i][j] && take(fb, j) == 0) {\n\n                    if (dfs(now | move(v), fa | move(i), fb | move(j), ans)) {\n\n                        return true;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    if (dfs(now | move(v), fa, fb, ans)) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n\n\n\nint solve() {\n\n    int mmaxans = min(g.match(gb, gp, bp, G, B, P, 0, 0, 0), g.match(gp, gb, pb, G, P, B, 0, 0, 0), g.match(bp, bg, pg, B, P, G, 0, 0, 0));\n\n    int ans = 1;\n\n    while (ans <= mmaxans) {\n\n        if (!dfs(0, 0, 0, ans)) {\n\n            break;\n\n        }\n\n        ++ans;\n\n    }\n\n    return ans - 1;\n\n}\n\n\n\nvoid mysort(int ab[maxn][maxn], int ac[maxn][maxn], int ba[maxn][maxn], int ca[maxn][maxn], int A, int B, int C) {\n\n    int degab[maxn] = {};\n\n    int degac[maxn] = {};\n\n    int deg[maxn];\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < B; ++j) {\n\n            degab[i] += ab[i][j];\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < C; ++j) {\n\n            degac[i] += ac[i][j];\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        deg[i] = min(degab[i], degac[i]);\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = i + 1; j < A; ++j) {\n\n            if (deg[j] < deg[i]) {\n\n                swap(deg[i], deg[j]);\n\n                for (int k = 0; k < B; ++k) {\n\n                    swap(ab[i][k], ab[j][k]);\n\n                }\n\n                for (int k = 0; k < C; ++k) {\n\n                    swap(ac[i][k], ac[j][k]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < B; ++j) {\n\n            ba[j][i] = ab[i][j];\n\n        }\n\n    }\n\n    for (int i = 0; i < A; ++i) {\n\n        for (int j = 0; j < C; ++j) {\n\n            ca[j][i] = ac[i][j];\n\n        }\n\n    }\n\n}\n\n\n\nint main() {\n\n    for (int i = 0; i < move(maxn); ++i) {\n\n        int k = i;\n\n        while (k) {\n\n            cnt[i] += k & 1;\n\n            k >>= 1;\n\n        }\n\n    }\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d %d %d\", &G, &B, &P);\n\n        for (int i = 0; i < G; ++i) {\n\n            for (int j = 0; j < B; ++j) {\n\n                scanf(\"%d\", gb[i] + j);\n\n                bg[j][i] = gb[i][j];\n\n            }\n\n        }\n\n        for (int i = 0; i < G; ++i) {\n\n            for (int j = 0; j < P; ++j) {\n\n                scanf(\"%d\", gp[i] + j);\n\n                pg[j][i] = gp[i][j];\n\n            }\n\n        }\n\n        for (int i = 0; i < B; ++i) {\n\n            for (int j = 0; j < P; ++j) {\n\n                scanf(\"%d\", bp[i] + j);\n\n                pb[j][i] = bp[i][j];\n\n            }\n\n        }\n\n        mysort(gb, gp, bg, pg, G, B, P);\n\n        mysort(bp, bg, pb, gb, B, P, G);\n\n        mysort(pg, pb, gp, bp, P, G, B);\n\n        printf(\"%d\\n\", solve());\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(221,'/**\n\n * File Name: FreeRadiant.cpp\n\n * Created Time:  9/7/2009 3:57:55 PM\n\n * Author: momodi\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <vector>\n\nusing namespace std;\n\n#define NEXT(v, n) (((v) == (n))? 0 : (v))\n\n#define SZ(x) ((int) x.size())\n\n#define out(v) printf(\"%s: %lld\", #v, (long long)v)\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((v) * (v))\n\nconst int maxint = -1u>>1;\n\nconst double eps = 1e-6;\n\nint sgn(const double &a) {\n\n    return (a > eps) - (a < -eps);\n\n}\n\nstruct P {\n\n    double x, y;\n\n    P(double _x, double _y)\n\n        :x(_x), y(_y) {}\n\n    P() {}\n\n    bool operator == (const P &a) const {\n\n        return sgn(x - a.x) == 0 && sgn(y - a.y) == 0;\n\n    }\n\n    bool operator != (const P &a) const {\n\n        return sgn(x - a.x) != 0 || sgn(y - a.y) != 0;\n\n    }\n\n    bool operator < (const P &a) const {\n\n        return sgn(x - a.x) < 0 || sgn(x - a.x) == 0 && sgn(y - a.y) < 0;\n\n    }\n\n    P operator + (const P &a) const {\n\n        return P(x + a.x, y + a.y);\n\n    }\n\n    P operator - (const P &a) const {\n\n        return P(x - a.x, y - a.y);\n\n    }\n\n    P operator * (const double &a) const {\n\n        return P(x * a, y * a);\n\n    }\n\n    P operator / (const double &a) const {\n\n        return P(x / a, y / a);\n\n    }\n\n    P turn_left() const {\n\n        return P(-y, x);\n\n    }\n\n    P trunc(double a) const {\n\n        a /= sqrt(SQR(x) + SQR(y));\n\n        return P(x * a, y * a);\n\n    }\n\n    void input() {\n\n        scanf(\"%lf %lf\", &x, &y);\n\n    }\n\n    void output() const {\n\n        printf(\"%lf %lf\\n\", x, y);\n\n    }\n\n};\n\ndouble dist(const P &a, const P &b) {\n\n    return sqrt(SQR(a.x - b.x) + SQR(a.y - b.y));\n\n}\n\n\n\nstruct Simplex {\n\n    static const int maxn = 2500 + 100;\n\n    double A[maxn][maxn], b[maxn], c[maxn], v;\n\n    int Nsets[maxn], Bsets[maxn], Nsize, Bsize;\n\n    void clear(int n, int m, int *T) {\n\n        Nsize = n, Bsize = m;\n\n        memset(c, 0, sizeof(c));\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            c[i] = -1;\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            b[Nsize + i] = -T[i];\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            Bsets[i] = Nsize + i;\n\n        }\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            Nsets[i] = i;\n\n        }\n\n        v = 0;\n\n        memset(A, 0, sizeof(A));\n\n    }\n\n    void insert(int u, int v, double c) {\n\n        A[u + Nsize][v] = c;\n\n    }\n\n    void del() {\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            if (Bsets[i] == Nsize + Bsize - 1) {\n\n                pivot(Nsize + Bsize - 1, Nsets[0]);\n\n            }\n\n        }\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            if (Nsets[i] == Nsize + Bsize - 1) {\n\n                Nsets[i] = Nsets[--Nsize];\n\n                return ;\n\n            }\n\n        }\n\n        while (1);\n\n    }\n\n    void init() {\n\n        int l = Bsets[0];\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            if (b[Bsets[i]] < b[l]) {\n\n                l = Bsets[i];\n\n            }\n\n        }\n\n        if (sgn(b[l]) >= 0) {\n\n            return ;\n\n        }\n\n        double remc[maxn];\n\n        copy(c, c + Nsize + Bsize + 1, remc);\n\n        Nsets[Nsize] = Nsize + Bsize;\n\n        ++Nsize;\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            A[Bsets[i]][Nsize + Bsize - 1] = -1;\n\n        }\n\n        memset(c, 0, sizeof(c));\n\n        c[Nsize + Bsize - 1] = -1;\n\n        pivot(l, Nsize + Bsize - 1);\n\n        if (sgn(optimize()) < 0) {\n\n            printf(\"error: nosolution\\n\");\n\n            return ;\n\n        }\n\n        del();\n\n        copy(remc, remc + Nsize + Bsize + 1, c);\n\n        for (int a = 0; a < Bsize; ++a) {\n\n            int i = Bsets[a];\n\n            if (sgn(c[i]) != 0) {\n\n                v += c[i] * b[i];\n\n                for (int j = 0; j < Nsize; ++j) {\n\n                    c[Nsets[j]] -= A[i][Nsets[j]] * c[i];\n\n                }\n\n                c[i] = 0;\n\n            }\n\n        }\n\n    }\n\n    double find() {\n\n        init();\n\n        optimize();\n\n        return v;\n\n    }\n\n    double optimize() {\n\n        while (1) {\n\n            int l, e;\n\n            double mmax = -1;\n\n            for (int i = 0; i < Nsize; ++i) {\n\n                int tmpe = Nsets[i];\n\n                if (sgn(c[tmpe]) <= 0) {\n\n                    continue;\n\n                }\n\n                int tmpl = maxint;\n\n                double mmin = 1e100;\n\n                for (int i = 0; i < Bsize; ++i) {\n\n                    int u = Bsets[i];\n\n                    if (sgn(A[u][tmpe]) > 0 && (b[u] / A[u][tmpe] < mmin || sgn(b[u] / A[u][tmpe] - mmin) == 0 && u < tmpl)) {\n\n                        mmin = b[u] / A[u][tmpe];\n\n                        tmpl = u;\n\n                    }\n\n                }\n\n                if (tmpl == maxint) {\n\n                    return mmin;\n\n                }\n\n                if (mmin * c[tmpe] > mmax) {\n\n                    mmax = mmin * c[tmpe];\n\n                    l = tmpl;\n\n                    e = tmpe;\n\n                }\n\n            }\n\n            if (mmax == -1) {\n\n                return v;\n\n            }\n\n            pivot(l, e);\n\n        }\n\n    }\n\n    void pivot(int l, int e) {\n\n        b[e] = b[l] / A[l][e];\n\n        A[e][l] = 1 / A[l][e];\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            int u = Nsets[i];\n\n            if (u != e) {\n\n                A[e][u] = A[l][u] / A[l][e];\n\n            }\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            int u = Bsets[i];\n\n            if (u != l) {\n\n                b[u] -= A[u][e] * b[e];\n\n                A[u][l] = -A[u][e] * A[e][l];\n\n                for (int j = 0; j < Nsize; ++j) {\n\n                    int v = Nsets[j];\n\n                    if (v != e) {\n\n                        A[u][v] -= A[u][e] * A[e][v];\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        v += b[e] * c[e];\n\n        c[l] = -A[e][l] * c[e];\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            int u = Nsets[i];\n\n            if (u != e) {\n\n                c[u] -= c[e] * A[e][u];\n\n            }\n\n        }\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            if (Nsets[i] == e) {\n\n                Nsets[i] = l;\n\n                break;\n\n            }\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            if (Bsets[i] == l) {\n\n                Bsets[i] = e;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n} simplex;\n\nstruct Graph {\n\n    static const int maxn = 100 * 100;\n\n    static const int maxm = 100;\n\n    int n, m;\n\n    int adj[maxn][maxm];\n\n    void init() {\n\n        n = m = 0;\n\n        memset(adj, 0, sizeof(adj));\n\n    }\n\n    void insert(int u, int v) {\n\n        get_max(n, u + 1);\n\n        get_max(m, v + 1);\n\n        adj[u][v] = 1;\n\n    }\n\n    double find_ans(int *T) {\n\n        simplex.clear(n, m, T);\n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < m; ++j) {\n\n                if (adj[i][j]) {\n\n                    simplex.insert(j, i, -1);\n\n                }\n\n            }\n\n        }\n\n        double ans = simplex.find() * -1;\n\n        return ans;\n\n    }\n\n};\n\nGraph g;\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        int n, r;\n\n        scanf(\"%d %d\", &n, &r);\n\n        P dt[n];\n\n        int T[n];\n\n        for (int i = 0; i < n; ++i) {\n\n            dt[i].input();\n\n            scanf(\"%d\", T + i);\n\n        }\n\n        vector<P> cir;\n\n        bool visited[n];\n\n        for (int i = 0; i < n; ++i) {\n\n            visited[i] = false;\n\n        }\n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < n; ++j) {\n\n                if (dt[i] != dt[j]) {\n\n                    double d = dist(dt[i], dt[j]);\n\n                    if (sgn(d - r * 2) == 0) {\n\n                        cir.push_back((dt[i] + dt[j]) / 2);\n\n                        visited[i] = visited[j] = true;\n\n                    } else if (sgn(d - r * 2) < 0) {\n\n                        cir.push_back((dt[i] + dt[j]) / 2 + (dt[j] - dt[i]).turn_left().trunc(sqrt(SQR(r) - SQR(d / 2))));\n\n                        visited[i] = visited[j] = true;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        sort(cir.begin(), cir.end());\n\n        cir.erase(unique(cir.begin(), cir.end()), cir.end());\n\n        g.init();\n\n        double ans = 0;\n\n        for (int i = 0; i < n; ++i) {\n\n            if (visited[i] == false) {\n\n                ans += T[i];\n\n                T[i] = -116;\n\n            }\n\n        }\n\n        for (int i = 0; i < SZ(cir); ++i) {\n\n            for (int j = 0; j < n; ++j) {\n\n                if (sgn(dist(cir[i], dt[j]) - r) <= 0) {\n\n                    g.insert(i, j);\n\n                }\n\n            }\n\n        }\n\n        printf(\"%.2lf\\n\", ans + g.find_ans(T));\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(222,'/**\n\n * File Name: FreeRadiant.cpp\n\n * Created Time:  9/7/2009 3:57:55 PM\n\n * Author: momodi\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <vector>\n\nusing namespace std;\n\n#define NEXT(v, n) (((v) == (n))? 0 : (v))\n\n#define SZ(x) ((int) x.size())\n\n#define out(v) printf(\"%s: %lld\", #v, (long long)v)\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((v) * (v))\n\nconst int maxint = -1u>>1;\n\nconst double eps = 1e-6;\n\nint sgn(const double &a) {\n\n    return (a > eps) - (a < -eps);\n\n}\n\nstruct P {\n\n    double x, y;\n\n    P(double _x, double _y)\n\n        :x(_x), y(_y) {}\n\n    P() {}\n\n    bool operator == (const P &a) const {\n\n        return sgn(x - a.x) == 0 && sgn(y - a.y) == 0;\n\n    }\n\n    bool operator != (const P &a) const {\n\n        return sgn(x - a.x) != 0 || sgn(y - a.y) != 0;\n\n    }\n\n    bool operator < (const P &a) const {\n\n        return sgn(x - a.x) < 0 || sgn(x - a.x) == 0 && sgn(y - a.y) < 0;\n\n    }\n\n    P operator + (const P &a) const {\n\n        return P(x + a.x, y + a.y);\n\n    }\n\n    P operator - (const P &a) const {\n\n        return P(x - a.x, y - a.y);\n\n    }\n\n    P operator * (const double &a) const {\n\n        return P(x * a, y * a);\n\n    }\n\n    P operator / (const double &a) const {\n\n        return P(x / a, y / a);\n\n    }\n\n    P turn_left() const {\n\n        return P(-y, x);\n\n    }\n\n    P trunc(double a) const {\n\n        a /= sqrt(SQR(x) + SQR(y));\n\n        return P(x * a, y * a);\n\n    }\n\n    void input() {\n\n        scanf(\"%lf %lf\", &x, &y);\n\n    }\n\n    void output() const {\n\n        printf(\"%lf %lf\\n\", x, y);\n\n    }\n\n};\n\ndouble dist(const P &a, const P &b) {\n\n    return sqrt(SQR(a.x - b.x) + SQR(a.y - b.y));\n\n}\n\n\n\nstruct Simplex {\n\n    static const int maxn = 2500 + 100;\n\n    double A[maxn][maxn], b[maxn], c[maxn], v;\n\n    int Nsets[maxn], Bsets[maxn], Nsize, Bsize;\n\n    void clear(int n, int m, int *T) {\n\n        Nsize = n, Bsize = m;\n\n        memset(c, 0, sizeof(c));\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            c[i] = -1;\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            b[Nsize + i] = -T[i];\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            Bsets[i] = Nsize + i;\n\n        }\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            Nsets[i] = i;\n\n        }\n\n        v = 0;\n\n        memset(A, 0, sizeof(A));\n\n    }\n\n    void insert(int u, int v, double c) {\n\n        A[u + Nsize][v] = c;\n\n    }\n\n    void del() {\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            if (Bsets[i] == Nsize + Bsize - 1) {\n\n                pivot(Nsize + Bsize - 1, Nsets[0]);\n\n            }\n\n        }\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            if (Nsets[i] == Nsize + Bsize - 1) {\n\n                Nsets[i] = Nsets[--Nsize];\n\n                return ;\n\n            }\n\n        }\n\n        while (1);\n\n    }\n\n    void init() {\n\n        int l = Bsets[0];\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            if (b[Bsets[i]] < b[l]) {\n\n                l = Bsets[i];\n\n            }\n\n        }\n\n        if (sgn(b[l]) >= 0) {\n\n            return ;\n\n        }\n\n        double remc[maxn];\n\n        copy(c, c + Nsize + Bsize + 1, remc);\n\n        Nsets[Nsize] = Nsize + Bsize;\n\n        ++Nsize;\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            A[Bsets[i]][Nsize + Bsize - 1] = -1;\n\n        }\n\n        memset(c, 0, sizeof(c));\n\n        c[Nsize + Bsize - 1] = -1;\n\n        pivot(l, Nsize + Bsize - 1);\n\n        if (sgn(optimize()) < 0) {\n\n            printf(\"error: nosolution\\n\");\n\n            return ;\n\n        }\n\n        del();\n\n        copy(remc, remc + Nsize + Bsize + 1, c);\n\n        for (int a = 0; a < Bsize; ++a) {\n\n            int i = Bsets[a];\n\n            if (sgn(c[i]) != 0) {\n\n                v += c[i] * b[i];\n\n                for (int j = 0; j < Nsize; ++j) {\n\n                    c[Nsets[j]] -= A[i][Nsets[j]] * c[i];\n\n                }\n\n                c[i] = 0;\n\n            }\n\n        }\n\n    }\n\n    double find() {\n\n        init();\n\n        optimize();\n\n        return v;\n\n    }\n\n    double optimize() {\n\n        while (1) {\n\n            int l, e;\n\n            double mmax = -1;\n\n            for (int i = 0; i < Nsize; ++i) {\n\n                int tmpe = Nsets[i];\n\n                if (sgn(c[tmpe]) <= 0) {\n\n                    continue;\n\n                }\n\n                int tmpl = maxint;\n\n                double mmin = 1e100;\n\n                for (int i = 0; i < Bsize; ++i) {\n\n                    int u = Bsets[i];\n\n                    if (sgn(A[u][tmpe]) > 0 && (b[u] / A[u][tmpe] < mmin || sgn(b[u] / A[u][tmpe] - mmin) == 0 && u < tmpl)) {\n\n                        mmin = b[u] / A[u][tmpe];\n\n                        tmpl = u;\n\n                    }\n\n                }\n\n                if (tmpl == maxint) {\n\n                    return mmin;\n\n                }\n\n                if (mmin * c[tmpe] > mmax) {\n\n                    mmax = mmin * c[tmpe];\n\n                    l = tmpl;\n\n                    e = tmpe;\n\n                }\n\n            }\n\n            if (mmax == -1) {\n\n                return v;\n\n            }\n\n            pivot(l, e);\n\n        }\n\n    }\n\n    void pivot(int l, int e) {\n\n        b[e] = b[l] / A[l][e];\n\n        A[e][l] = 1 / A[l][e];\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            int u = Nsets[i];\n\n            if (u != e) {\n\n                A[e][u] = A[l][u] / A[l][e];\n\n            }\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            int u = Bsets[i];\n\n            if (u != l) {\n\n                b[u] -= A[u][e] * b[e];\n\n                A[u][l] = -A[u][e] * A[e][l];\n\n                for (int j = 0; j < Nsize; ++j) {\n\n                    int v = Nsets[j];\n\n                    if (v != e) {\n\n                        A[u][v] -= A[u][e] * A[e][v];\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        v += b[e] * c[e];\n\n        c[l] = -A[e][l] * c[e];\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            int u = Nsets[i];\n\n            if (u != e) {\n\n                c[u] -= c[e] * A[e][u];\n\n            }\n\n        }\n\n        for (int i = 0; i < Nsize; ++i) {\n\n            if (Nsets[i] == e) {\n\n                Nsets[i] = l;\n\n                break;\n\n            }\n\n        }\n\n        for (int i = 0; i < Bsize; ++i) {\n\n            if (Bsets[i] == l) {\n\n                Bsets[i] = e;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n} simplex;\n\nstruct Graph {\n\n    static const int maxn = 100 * 100;\n\n    static const int maxm = 100;\n\n    int n, m;\n\n    int adj[maxn][maxm];\n\n    void init() {\n\n        n = m = 0;\n\n        memset(adj, 0, sizeof(adj));\n\n    }\n\n    void insert(int u, int v) {\n\n        get_max(n, u + 1);\n\n        get_max(m, v + 1);\n\n        adj[u][v] = 1;\n\n    }\n\n    double find_ans(int *T) {\n\n        simplex.clear(n, m, T);\n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < m; ++j) {\n\n                if (adj[i][j]) {\n\n                    simplex.insert(j, i, -1);\n\n                }\n\n            }\n\n        }\n\n        double ans = simplex.find() * -1;\n\n        return ans;\n\n    }\n\n};\n\nGraph g;\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        int n, r;\n\n        scanf(\"%d %d\", &n, &r);\n\n        P dt[n];\n\n        int T[n];\n\n        for (int i = 0; i < n; ++i) {\n\n            dt[i].input();\n\n            scanf(\"%d\", T + i);\n\n        }\n\n        vector<P> cir;\n\n        bool visited[n];\n\n        for (int i = 0; i < n; ++i) {\n\n            visited[i] = false;\n\n        }\n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < n; ++j) {\n\n                if (dt[i] != dt[j]) {\n\n                    double d = dist(dt[i], dt[j]);\n\n                    if (sgn(d - r * 2) == 0) {\n\n                        cir.push_back((dt[i] + dt[j]) / 2);\n\n                        visited[i] = visited[j] = true;\n\n                    } else if (sgn(d - r * 2) < 0) {\n\n                        cir.push_back((dt[i] + dt[j]) / 2 + (dt[j] - dt[i]).turn_left().trunc(sqrt(SQR(r) - SQR(d / 2))));\n\n                        visited[i] = visited[j] = true;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        sort(cir.begin(), cir.end());\n\n        cir.erase(unique(cir.begin(), cir.end()), cir.end());\n\n        g.init();\n\n        double ans = 0;\n\n        for (int i = 0; i < n; ++i) {\n\n            if (visited[i] == false) {\n\n                ans += T[i];\n\n                T[i] = -116;\n\n            }\n\n        }\n\n        for (int i = 0; i < SZ(cir); ++i) {\n\n            for (int j = 0; j < n; ++j) {\n\n                if (sgn(dist(cir[i], dt[j]) - r) <= 0) {\n\n                    g.insert(i, j);\n\n                }\n\n            }\n\n        }\n\n        printf(\"%.2lf\\n\", ans + g.find_ans(T));\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(223,'#include <iostream> \r\n#include <cstdio> \r\n#include <cstring> \r\n  \r\nusing namespace std; \r\nint solve(int a, int b) \r\n{ \r\n    if(b==1) return 0; \r\n    if(a==0) return 1; \r\n    int now=1,ans=1; \r\n    for(int i=1; i<=a; ++i) \r\n    { \r\n        now=(long long)now*i%b; \r\n        ans=(ans+now)%b; \r\n    } \r\n    return ans; \r\n} \r\nint main() \r\n{ \r\n    //freopen(\"in.txt\",\"r\",stdin); \r\n    int T; \r\n    scanf(\"%d\",&T); \r\n    while(T--) \r\n    { \r\n        char s[110]; \r\n        int m; \r\n        scanf(\"%s %d\",s,&m); \r\n        int a; \r\n        if(strlen(s)>6) \r\n            a=m-1; \r\n        else\r\n            sscanf(s,\"%d\",&a); \r\n        printf(\"%d\\n\",solve(a,m)); \r\n    } \r\n    return 0; \r\n}'),(224,'#include<iostream>\r\n#include<string>\r\n#include<cstdlib>\r\nusing namespace std;\r\nint main()\r\n{\r\nint sum=1;\r\nlong long a=1;\r\nint x,m;\r\nstring x1,m1;\r\nint n;\r\ncin>>n;\r\nwhile(n--)\r\n{\r\nsum=1;a=1;\r\ncin>>x1>>m1;\r\nm=atoi(m1.c_str());\r\nif(x1.length()>m1.length())\r\nx=m-1;\r\nelse\r\nx=atoi(x1.c_str());\r\nif(x>=m) x=m-1;\r\nif(m>1)\r\n{for(int i=1;i<=x;i++)\r\n{\r\na=(a*i)%m;\r\nsum=(sum+a)%m;\r\n}\r\ncout<<sum<<endl;\r\n}\r\nelse cout<<0<<endl;\r\n}\r\n}'),(225,'/*\n\n * Author: momodi\n\n * Created Time:  2009/6/30 21:16:48\n\n * File Name: circle.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <set>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((double)(v) * (v))\n\nconst int maxn = 101000;\n\nconst double eps = 1e-10;\n\nint sgn(double a) {\n\n    return (a > eps) - (a < -eps);\n\n}\n\nint n;\n\nint X[maxn], Y[maxn], R[maxn];\n\nint LL[maxn], RR[maxn];\n\nint num[maxn];\n\nset<int> tree;\n\nint tmp[maxn];\n\ndouble mid;\n\nbool collid(int a, int b) {\n\n    a = tmp[a];\n\n    b = tmp[b];\n\n    if (SQR(X[a] - X[b]) + SQR(Y[a] - Y[b]) - SQR(R[a] + R[b] + mid + mid) <= 0) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n\nbool insert(int v) {\n\n    set<int>::iterator it = tree.insert(v).first;\n\n    if (it != tree.begin()) {\n\n        if (collid(v, *--it)) {\n\n            return false;\n\n        }\n\n        ++it;\n\n    }\n\n    if (++it != tree.end()) {\n\n        if (collid(v, *it)) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n\nbool remove(int v) {\n\n    set<int>::iterator it = tree.find(v);\n\n    if (it == tree.end()) {\n\n        printf(\"error\\n\");\n\n    }\n\n    if (it != tree.begin() && it != --tree.end()) {\n\n        int a = *--it;\n\n        ++it;\n\n        int b = *++it;\n\n        if (collid(a, b)) {\n\n            return false;\n\n        }\n\n    }\n\n    tree.erase(v);\n\n    return true;\n\n}\n\n\n\nbool ok(double mid) {\n\n    ::mid = mid;\n\n    tree.clear();\n\n    int l = 0, r = 0;\n\n    while (l < n || r < n) {\n\n        if (l == n) {\n\n            if (!remove(num[RR[r++]])) {\n\n                return false;\n\n            }\n\n        } else if (r == n) {\n\n            if (!insert(num[LL[l++]])) {\n\n                return false;\n\n            }\n\n        } else if (sgn(X[LL[l]] - R[LL[l]] - mid - X[RR[r]] - R[RR[r]] - mid) <= 0){\n\n            if (!insert(num[LL[l++]])) {\n\n                return false;\n\n            }\n\n        } else {\n\n            if (!remove(num[RR[r++]])) {\n\n                return false;\n\n            }\n\n        }\n\n    }\n\n    return true;\n\n}\n\nbool cmpy(int a, int b) {\n\n    if (Y[a] == Y[b]) {\n\n        return X[a] < X[b];\n\n    }\n\n    return Y[a] < Y[b];\n\n}\n\nbool cmpl(int a, int b) {\n\n    return X[a] - R[a] < X[b] - R[b];\n\n}\n\nbool cmpr(int a, int b) {\n\n    return X[a] + R[a] < X[b] + R[b];\n\n}\n\ndouble solve() {\n\n    for (int i = 0; i < n; ++i) {\n\n        tmp[i] = LL[i] = RR[i] = i;\n\n    }\n\n    sort(tmp, tmp + n, cmpy);\n\n    for (int i = 0; i < n; ++i) {\n\n        num[tmp[i]] = i;\n\n    }\n\n    sort(LL, LL + n, cmpl);\n\n    sort(RR, RR + n, cmpr);\n\n    double s = 0, t = SQR(sqrt(SQR(X[0] - X[1]) + SQR(Y[0] - Y[1])) - R[0] - R[1]);\n\n    while (t - s > 1e-8) {\n\n        double mid = (s + t) / 2;\n\n        if (ok(mid)) {\n\n            s = mid;\n\n        } else {\n\n            t = mid;\n\n        }\n\n    }\n\n    return s + t;\n\n}\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d\", &n);\n\n        for (int i = 0; i < n; ++i) {\n\n            scanf(\"%d %d %d\", X + i, Y + i, R + i);\n\n        }\n\n        printf(\"%.6lf\\n\", solve());\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(226,'/*\n\n * Author: momodi\n\n * Created Time:  2009/6/30 21:16:48\n\n * File Name: circle.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <algorithm>\n\n#include <set>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((double)(v) * (v))\n\nconst int maxn = 101000;\n\nconst double eps = 1e-10;\n\nint sgn(double a) {\n\n    return (a > eps) - (a < -eps);\n\n}\n\nint n;\n\nint X[maxn], Y[maxn], R[maxn];\n\nint LL[maxn], RR[maxn];\n\nint num[maxn];\n\nset<int> tree;\n\nint tmp[maxn];\n\ndouble mid;\n\nbool collid(int a, int b) {\n\n    a = tmp[a];\n\n    b = tmp[b];\n\n    if (SQR(X[a] - X[b]) + SQR(Y[a] - Y[b]) - SQR(R[a] + R[b] + mid + mid) <= 0) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n\nbool insert(int v) {\n\n    set<int>::iterator it = tree.insert(v).first;\n\n    if (it != tree.begin()) {\n\n        if (collid(v, *--it)) {\n\n            return false;\n\n        }\n\n        ++it;\n\n    }\n\n    if (++it != tree.end()) {\n\n        if (collid(v, *it)) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n\nbool remove(int v) {\n\n    set<int>::iterator it = tree.find(v);\n\n    if (it == tree.end()) {\n\n        printf(\"error\\n\");\n\n    }\n\n    if (it != tree.begin() && it != --tree.end()) {\n\n        int a = *--it;\n\n        ++it;\n\n        int b = *++it;\n\n        if (collid(a, b)) {\n\n            return false;\n\n        }\n\n    }\n\n    tree.erase(v);\n\n    return true;\n\n}\n\n\n\nbool ok(double mid) {\n\n    ::mid = mid;\n\n    tree.clear();\n\n    int l = 0, r = 0;\n\n    while (l < n || r < n) {\n\n        if (l == n) {\n\n            if (!remove(num[RR[r++]])) {\n\n                return false;\n\n            }\n\n        } else if (r == n) {\n\n            if (!insert(num[LL[l++]])) {\n\n                return false;\n\n            }\n\n        } else if (sgn(X[LL[l]] - R[LL[l]] - mid - X[RR[r]] - R[RR[r]] - mid) <= 0){\n\n            if (!insert(num[LL[l++]])) {\n\n                return false;\n\n            }\n\n        } else {\n\n            if (!remove(num[RR[r++]])) {\n\n                return false;\n\n            }\n\n        }\n\n    }\n\n    return true;\n\n}\n\nbool cmpy(int a, int b) {\n\n    if (Y[a] == Y[b]) {\n\n        return X[a] < X[b];\n\n    }\n\n    return Y[a] < Y[b];\n\n}\n\nbool cmpl(int a, int b) {\n\n    return X[a] - R[a] < X[b] - R[b];\n\n}\n\nbool cmpr(int a, int b) {\n\n    return X[a] + R[a] < X[b] + R[b];\n\n}\n\ndouble solve() {\n\n    for (int i = 0; i < n; ++i) {\n\n        tmp[i] = LL[i] = RR[i] = i;\n\n    }\n\n    sort(tmp, tmp + n, cmpy);\n\n    for (int i = 0; i < n; ++i) {\n\n        num[tmp[i]] = i;\n\n    }\n\n    sort(LL, LL + n, cmpl);\n\n    sort(RR, RR + n, cmpr);\n\n    double s = 0, t = SQR(sqrt(SQR(X[0] - X[1]) + SQR(Y[0] - Y[1])) - R[0] - R[1]);\n\n    while (t - s > 1e-8) {\n\n        double mid = (s + t) / 2;\n\n        if (ok(mid)) {\n\n            s = mid;\n\n        } else {\n\n            t = mid;\n\n        }\n\n    }\n\n    return s + t;\n\n}\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d\", &n);\n\n        for (int i = 0; i < n; ++i) {\n\n            scanf(\"%d %d %d\", X + i, Y + i, R + i);\n\n        }\n\n        printf(\"%.6lf\\n\", solve());\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(227,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    int t;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        char str[55];\r\n        scanf(\"%s\",str);\r\n        char temp;\r\n        int i,j;\r\n        int flag=0;\r\n        for(i=0;i<strlen(str);i++)\r\n        {\r\n            if(str[i]==\':\'&&(str[i+1]==\'/\'||str[i+1]==\'\\\\\')\r\n               &&(str[i+2]==\'/\'||str[i+2]==\'\\\\\'))\r\n               flag=1;\r\n        }\r\n        if(flag)\r\n        {\r\n            for(j=0;j<strlen(str);j++)\r\n            if(str[j]==\'\\\\\')\r\n            str[j]=\'/\';\r\n            printf(\"It\'s a URL!\\n\");\r\n            printf(\"%s\\n\",str);\r\n           \r\n        }\r\n        else if(str[0]==\'/\'||str[0]==\'\\\\\')\r\n        {\r\n            for(j=0;j<strlen(str);j++)\r\n            if(str[j]==\'\\\\\')\r\n            str[j]=\'/\';\r\n            printf(\"It\'s a path in Unix-like systems!\\n\");\r\n            printf(\"%s\\n\",str);\r\n            \r\n        }\r\n        else\r\n        {\r\n            for(j=0;j<strlen(str);j++)\r\n            if(str[j]==\'/\')\r\n            str[j]=\'\\\\\';\r\n            printf(\"It\'s a path in Windows system!\\n\");\r\n            printf(\"%s\\n\",str);\r\n           \r\n        }\r\n    }\r\n    return 0;\r\n}'),(228,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    int t;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        char str[55];\r\n        scanf(\"%s\",str);\r\n        char temp;\r\n        int i,j;\r\n        int flag=0;\r\n        for(i=0;i<strlen(str);i++)\r\n        {\r\n            if(str[i]==\':\'&&(str[i+1]==\'/\'||str[i+1]==\'\\\\\')\r\n               &&(str[i+2]==\'/\'||str[i+2]==\'\\\\\'))\r\n               flag=1;\r\n        }\r\n        if(flag)\r\n        {\r\n            for(j=0;j<strlen(str);j++)\r\n            if(str[j]==\'\\\\\')\r\n            str[j]=\'/\';\r\n            printf(\"It\'s a URL!\\n\");\r\n            printf(\"%s\\n\",str);\r\n           \r\n        }\r\n        else if(str[0]==\'/\'||str[0]==\'\\\\\')\r\n        {\r\n            for(j=0;j<strlen(str);j++)\r\n            if(str[j]==\'\\\\\')\r\n            str[j]=\'/\';\r\n            printf(\"It\'s a path in Unix-like systems!\\n\");\r\n            printf(\"%s\\n\",str);\r\n            \r\n        }\r\n        else\r\n        {\r\n            for(j=0;j<strlen(str);j++)\r\n            if(str[j]==\'/\')\r\n            str[j]=\'\\\\\';\r\n            printf(\"It\'s a path in Windows system!\\n\");\r\n            printf(\"%s\\n\",str);\r\n           \r\n        }\r\n    }\r\n    return 0;\r\n}'),(229,'/*\n\n * Author: momodi\n\n * Created Time:  2009/9/5 22:31:02\n\n * File Name: Nova.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <algorithm>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((long long)(v) * (v))\n\nconst int maxn = 310;\n\nint n, m, t;\n\nint lichx[maxn], lichy[maxn], lichr[maxn], licht[maxn];\n\nint wispx[maxn], wispy[maxn];\n\nint treex[maxn], treey[maxn], treer[maxn];\n\nbool adj[maxn][maxn];\n\nint now[maxn];\n\n\n\nlong long sqr(long long a) {\n\n    return a * a;\n\n}\n\nlong long dist2(int ax, int ay, int bx, int by) {\n\n    return SQR(ax - bx) + SQR(ay - by);\n\n}\n\nint cross(int ax, int ay, int bx, int by, int cx, int cy) {\n\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);\n\n}\n\nint mul(int  ax, int ay, int bx, int by, int cx, int cy) {\n\n    return (bx - ax) * (cx - ax) + (by - ay) * (cy - ay);\n\n}\n\n\n\nbool block(int a, int b, int c) {\n\n    if (sqr(cross(lichx[a], lichy[a], wispx[b], wispy[b], treex[c], treey[c])) > SQR(treer[c]) * dist2(lichx[a], lichy[a], wispx[b], wispy[b])) {\n\n        return false;\n\n    }\n\n    return mul(lichx[a], lichy[a], wispx[b], wispy[b], treex[c], treey[c]) >= 0 &&\n\n        mul(wispx[b], wispy[b], lichx[a], lichy[a], treex[c], treey[c]) >= 0;\n\n}\n\n\n\nbool can_see(int a, int b) {\n\n    int d2 = SQR(lichx[a] - wispx[b]) + SQR(lichy[a] - wispy[b]);\n\n    if (d2 > SQR(lichr[a])) {\n\n        return false;\n\n    }\n\n    for (int i = 0; i < t; ++i) {\n\n        if (block(a, b, i)) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n\nint match[maxn], flag[maxn];\n\nbool dfs(int v) {\n\n    for (int i = 0; i < m; ++i) {\n\n        if (adj[v][i] && flag[i] == false) {\n\n            flag[i] = true;\n\n            if (match[i] == -1 || dfs(match[i])) {\n\n                match[i] = v;\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n    return false;\n\n}\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d %d %d\", &n, &m, &t);\n\n        for (int i = 0; i < n; ++i) {\n\n            scanf(\"%d %d %d %d\", lichx + i, lichy + i, lichr + i, licht + i);\n\n        }\n\n        for (int i = 0; i < m; ++i) {\n\n            scanf(\"%d %d\", wispx + i, wispy + i);\n\n        }\n\n        for (int i = 0; i < t; ++i) {\n\n            scanf(\"%d %d %d\", treex + i, treey + i, treer + i);\n\n        }\n\n        \n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < m; ++j) {\n\n                adj[i][j] = can_see(i, j);\n\n            }\n\n        }\n\n        int tot = 0;\n\n        int ans = 0;\n\n        memset(match, -1, sizeof(match));\n\n        memset(now, 0, sizeof(now));\n\n        while (tot < m) {\n\n            int mmin = maxint;\n\n            int v = -1;\n\n            for (int i = 0; i < n; ++i) {\n\n                if (get_min(mmin, now[i])) {\n\n                    v = i;\n\n                }\n\n            }\n\n            if (v == -1) {\n\n                break;\n\n            }\n\n            memset(flag, 0, sizeof(flag));\n\n            if (dfs(v)) {\n\n                ans = now[v];\n\n                now[v] += licht[v];\n\n                ++tot;\n\n            } else {\n\n                now[v] = maxint;\n\n            }\n\n        }\n\n        if (tot == m) {\n\n            printf(\"%d\\n\", ans);\n\n        } else {\n\n            printf(\"-1\\n\");\n\n        }\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(230,'/*\n\n * Author: momodi\n\n * Created Time:  2009/9/5 22:31:02\n\n * File Name: Nova.cpp\n\n * Description: \n\n */\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <cmath>\n\n#include <vector>\n\n#include <cstdlib>\n\n#include <algorithm>\n\nusing namespace std;\n\n#define out(x) fprintf(stderr, \"%s: %I64d\\n\", #x, (long long)(x))\n\n#define SZ(v) ((int)(v).size())\n\nconst int maxint=-1u>>1;\n\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\n\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\n\n#define SQR(v) ((long long)(v) * (v))\n\nconst int maxn = 310;\n\nint n, m, t;\n\nint lichx[maxn], lichy[maxn], lichr[maxn], licht[maxn];\n\nint wispx[maxn], wispy[maxn];\n\nint treex[maxn], treey[maxn], treer[maxn];\n\nbool adj[maxn][maxn];\n\nint now[maxn];\n\n\n\nlong long sqr(long long a) {\n\n    return a * a;\n\n}\n\nlong long dist2(int ax, int ay, int bx, int by) {\n\n    return SQR(ax - bx) + SQR(ay - by);\n\n}\n\nint cross(int ax, int ay, int bx, int by, int cx, int cy) {\n\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);\n\n}\n\nint mul(int  ax, int ay, int bx, int by, int cx, int cy) {\n\n    return (bx - ax) * (cx - ax) + (by - ay) * (cy - ay);\n\n}\n\n\n\nbool block(int a, int b, int c) {\n\n    if (sqr(cross(lichx[a], lichy[a], wispx[b], wispy[b], treex[c], treey[c])) > SQR(treer[c]) * dist2(lichx[a], lichy[a], wispx[b], wispy[b])) {\n\n        return false;\n\n    }\n\n    return mul(lichx[a], lichy[a], wispx[b], wispy[b], treex[c], treey[c]) >= 0 &&\n\n        mul(wispx[b], wispy[b], lichx[a], lichy[a], treex[c], treey[c]) >= 0;\n\n}\n\n\n\nbool can_see(int a, int b) {\n\n    int d2 = SQR(lichx[a] - wispx[b]) + SQR(lichy[a] - wispy[b]);\n\n    if (d2 > SQR(lichr[a])) {\n\n        return false;\n\n    }\n\n    for (int i = 0; i < t; ++i) {\n\n        if (block(a, b, i)) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n\nint match[maxn], flag[maxn];\n\nbool dfs(int v) {\n\n    for (int i = 0; i < m; ++i) {\n\n        if (adj[v][i] && flag[i] == false) {\n\n            flag[i] = true;\n\n            if (match[i] == -1 || dfs(match[i])) {\n\n                match[i] = v;\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n    return false;\n\n}\n\nint main() {\n\n    int ca;\n\n    scanf(\"%d\", &ca);\n\n    while (ca--) {\n\n        scanf(\"%d %d %d\", &n, &m, &t);\n\n        for (int i = 0; i < n; ++i) {\n\n            scanf(\"%d %d %d %d\", lichx + i, lichy + i, lichr + i, licht + i);\n\n        }\n\n        for (int i = 0; i < m; ++i) {\n\n            scanf(\"%d %d\", wispx + i, wispy + i);\n\n        }\n\n        for (int i = 0; i < t; ++i) {\n\n            scanf(\"%d %d %d\", treex + i, treey + i, treer + i);\n\n        }\n\n        \n\n        for (int i = 0; i < n; ++i) {\n\n            for (int j = 0; j < m; ++j) {\n\n                adj[i][j] = can_see(i, j);\n\n            }\n\n        }\n\n        int tot = 0;\n\n        int ans = 0;\n\n        memset(match, -1, sizeof(match));\n\n        memset(now, 0, sizeof(now));\n\n        while (tot < m) {\n\n            int mmin = maxint;\n\n            int v = -1;\n\n            for (int i = 0; i < n; ++i) {\n\n                if (get_min(mmin, now[i])) {\n\n                    v = i;\n\n                }\n\n            }\n\n            if (v == -1) {\n\n                break;\n\n            }\n\n            memset(flag, 0, sizeof(flag));\n\n            if (dfs(v)) {\n\n                ans = now[v];\n\n                now[v] += licht[v];\n\n                ++tot;\n\n            } else {\n\n                now[v] = maxint;\n\n            }\n\n        }\n\n        if (tot == m) {\n\n            printf(\"%d\\n\", ans);\n\n        } else {\n\n            printf(\"-1\\n\");\n\n        }\n\n    }\n\n    return 0;\n\n}\n\n\n\n'),(231,'#include <stdio.h>\r\n#include <algorithm>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    int x,y,v;\r\n}a[20];\r\n\r\nint dp[1005][1005];\r\n\r\nint main()\r\n{\r\n    int i,j,k,n,X,Y,t;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        scanf(\"%d%d%d\",&n,&X,&Y);\r\n        for(i = 0;i<n;i++)\r\n        scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].v);\r\n        memset(dp,0,sizeof(dp));\r\n        for(i = 0;i<=X;i++)\r\n        {\r\n            for(j = 0;j<=Y;j++)\r\n            {\r\n                for(k = 0;k<n;k++)\r\n                {\r\n                    if(i>=a[k].x && j>=a[k].y)\r\n                    dp[i][j] = max(dp[i][j],max((dp[i-a[k].x][j]+dp[a[k].x][j-a[k].y]),(dp[i][j-a[k].y]+dp[i-a[k].x][a[k].y]))+a[k].v);\r\n                    if(i>=a[k].y && j>=a[k].x)\r\n                    dp[i][j] = max(dp[i][j],max((dp[i-a[k].y][j]+dp[a[k].y][j-a[k].x]),(dp[i][j-a[k].x]+dp[i-a[k].y][a[k].x]))+a[k].v);\r\n                }\r\n            }\r\n        }\r\n        printf(\"%d\\n\",dp[X][Y]);\r\n    }\r\n\r\n    return 0;\r\n}'),(232,'#include <stdio.h>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    int x,y,v;\r\n}a[20];\r\n\r\nint dp[1005][1005];\r\n\r\nint main()\r\n{\r\n    int i,j,k,n,X,Y,t;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        scanf(\"%d%d%d\",&n,&X,&Y);\r\n        for(i = 0;i<n;i++)\r\n        scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].v);\r\n        memset(dp,0,sizeof(dp));\r\n        for(i = 0;i<=X;i++)\r\n        {\r\n            for(j = 0;j<=Y;j++)\r\n            {\r\n                for(k = 0;k<n;k++)\r\n                {\r\n                    if(i>=a[k].x && j>=a[k].y)\r\n                    dp[i][j] = max(dp[i][j],max((dp[i-a[k].x][j]+dp[a[k].x][j-a[k].y]),(dp[i][j-a[k].y]+dp[i-a[k].x][a[k].y]))+a[k].v);\r\n                    if(i>=a[k].y && j>=a[k].x)\r\n                    dp[i][j] = max(dp[i][j],max((dp[i-a[k].y][j]+dp[a[k].y][j-a[k].x]),(dp[i][j-a[k].x]+dp[i-a[k].y][a[k].x]))+a[k].v);\r\n                }\r\n            }\r\n        }\r\n        printf(\"%d\\n\",dp[X][Y]);\r\n    }\r\n\r\n    return 0;\r\n}'),(233,'#include <stdio.h> \r\nint main() \r\n{ \r\n    float sn=0,l=1; \r\n    int n,k; \r\n    scanf(\"%d\",&k); \r\n    for(n=1;sn<=k;n++) \r\n    { \r\n        sn=sn+l/n; \r\n    } \r\n    printf(\"%d\",n-1); \r\n    return 0; \r\n} '),(234,'void main(){int k,n=1;double sn=1;\r\n   scanf(\"%d\",&k);\r\n   while(sn<=k*1.0) sn+=1.0/(++n);\r\n   printf(\"%d\\n\",n);}'),(235,'#include<iostream>\r\n#include<cstring>\r\n#include <math.h>\r\nusing namespace std;\r\nint p[1230];\r\nlong x[21];\r\nint a[21];\r\nlong sum;\r\nlong total;\r\nint f[10001];\r\nvoid Get_Prime()\r\n {\r\n     memset(p,0,sizeof(p));\r\n     int i,j,s;\r\n     s=0;\r\n     f[1]=0;\r\n     for(i=2;i<=10000;i++)\r\n       f[i]=1;\r\n     for(i=2;i<=10000;i++)\r\n      if(f[i]==1)\r\n       {\r\n           s++;\r\n           p[s]=i;\r\n           j=2*i;\r\n           while(j<=10000)\r\n            {\r\n                f[j]=0;\r\n                j+=i;\r\n            }\r\n       }\r\n }\r\nbool fit(long sum)\r\n{\r\n    int m,Max;\r\n    Max=int(sqrt(sum+0.0))+1;\r\n    m=1;\r\n    while(sum%p[m]!=0&&p[m]<Max)\r\n     m++;\r\n    if(p[m]>=Max)\r\n     return 1;\r\n    else\r\nreturn 0;\r\n}\r\nint main()\r\n{\r\n    int n,k;\r\n    int i,j;\r\n    Get_Prime();\r\n    while(cin>>n>>k)\r\n     {\r\n         for(i=1;i<=n;i++)\r\n          cin>>x[i];\r\n        total=0;\r\n        for(i=0;i<=k;i++)\r\n        a[i]=i;\r\n    while(a[0]==0)\r\n         {\r\n             sum=0;\r\n             for(i=1;i<=k;i++)\r\n               sum+=x[a[i]];\r\n             if(fit(sum))\r\n                total++;\r\n             j=k;\r\n             while(a[j]==n-k+j)\r\n              j--;\r\n            a[j]=a[j]+1;\r\n            for(i=j+1;i<=k;i++)\r\n             a[i]=a[i-1]+1;\r\n         }\r\n      cout<<total<<endl;\r\n     }\r\n    return 0;\r\n}'),(236,'#include<stdio.h>\r\n#include<math.h>\r\nint ss=0;\r\nvoid judge(int a)\r\n{\r\nfor(int i=2;i<sqrt(a)+1;i++)\r\nif(!(a%i)) return;\r\nss++;\r\n}\r\nvoid f(int a[],int n,int k,int sum)\r\n{\r\nint i,j,s=sum;\r\nif(k!=1)\r\n{\r\nfor(i=n;i>=k-1;i--)\r\n{\r\nsum=s;\r\nsum=sum+a[i];\r\nf(a,i-1,k-1,sum);\r\n}\r\n}\r\nelse\r\n{\r\nfor(j=n;j>=0;j--)\r\n{\r\nsum=s;\r\nsum=sum+a[j];\r\njudge(sum);\r\n}\r\n}\r\n}\r\nint main()\r\n{\r\nint n,k,a[22]={0},p[10000]={0},s=0,t,u=0;\r\nscanf(\"%d%d\",&n,&k);\r\nfor(int i=0;i<n;i++)\r\nscanf(\"%d\",&a[i]);\r\nf(a,n-1,k,0);\r\nprintf(\"%d\\n\",ss);\r\n}\r\n'),(237,'#include <stdio.h>\r\nint dg(int now);\r\nint a[10][10],b[10],zero[10],num[10];\r\nint dg(int now)\r\n{\r\n     int i;\r\n     for (i=0;i<10;i++)\r\n         if ((a[now][i]==1)&&(b[i]==0))\r\n         {\r\n            b[i]=1;\r\n            dg(i);\r\n         }\r\n}\r\nmain()\r\n{\r\n      int i,j,k,t,tn,x,y;\r\n      int n1[40]={0};\r\n      char n[40];\r\n      scanf(\"%s %d\",&n,&k);\r\n      for (i=0;i<k;i++)\r\n      {\r\n          scanf(\"%d%d\",&x,&y);\r\n          a[x][y]=1;\r\n      }\r\n      for (i=0;i<10;i++)\r\n      {\r\n          for (j=0;j<10;j++) b[j]=0;\r\n          b[i]=1;\r\n          dg(i);\r\n          zero[i]=b[0];\r\n          for (j=0;j<10;j++) num[i]+=b[j];\r\n      }\r\n      n[0]=num[n[0]-48]-zero[n[0]-48];\r\n      for (i=1;n[i]>0;i++) n[i]=num[n[i]-48];\r\n      tn=i;\r\n      t=1;\r\n      n1[0]=n[0];\r\n      for (i=1;i<tn;i++)\r\n      {\r\n          for (j=0;j<t;j++) n1[j]*=n[i];\r\n          for (j=0;j<t;j++)\r\n              if (n1[j]>9)\r\n              {\r\n                 n1[j+1]+=n1[j]/10;\r\n                 n1[j]%=10;\r\n              }\r\n          if (n1[t]>0) t++;\r\n      }\r\n      for (i=t-1;i>=0;i--) printf(\"%d\",n1[i]);\r\n      return(0);\r\n}'),(238,'#include <stdio.h>\r\nint dg(int now);\r\nint a[10][10],b[10],zero[10],num[10];\r\nint dg(int now)\r\n{\r\nint i;\r\nfor (i=0;i<10;i++)\r\nif ((a[now][i]==1)&&(b[i]==0))\r\n{\r\nb[i]=1;\r\ndg(i);\r\n}\r\n}\r\nmain()\r\n{\r\nint i,j,k,t,tn,x,y;\r\nint n1[40]={0};\r\nchar n[40];\r\nscanf(\"%s %d\",&n,&k);\r\nfor (i=0;i<k;i++)\r\n{\r\nscanf(\"%d%d\",&x,&y);\r\na[x][y]=1;\r\n}\r\nfor (i=0;i<10;i++)\r\n{\r\nfor (j=0;j<10;j++) b[j]=0;\r\nb[i]=1;\r\ndg(i);\r\nzero[i]=b[0];\r\nfor (j=0;j<10;j++) num[i]+=b[j];\r\n}\r\nn[0]=num[n[0]-48]-zero[n[0]-48];\r\nfor (i=1;n[i]>0;i++) n[i]=num[n[i]-48];\r\ntn=i;\r\nt=1;\r\nn1[0]=n[0];\r\nfor (i=1;i<tn;i++)\r\n{\r\nfor (j=0;j<t;j++) n1[j]*=n[i];\r\nfor (j=0;j<t;j++)\r\nif (n1[j]>9)\r\n{\r\nn1[j+1]+=n1[j]/10;\r\nn1[j]%=10;\r\n}\r\nif (n1[t]>0) t++;\r\n}\r\nfor (i=t-1;i>=0;i--) printf(\"%d\",n1[i]);\r\nreturn(0);\r\n}\r\n'),(239,'#include<stdio.h>\r\n#include<math.h>\r\nmain()\r\n{\r\nlong double a[21][21]={0};\r\nint m,n,x,y,i,j;\r\nscanf (\"%d%d%d%d\",&n,&m,&x,&y);\r\nfor (i=0;i<=20;i++)\r\nfor (j=0;j<=20;j++)\r\na[i][j]=0;\r\ni=j=0;\r\nif ((abs(i-x)*abs(j-y)!=2) && (abs(i-x)+abs(j-y)!=0))\r\na[0][0]=1;\r\nfor (i=0;i<=n;i++)\r\nfor (j=0;j<=m;j++)\r\n{\r\nif ((abs(i-x)*abs(j-y)!=2) && (abs(i-x)+abs(j-y)!=0))\r\n{\r\n(i)&&(a[i][j]+=a[i-1][j]);\r\n(j)&&(a[i][j]+=a[i][j-1]);\r\n}\r\n}\r\nprintf (\"%0.Lf\\n\",a[n][m]);\r\nreturn 0;\r\n}'),(240,'#include<stdio.h>\r\n#include<math.h>\r\nmain()\r\n{\r\nlong double a[21][21]={0};\r\nint m,n,x,y,i,j;\r\nscanf (\"%d%d%d%d\",&n,&m,&x,&y);\r\nfor (i=0;i<=20;i++)\r\nfor (j=0;j<=20;j++)\r\na[i][j]=0;\r\ni=j=0;\r\nif ((abs(i-x)*abs(j-y)!=2) && (abs(i-x)+abs(j-y)!=0))\r\na[0][0]=1;\r\nfor (i=0;i<=n;i++)\r\nfor (j=0;j<=m;j++)\r\n{\r\nif ((abs(i-x)*abs(j-y)!=2) && (abs(i-x)+abs(j-y)!=0))\r\n{\r\n(i)&&(a[i][j]+=a[i-1][j]);\r\n(j)&&(a[i][j]+=a[i][j-1]);\r\n}\r\n}\r\nprintf (\"%0.Lf\\n\",a[n][m]);\r\nreturn 0;\r\n}'),(241,'/*#include <stdio.h>\r\nint main()\r\n{\r\n    char s[1000000];\r\n    int i,win,lost,site;\r\n    for(i=0;;i++)\r\n    {\r\n        scanf(\"%c\",&s[i]);\r\n        if (s[i]==\'E\')\r\n            break;\r\n    }\r\n    site=i;\r\n    for(i=0,win=0,lost=0;i<site;i++)\r\n    {\r\n        if(s[i]==\'W\')\r\n            win++;\r\n        if(s[i]==\'L\')\r\n            lost++;\r\n        if(win==11 &&win-lost>=2|| lost==11 && lost-win>=2)\r\n        {\r\n            printf(\"%d:%d\\n\",win,lost);\r\n            win=0,lost=0;\r\n        }\r\n    }\r\n    if(win!=0 && lost!=0)\r\n        printf(\"%d:%d\\n\",win,lost);\r\n    printf(\"\\n\");\r\n\r\n    for(i=0,win=0,lost=0;i<site;i++)\r\n    {\r\n        if(s[i]==\'W\')\r\n            win++;\r\n        if(s[i]==\'L\')\r\n            lost++;\r\n        if(win==21 && win-lost>=2 || lost==21 && lost-win >=2)\r\n        {\r\n            printf(\"%d:%d\\n\",win,lost);\r\n            win=0,lost=0;\r\n        }\r\n    }\r\n    if(win!=0 && lost!=0)\r\n        printf(\"%d:%d\\n\",win,lost);\r\n        return 0;\r\n}\r\n*/#include <stdio.h>\r\n\r\nint main()\r\n\r\n{\r\n\r\n       char ch[1000000];\r\n\r\n       long int i, k, x = 0, y = 0, l;\r\n\r\n       for(i=0; ;i++)\r\n       {\r\n\r\n              scanf(\"%c\",&ch[i]);\r\n              if(ch[i]==\'E\') break;\r\n       }\r\n       for(k=x=y=0; k<i && ch[k] != \'\\0\' && ch[k] != \'E\'; k++)\r\n       {\r\n\r\n              if(ch[k]==\'W\') x++;\r\n              if(ch[k]==\'L\') y++;\r\n              if((x>=11&&x-y>=2)||(y>=11&&y-x>=2))\r\n              {\r\n                     printf(\"%ld:%ld\\n\",x,y);\r\n                     x=y=0;\r\n              }\r\n       }\r\n\r\n       if(ch[k]==\'E\')  printf(\"%ld:%ld\\n\\n\",x,y);\r\n              \r\n       for(k=x=y=0;k<i&&ch[k]!=\'\\0\'&&ch[k]!=\'E\';k++)\r\n\r\n       {\r\n\r\n              if(ch[k]==\'W\')  x++;\r\n\r\n              if(ch[k]==\'L\') y++;\r\n\r\n              if((x>=21&&x-y>=2)||(y>=21&&y-x>=2))\r\n            {\r\n                     printf(\"%ld:%ld\\n\",x,y);\r\n                     x=y=0;\r\n            }\r\n       }\r\n       if(ch[k]==\'E\')\r\n\r\n              printf(\"%ld:%ld\\n\",x,y);\r\n    return 0;\r\n\r\n}'),(242,'#include<stdio.h> \r\nmain() \r\n{int i=0,nw=0,nl=0;\r\nchar a[100000];\r\nscanf(\"%c\",&a[0]);i=1;\r\nif(a[0]==\'E\')\r\n{printf(\"0:0\\n\");\r\nprintf(\"\\n\");\r\nprintf(\"0:0\");\r\n}\r\nelse{\r\n\r\nwhile(a[i-1]!=\'E\')\r\n{scanf(\"%c\",&a[i]);\r\ni++;\r\n}\r\nfor(i=0;a[i]!=\'E\';i++)\r\n{if(a[i]==\'W\') nw++;\r\nif(a[i]==\'L\') nl++;\r\nif((nw>=11&&nl<=nw-2)||(nl>=11&&nw<=nl-2)){\r\n                   printf(\"%d:%d\\n\",nw,nl);nw=0;nl=0;\r\n                   }\r\n}\r\nprintf(\"%d:%d\\n\",nw,nl);\r\nprintf(\"\\n\");\r\nnw=0;nl=0;\r\nfor(i=0;a[i]!=\'E\';i++)\r\n{\r\nif(a[i]==\'W\') nw++;\r\nif(a[i]==\'L\') nl++;\r\nif((nw>=21&&nl<=nw-2)||(nl>=21&&nw<=nl-2)){\r\n                   printf(\"%d:%d\\n\",nw,nl);nw=0;nl=0;\r\n                   }\r\n}\r\nprintf(\"%d:%d\",nw,nl);\r\n}\r\ngetchar();\r\n}'),(243,'#include<iostream>  \r\nusing namespace std;  \r\nint sum[110][110],fmax[110][110][10],fmin[110][110][10],a[110];  \r\nint n,i,j,m,start,end,k;  \r\nint main(){  \r\n    cin>>n>>m;  \r\n    for (i=1;i<=n;++i){  \r\n        cin>>a[i];  \r\n        a[i+n]=a[i];  \r\n    }  \r\n    for (i=1;i<=2*n;++i)  \r\n        for (j=i;j<=2*n;++j)  \r\n            sum[i][j]=(sum[i][j-1]+a[j]+1000000)%10;  \r\n    for (i=1;i<=2*n;++i)  \r\n        for (j=i;j<=2*n;++j)  \r\n            for (k=1;k<=m;++k)  \r\n                fmin[i][j][k]=99999999;  \r\n    for (i=1;i<=2*n;++i)  \r\n        for (j=i;j<=2*n;++j){  \r\n            fmax[i][j][1]=sum[i][j];  \r\n            fmin[i][j][1]=sum[i][j];  \r\n        }  \r\n              \r\n    for (start=1;start<=n;++start){  \r\n        end=start+n-1;  \r\n        for (int distance=2;distance<=m;++distance)  \r\n            for (i=start;i<=end;++i)  \r\n                for (j=i;j<=end;++j)  \r\n                    for (k=i;k<=j;++k){  \r\n                        if (fmax[i][j][distance]<fmax[i][k][distance-1]*sum[k+1][j])  \r\n                           fmax[i][j][distance]=fmax[i][k][distance-1]*sum[k+1][j];  \r\n                        if (fmin[i][j][distance]>fmin[i][k][distance-1]*sum[k+1][j])  \r\n                           if (k+1<=j)  \r\n                           fmin[i][j][distance]=fmin[i][k][distance-1]*sum[k+1][j];  \r\n                    }  \r\n    }  \r\n    int ans_max=-1,ans_min=99999999;  \r\n      \r\n    for (i=1;i<=n;++i){  \r\n        if (fmax[i][i+n-1][m]>ans_max) ans_max=fmax[i][i+n-1][m];  \r\n        if (fmin[i][i+n-1][m]<ans_min) ans_min=fmin[i][i+n-1][m];  \r\n    }  \r\n    cout<<ans_min<<endl<<ans_max<<endl;  \r\n    return 0;  \r\n}  '),(244,'#include<iostream>  \r\nusing namespace std;  \r\nint sum[110][110],fmax[110][110][10],fmin[110][110][10],a[110];  \r\nint n,i,j,m,start,end,k;  \r\nint main(){  \r\n    cin>>n>>m;  \r\n    for (i=1;i<=n;++i){  \r\n        cin>>a[i];  \r\n        a[i+n]=a[i];  \r\n    }  \r\n    for (i=1;i<=2*n;++i)  \r\n        for (j=i;j<=2*n;++j)  \r\n            sum[i][j]=(sum[i][j-1]+a[j]+1000000)%10;  \r\n    for (i=1;i<=2*n;++i)  \r\n        for (j=i;j<=2*n;++j)  \r\n            for (k=1;k<=m;++k)  \r\n                fmin[i][j][k]=99999999;  \r\n    for (i=1;i<=2*n;++i)  \r\n        for (j=i;j<=2*n;++j){  \r\n            fmax[i][j][1]=sum[i][j];  \r\n            fmin[i][j][1]=sum[i][j];  \r\n        }  \r\n              \r\n    for (start=1;start<=n;++start){  \r\n        end=start+n-1;  \r\n        for (int distance=2;distance<=m;++distance)  \r\n            for (i=start;i<=end;++i)  \r\n                for (j=i;j<=end;++j)  \r\n                    for (k=i;k<=j;++k){  \r\n                        if (fmax[i][j][distance]<fmax[i][k][distance-1]*sum[k+1][j])  \r\n                           fmax[i][j][distance]=fmax[i][k][distance-1]*sum[k+1][j];  \r\n                        if (fmin[i][j][distance]>fmin[i][k][distance-1]*sum[k+1][j])  \r\n                           if (k+1<=j)  \r\n                           fmin[i][j][distance]=fmin[i][k][distance-1]*sum[k+1][j];  \r\n                    }  \r\n    }  \r\n    int ans_max=-1,ans_min=99999999;  \r\n      \r\n    for (i=1;i<=n;++i){  \r\n        if (fmax[i][i+n-1][m]>ans_max) ans_max=fmax[i][i+n-1][m];  \r\n        if (fmin[i][i+n-1][m]<ans_min) ans_min=fmin[i][i+n-1][m];  \r\n    }  \r\n    cout<<ans_min<<endl<<ans_max<<endl;  \r\n    return 0;  \r\n}  '),(245,'#include <stdio.h>\r\n\r\nmain()\r\n{\r\n      int i,j,n,a[20]={0};\r\n      scanf(\"%d\",&n);\r\n      a[0]=1; a[1]=1;\r\n      for (i=2;i<=n;i++)\r\n          for (j=0;j<i;j++)\r\n              a[i]=a[i]+a[j]*a[i-j-1];\r\n      printf(\"%d\",a[n]);\r\n      getchar();\r\n      getchar();\r\n      return(0);\r\n}'),(246,'#include<stdio.h>\r\nint main()\r\n{\r\nint a,i;\r\ndouble s=1;\r\nscanf(\"%d\",&a);\r\nfor(i=a*2;i>a;i--)s*=i;\r\nfor(i=a+1;i>1;i--)s/=i;\r\nprintf(\"%d\\n\",(int)s);\r\n}'),(247,'#include \"stdio.h\"\r\nmain()\r\n{\r\nint i,j,a,b,c[8],max=8;\r\nfor(i=1;i<=7;i++)\r\n     {\r\n      scanf(\"%d%d\",&a,&b);\r\n      if ((a+b)>max)\r\n         c[i]=a+b;\r\n     else\r\n	 c[i]=0;\r\n     }\r\nc[0]=0;\r\nfor(i=1;i<=7;i++)\r\n  {\r\n  if(c[i]>c[0])\r\n    {\r\n     c[0]=c[i];\r\n     j=i;\r\n    }\r\n  }\r\nif (c[0]>0)\r\n   printf(\"%d\\n\",j);\r\nelse\r\n   printf(\"0\");\r\n}\r\n\r\n'),(248,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,i=0;\r\n	while(i<7)\r\n	{\r\n		scanf(\"%d %d\",&a,&b);\r\n		if(a+b>8) break;\r\n		i++;\r\n	}\r\n	printf(\"%d\",i+1);\r\n}\r\n'),(249,'#include <stdio.h> \r\nvoid bubble(); \r\nint a[21][21],b[401][2],m,n,k,v,s; \r\nvoid bubble()//对已知有花生的点进行排序，方便之后的调用 \r\n{ \r\n     int t,i,j; \r\n     for (i=1;i<v;i++) \r\n         for (j=i+1;j<v;j++) \r\n             if (a[b[i][0]][b[i][1]]<a[b[j][0]][b[j][1]]) \r\n             { \r\n                t=b[i][0]; \r\n                b[i][0]=b[j][0]; \r\n                b[j][0]=t; \r\n                t=b[i][1]; \r\n                b[i][1]=b[j][1]; \r\n                b[j][1]=t; \r\n             } \r\n} \r\nmain() \r\n{ \r\n      int i,j,t,t0,t1,t2,r; \r\n      scanf(\"%d%d%d\",&m,&n,&k); \r\n      v=1; \r\n      for (i=1;i<=m;i++) \r\n          for (j=1;j<=n;j++) \r\n          { \r\n              scanf(\"%d\",&a[i][j]); \r\n              if (a[i][j]!=0)//判断该点是否有花生 \r\n              { \r\n                 b[v][0]=i;//保存下该点坐标 \r\n                 b[v][1]=j; \r\n                 v++; \r\n              } \r\n          } \r\n      bubble(); \r\n      s=0; \r\n      r=1; \r\n      t=b[r][0]+1;//计算采摘第一株花生所需时间 \r\n      t2=b[r][0];//计算返回路边所需时间 \r\n      while ((t+t2<=k)&&(r<=v))//两个条件判断：时间足够；花生未被采摘完 \r\n      { \r\n            s=s+a[b[r][0]][b[r][1]];//累加已摘花生 \r\n            k=k-t; \r\n            r++; \r\n            t0=b[r][0]-b[r-1][0]; \r\n            if (t0<0) t0=-t0; \r\n            t1=b[r][1]-b[r-1][1]; \r\n            if (t1<0) t1=-t1; \r\n            t=t0+t1+1;//以上四行分别计算横纵坐标的距离，最后加上采摘所需时间1 \r\n            t2=b[r][0]; \r\n      } \r\n      printf(\"%d\\n\",s); \r\n      return 0; \r\n}'),(250,'#include<stdio.h>\r\n#include<math.h>\r\nint plant[51][51];\r\nint main(){\r\nint cx,cy,T,m,n,i,j,mx,my,time,get;\r\nget=0;\r\nscanf(\"%d%d%d\",&m,&n,&time);\r\nfor(i=1;i<=m;i++)\r\nfor(j=1;j<=n;j++)\r\nscanf(\"%d\",&plant[i][j]);\r\nmx=my=1;\r\nfor(i=1;i<=m;i++){\r\nfor(j=1;j<=n;j++){\r\nif(plant[i][j]>plant[mx][my]){\r\nmx=i;\r\nmy=j;\r\n}\r\n}\r\n}\r\ncy=my;\r\ncx=0;\r\nwhile(time>0){\r\nfor(i=1;i<=m;i++)\r\nfor(j=1;j<=n;j++){\r\nif(plant[i][j]>plant[mx][my]){\r\nmx=i;\r\nmy=j;\r\n}\r\n}\r\nif(plant[mx][my]==0)\r\nbreak;\r\nif(time>=(abs(cx-mx)+abs(cy-my)+mx+1)){\r\ntime-=(abs(cx-mx)+abs(cy-my)+1);\r\ncx=mx;cy=my;\r\nget+=plant[mx][my];\r\nplant[mx][my]=0;   \r\n}else	break;\r\n}\r\nprintf(\"%d\\n\",get);\r\nreturn 0;\r\n}'),(251,'#include <stdio.h>\r\nvoid print(int a1,int a2);\r\nchar a[1100];\r\nvoid print(int a1,int a2)\r\n{\r\n     int i,t0,t1;\r\n     if (a1==a2)\r\n     {\r\n        if (a[a1]==\'0\') printf(\"B\");\r\n        else printf(\"I\");\r\n     }\r\n     else\r\n     {\r\n         i=(a2-a1-1)/2;\r\n         print(a1,a1+i);\r\n         print(a2-i,a2);\r\n         t0=0; t1=0;\r\n         for (i=a1;i<=a2;i++)\r\n             if (a[i]==\'0\') t0++;\r\n             else t1++;\r\n         if (t0==0) printf(\"I\");\r\n         else if (t1==0) printf(\"B\");\r\n              else printf(\"F\");\r\n     }\r\n}\r\nmain()\r\n{\r\n      int n1,n,i;\r\n      scanf(\"%d\",&n1);\r\n      n=1;\r\n      for (i=0;i<n1;i++) n=n*2;\r\n      getchar();\r\n      for (i=0;i<n;i++) scanf(\"%c\",&a[i]);\r\n      print(0,n-1);\r\n      getchar();\r\n      getchar();\r\n      return(0);\r\n}\r\n'),(252,'#include <stdio.h> \r\n#define MAXN 1 << 11 \r\nint s[MAXN]; \r\nchar a[MAXN]; \r\nint n; \r\nvoid solve(int i,int j) { \r\n if (i == j) { \r\n if (a[i] == \'1\') \r\n printf(\"I\"); \r\n else\r\n printf(\"B\"); \r\n return; \r\n } \r\nsolve(i,(i + j) / 2); \r\n solve((i + j) / 2 + 1,j); \r\n int x = s[j] - s[i - 1]; \r\n if (x == (j - i + 1)) \r\n printf(\"I\"); \r\n else\r\n if (x) \r\n printf(\"F\"); \r\n else\r\n printf(\"B\"); \r\n} \r\nint main() { \r\n scanf(\"%d%s\",&n,a); \r\nn = 1 << n; \r\n for (int i = n;i > 0;--i) \r\n a[i] = a[i - 1]; \r\n for (int i = 1;i <= n;++i)  \r\n if (a[i] == \'1\') \r\n s[i] = s[i - 1] + 1; \r\n  \r\nelse\r\n s[i] = s[i - 1]; \r\nsolve(1,n); \r\n return 0; \r\n}'),(253,'#include <stdio.h>\r\n#include <algorithm> \r\nusing namespace std;\r\nvoid swap(int *a,int *b)\r\n{\r\n	int tmp = *a;	*a = *b;	*b = tmp;\r\n}\r\nint flagx(int *s,int n)\r\n{\r\n	int i;\r\n	for(i = n; s[i]<s[i-1]; i--);\r\n	return i-1;\r\n}\r\nint flagy(int *s,int loc,int n)\r\n{\r\n	for(int i = n; i>loc; i--)\r\n		if(s[i] > s[loc])	return i;\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,m;\r\n	int s[10001];\r\n	while(scanf(\"%d%d\",&n,&m)!=EOF)\r\n	{\r\n		for(int i = 1; i<=n; i++)\r\n			scanf(\"%d\",&s[i]);\r\n		int count = 0;\r\n		while( count != m )\r\n		{\r\n			int tmp1,tmp2;\r\n			if( (tmp1 = flagx(s,n)) != 0 && (tmp2 = flagy(s,tmp1,n)) != 0)\r\n			{\r\n				swap(&s[tmp1],&s[tmp2]);\r\n				sort(s+tmp1+1,s+n+1);\r\n				count++;\r\n			}\r\n		}\r\n		printf(\"%d\",s[1]);\r\n		for(int i = 2; i<=n; i++)\r\n			printf(\" %d\",s[i]);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}\r\n'),(254,'#include <stdio.h>\r\n#include <algorithm> \r\nusing namespace std;\r\nvoid swap(int *a,int *b)\r\n{\r\n	int tmp = *a;	*a = *b;	*b = tmp;\r\n}\r\nint flagx(int *s,int n)\r\n{\r\n	int i;\r\n	for(i = n; s[i]<s[i-1]; i--);\r\n	return i-1;\r\n}\r\nint flagy(int *s,int loc,int n)\r\n{\r\n	for(int i = n; i>loc; i--)\r\n		if(s[i] > s[loc])	return i;\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,m;\r\n	int s[10001];\r\n	while(scanf(\"%d%d\",&n,&m)!=EOF)\r\n	{\r\n		for(int i = 1; i<=n; i++)\r\n			scanf(\"%d\",&s[i]);\r\n		int count = 0;\r\n		while( count != m )\r\n		{\r\n			int tmp1,tmp2;\r\n			if( (tmp1 = flagx(s,n)) != 0 && (tmp2 = flagy(s,tmp1,n)) != 0)\r\n			{\r\n				swap(&s[tmp1],&s[tmp2]);\r\n				sort(s+tmp1+1,s+n+1);\r\n				count++;\r\n			}\r\n		}\r\n		printf(\"%d\",s[1]);\r\n		for(int i = 2; i<=n; i++)\r\n			printf(\" %d\",s[i]);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}\r\n'),(255,'#include <iostream>   \r\nusing namespace std;   \r\nstruct money   \r\n{   \r\n    char name[25];   \r\n    long a;   \r\n    long b;   \r\n    char p;   \r\n    char q;   \r\n    long s;   \r\n    long long mon;   \r\n};   \r\nint main()   \r\n{   \r\n    struct money money[110]={0};   \r\n    long n,i;   \r\n    long long allm=0;   \r\n    cin>>n;   \r\n    for(i=0;i<n;i++)   \r\n    {   \r\n        cin>>money[i].name>>money[i].a>>money[i].b>>money[i].p>>money[i].q>>money[i].s;   \r\n        money[i].mon=0;   \r\n        if(money[i].a>80 && money[i].s>0)   \r\n            money[i].mon+=8000;   \r\n        if(money[i].a>85 && money[i].b>80)   \r\n            money[i].mon+=4000;   \r\n        if(money[i].a>90)   \r\n            money[i].mon+=2000;   \r\n        if(money[i].a>85 && money[i].q==\'Y\')   \r\n            money[i].mon+=1000;   \r\n        if(money[i].b>80 && money[i].p==\'Y\')   \r\n            money[i].mon+=850;   \r\n        allm+=money[i].mon;   \r\n    }   \r\n    int max=money[0].mon,tt=0;   \r\n    for(int dd=0;dd<n;dd++)   \r\n    {   \r\n        if(money[dd].mon>max)   \r\n        {   \r\n            max=money[dd].mon;   \r\n            tt=dd;   \r\n        }   \r\n    }   \r\n    cout<<money[tt].name<<\"\\n\"<<money[tt].mon<<\"\\n\"<<allm;   \r\n    return 0;   \r\n} '),(256,'#include<iostream>\r\nusing namespace std;\r\nchar name[110][25]={0};\r\nint sch[110]={0};\r\n\r\nint main()\r\n{\r\n    int i,n;\r\n    int qm,bj,lw;\r\n    int max=0,maxn=0;\r\n    char gb,xb;\r\n    cin >> n;\r\n    for (i=1 ; i<=n ; i++)\r\n      {\r\n             cin>>name[i]>>qm>>bj>>gb>>xb>>lw;\r\n             if (qm>80 && lw>0) sch[i]+=8000;\r\n             if (qm>85 && bj>80) sch[i] += 4000;\r\n             if (qm>90) sch[i] += 2000;\r\n             if (qm>85 && xb ==\'Y\') sch[i] +=1000;\r\n             if (bj>80 && gb ==\'Y\') sch[i] +=850;\r\n      }\r\n    for(i=1;i<=n;i++) max+=sch[i];\r\n    for(i=1;i<=n;i++) \r\n    if(sch[i]>maxn) {maxn=sch[i];qm=i;}\r\n    cout<<name[qm]<<endl<<maxn<<endl<<max;\r\n    return 0;\r\n}'),(257,'#include <stdio.h> \r\n#include <string.h> \r\nlong stone[101]; \r\nint map[100001]; \r\nint f[100001]; \r\nlong L; \r\nint S, T, M;  \r\nvoid quickSort(int l, int r) \r\n{ \r\n    int i , j; \r\n    long temp; \r\n    i = l; \r\n    j = r; \r\n    temp = stone[i]; \r\n    while (i < j) \r\n    { \r\n        while (i < j && stone[j] > temp) \r\n            j--; \r\n        if (i < j) \r\n        { \r\n            stone[i] = stone[j]; \r\n            i++; \r\n        } \r\n        while (i < j && stone[i] < temp)                                                                         \r\n            i++; \r\n        if (i < j) \r\n        { \r\n            stone[j] = stone[i]; \r\n            j--; \r\n        } \r\n    } \r\n    stone[i] = temp; \r\n    if (i - 1 > l) quickSort(l, i - 1); \r\n    if (i + 1 < r) quickSort(i + 1, r); \r\n} \r\nint main() \r\n{ \r\n    int i, j; \r\n    long l, k, p = 0, min; \r\n    scanf(\"%ld%d%d%d\", &L, &S, &T, &M); \r\n    for (i = 1; i <= M; i++) \r\n        scanf(\"%ld\", &stone[i]); \r\n    memset(map, 0, sizeof(int)*100001); \r\n    memset(f, 0, sizeof(int)*100001); \r\n    quickSort(1, M); \r\n    stone[0] = 0; \r\n    p = 0; \r\n    for (i = 1; i <= M; i++) \r\n    { \r\n        l = stone[i] - stone[i - 1]; \r\n        if (l % T == 0)  \r\n            k = T; \r\n        else\r\n            k = l % T; \r\n        k = k + T; \r\n        if (l < k) \r\n            k = l; \r\n        p = p + k; \r\n        map[p] = 1; \r\n    } \r\n    for (i = 1; i <= p + T; i++) \r\n    { \r\n        min = 1000; \r\n        for (j = i - T; j <= i - S; j++) \r\n            if ( j >= 0 && f[j] < min) \r\n                min = f[j]; \r\n        f[i] = min + map[i]; \r\n    } \r\n    min = 1000; \r\n    for (i = p + 1; i <= p + T; i++) \r\n        if (f[i] < min) \r\n            min = f[i]; \r\n    printf(\"%d\\n\", min); \r\n    return 0; \r\n}'),(258,'#include <cstdio>\r\n#include <cstring>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\nint L;\r\nint S,T,M;\r\nint a[110];\r\nint f[20000];\r\nint v[20000];\r\nint main(){\r\n    //freopen(\"input.txt\",\"r\",stdin);\r\n    //freopen(\"output.txt\",\"w\",stdout);\r\n    scanf(\"%d\",&L);\r\n    scanf(\"%d%d%d\",&S,&T,&M);\r\n    for (int i=1;i<=M;i++) scanf(\"%d\",&a[i]);\r\n    sort(a+1,a+1+M);\r\n    a[0]=0;\r\n    a[M+1]=L;\r\n    if (S==T){\r\n              int ans=0;\r\n              for (int i=1;i<=M;i++){\r\n                  if (!(a[i] % S)) ans++;\r\n              }\r\n              cout<<ans<<endl;\r\n              return 0;\r\n    }\r\n    for (int i=1;i<=M+1;i++){\r\n        if (a[i]-a[i-1]>100){\r\n                             int t=a[i]-a[i-1]-100;\r\n                             for (int j=i;j<=M+1;j++) a[j]-=t;\r\n        }\r\n    }\r\n    for (int i=1;i<=M;i++) v[a[i]]=1;\r\n    L=a[M+1];\r\n    memset(f,8,sizeof(f));\r\n    f[0]=0;\r\n    for (int i=1;i<=L;i++){\r\n        for (int j=i-T;j<=i-S;j++){\r\n            if (j>=0){\r\n                f[i]=min(f[i],f[j]+v[i]);\r\n            }\r\n        }\r\n    }\r\n    int ans=f[L];\r\n    printf(\"%d\\n\",ans);\r\n    return 0;\r\n}'),(259,'#include <iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<stdlib.h> \r\n\r\nusing namespace std;\r\n\r\ntypedef struct\r\n{\r\n    char op;\r\n    long long v;\r\n    bool ok;\r\n}node1;\r\n\r\ntypedef struct\r\n{\r\n    int cnt;\r\n    node1 I[1010];\r\n}node2;\r\n\r\nnode2 E[30],H[30];\r\nint w[255];\r\nint N;\r\n\r\nbool big(char o1,char o2)\r\n{\r\n    if (o1==\'(\') return true;\r\n    if (o2==\'(\') return true;\r\n    return w[o1]>w[o2];\r\n}\r\nvoid postfix(int Q)\r\n{\r\n    char stack1[1010];\r\n    int top=0,p=0;\r\n    stack1[0]=\'@\';\r\n    for (int i=1;i<=E[Q].cnt;i++)\r\n    {\r\n        if (E[Q].I[i].op==0)\r\n        {\r\n            H[Q].I[++p].v=E[Q].I[i].v;\r\n            H[Q].I[p].ok=E[Q].I[i].ok;\r\n        }\r\n        else\r\n        {\r\n            if (E[Q].I[i].op==\')\')\r\n            {\r\n                while (stack1[top]!=\'(\')\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[top--]=0;\r\n            }\r\n            else if (big(E[Q].I[i].op,stack1[top]))\r\n                stack1[++top]=E[Q].I[i].op;\r\n            else\r\n            {\r\n                while (!big(E[Q].I[i].op,stack1[top]) && top>0)\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[++top]=E[Q].I[i].op;\r\n            }\r\n        }\r\n    }\r\n    H[Q].cnt=p;\r\n}\r\n\r\nlong long power(long long a,long long b)\r\n{\r\n    long long Q=1;\r\n    for (int i=1;i<=b;i++) Q*=a;\r\n    return Q;\r\n}\r\nlong long evaluate(int Q)\r\n{\r\n    int top=-1;\r\n    long long stack1[1010],a,b;\r\n    for (int i=1;i<=H[Q].cnt;i++)\r\n    {\r\n        if (H[Q].I[i].op==0)\r\n        {\r\n            stack1[++top]=H[Q].I[i].v;\r\n        }\r\n        else\r\n        {\r\n            b=stack1[top--]; a=stack1[top--];\r\n            switch(H[Q].I[i].op)\r\n            {\r\n                case \'+\':\r\n                    stack1[++top]=a+b;\r\n                    break;\r\n                case \'-\':\r\n                    stack1[++top]=a-b;\r\n                    break;\r\n                case \'*\':\r\n                    stack1[++top]=a*b;\r\n                    break;\r\n                case \'/\':\r\n                    stack1[++top]=a/b;\r\n                    break;\r\n                case \'^\':\r\n                    stack1[++top]=power(a,b);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return stack1[0];\r\n}\r\nbool is_operator(char c)\r\n{\r\n    return (c==\'+\' || c==\'-\' || c==\'*\' || c==\'/\' || c==\'^\' || c==\'(\' ||c==\')\');\r\n}\r\n\r\nvoid readf(int Q)\r\n{\r\n    int i=0; char c;\r\n    while (!cin.eof())\r\n    {\r\n        while ((c=cin.get())==\' \');\r\n            if (c==10 || c==13 || cin.eof()) break;\r\n        i++;\r\n        if (is_operator(c)) E[Q].I[i].op=c;\r\n        else if (c==\'a\') E[Q].I[i].ok=true;\r\n        else\r\n        {\r\n            cin.putback(c);\r\n            E[Q].I[i].op=0;\r\n            cin >> E[Q].I[i].v;\r\n        }\r\n    }\r\n    E[Q].I[ E[Q].cnt=i+1 ].op=\'@\';\r\n}\r\nvoid replace_letter(int P)\r\n{\r\n    int i,j;\r\n    for (i=0;i<=N;i++)\r\n        for (j=1;j<=H[i].cnt;j++)\r\n            if (H[i].I[j].ok) H[i].I[j].v=P;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    long long A,B,C;\r\n    bool right[30];\r\n    for (int i=1;i<=N;i++) right[i]=true;\r\n    for (int i=1;i<=10;i++)\r\n    {\r\n        replace_letter(rand()%100);\r\n        A=evaluate(0);\r\n        for (int j=1;j<=N;j++)\r\n        {\r\n            B=evaluate(j); C=A-B;\r\n            if (C<0) C=-C;\r\n            if (C>0.1) right[j]=false;\r\n        }\r\n    }\r\n    for (int i=1;i<=N;i++)\r\n        if (right[i]) printf(\"%c\",i-1+\'A\');\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    w[\'@\']=0; w[\'^\']=3;\r\n    w[\'+\']=w[\'-\']=1;\r\n    w[\'*\']=w[\'/\']=2;\r\n    readf(0); postfix(0);\r\n    cin>>N; getchar();\r\n    for (int i=1;i<=N;i++)\r\n    {\r\n        readf(i); postfix(i);\r\n    }\r\n    solve();\r\n    return 0;\r\n}'),(260,'#include <iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<stdlib.h> \r\n\r\nusing namespace std;\r\n\r\ntypedef struct\r\n{\r\n    char op;\r\n    long long v;\r\n    bool ok;\r\n}node1;\r\n\r\ntypedef struct\r\n{\r\n    int cnt;\r\n    node1 I[1010];\r\n}node2;\r\n\r\nnode2 E[30],H[30];\r\nint w[255];\r\nint N;\r\n\r\nbool big(char o1,char o2)\r\n{\r\n    if (o1==\'(\') return true;\r\n    if (o2==\'(\') return true;\r\n    return w[o1]>w[o2];\r\n}\r\nvoid postfix(int Q)\r\n{\r\n    char stack1[1010];\r\n    int top=0,p=0;\r\n    stack1[0]=\'@\';\r\n    for (int i=1;i<=E[Q].cnt;i++)\r\n    {\r\n        if (E[Q].I[i].op==0)\r\n        {\r\n            H[Q].I[++p].v=E[Q].I[i].v;\r\n            H[Q].I[p].ok=E[Q].I[i].ok;\r\n        }\r\n        else\r\n        {\r\n            if (E[Q].I[i].op==\')\')\r\n            {\r\n                while (stack1[top]!=\'(\')\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[top--]=0;\r\n            }\r\n            else if (big(E[Q].I[i].op,stack1[top]))\r\n                stack1[++top]=E[Q].I[i].op;\r\n            else\r\n            {\r\n                while (!big(E[Q].I[i].op,stack1[top]) && top>0)\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[++top]=E[Q].I[i].op;\r\n            }\r\n        }\r\n    }\r\n    H[Q].cnt=p;\r\n}\r\n\r\nlong long power(long long a,long long b)\r\n{\r\n    long long Q=1;\r\n    for (int i=1;i<=b;i++) Q*=a;\r\n    return Q;\r\n}\r\nlong long evaluate(int Q)\r\n{\r\n    int top=-1;\r\n    long long stack1[1010],a,b;\r\n    for (int i=1;i<=H[Q].cnt;i++)\r\n    {\r\n        if (H[Q].I[i].op==0)\r\n        {\r\n            stack1[++top]=H[Q].I[i].v;\r\n        }\r\n        else\r\n        {\r\n            b=stack1[top--]; a=stack1[top--];\r\n            switch(H[Q].I[i].op)\r\n            {\r\n                case \'+\':\r\n                    stack1[++top]=a+b;\r\n                    break;\r\n                case \'-\':\r\n                    stack1[++top]=a-b;\r\n                    break;\r\n                case \'*\':\r\n                    stack1[++top]=a*b;\r\n                    break;\r\n                case \'/\':\r\n                    stack1[++top]=a/b;\r\n                    break;\r\n                case \'^\':\r\n                    stack1[++top]=power(a,b);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return stack1[0];\r\n}\r\nbool is_operator(char c)\r\n{\r\n    return (c==\'+\' || c==\'-\' || c==\'*\' || c==\'/\' || c==\'^\' || c==\'(\' ||c==\')\');\r\n}\r\n\r\nvoid readf(int Q)\r\n{\r\n    int i=0; char c;\r\n    while (!cin.eof())\r\n    {\r\n        while ((c=cin.get())==\' \');\r\n            if (c==10 || c==13 || cin.eof()) break;\r\n        i++;\r\n        if (is_operator(c)) E[Q].I[i].op=c;\r\n        else if (c==\'a\') E[Q].I[i].ok=true;\r\n        else\r\n        {\r\n            cin.putback(c);\r\n            E[Q].I[i].op=0;\r\n            cin >> E[Q].I[i].v;\r\n        }\r\n    }\r\n    E[Q].I[ E[Q].cnt=i+1 ].op=\'@\';\r\n}\r\nvoid replace_letter(int P)\r\n{\r\n    int i,j;\r\n    for (i=0;i<=N;i++)\r\n        for (j=1;j<=H[i].cnt;j++)\r\n            if (H[i].I[j].ok) H[i].I[j].v=P;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    long long A,B,C;\r\n    bool right[30];\r\n    for (int i=1;i<=N;i++) right[i]=true;\r\n    for (int i=1;i<=10;i++)\r\n    {\r\n        replace_letter(rand()%100);\r\n        A=evaluate(0);\r\n        for (int j=1;j<=N;j++)\r\n        {\r\n            B=evaluate(j); C=A-B;\r\n            if (C<0) C=-C;\r\n            if (C>0.1) right[j]=false;\r\n        }\r\n    }\r\n    for (int i=1;i<=N;i++)\r\n        if (right[i]) printf(\"%c\",i-1+\'A\');\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    w[\'@\']=0; w[\'^\']=3;\r\n    w[\'+\']=w[\'-\']=1;\r\n    w[\'*\']=w[\'/\']=2;\r\n    readf(0); postfix(0);\r\n    cin>>N; getchar();\r\n    for (int i=1;i<=N;i++)\r\n    {\r\n        readf(i); postfix(i);\r\n    }\r\n    solve();\r\n    return 0;\r\n}'),(261,'#include <cstdio>\r\n#include <cstring>\r\n#include <iostream>\r\nusing namespace std;\r\nint b[500010][3];\r\nint a[50010],w[50010],d[50010];\r\nint ans,n;\r\nint main(){\r\n    scanf(\"%d\",&n);\r\n    for (int i=1;i<=n;i++){\r\n        scanf(\"%d%d\",&b[i][1],&b[i][2]);\r\n        d[b[i][1]]++;\r\n        d[b[i][2]]++;\r\n    }\r\n    for (int i=1;i<=n;i++){\r\n        if (d[i]!=2){printf(\"-1\\n\");return 0;}\r\n    }\r\n    a[1]=1;\r\n    a[2]=b[1][1];\r\n    for (int i=3;i<=n;i++){\r\n        if (a[i-2]!=b[a[i-1]][1]) a[i]=b[a[i-1]][1];else a[i]=b[a[i-1]][2];\r\n    }\r\n    if (a[n]!=b[1][2]){printf(\"-1\\n\");return 0;}\r\n    ans=0;\r\n    for (int i=1;i<=n;i++) w[(a[i]-i+n) % n]++;\r\n    for (int i=0;i<n;i++) if (ans<w[i]) ans=w[i];\r\n    memset(w,0,sizeof(w));\r\n    for (int i=1;i<=(n+1) >> 1;i++){\r\n        int t=a[i];a[i]=a[n-i+1];a[n-i+1]=t;\r\n    }\r\n    for (int i=1;i<=n;i++) w[(a[i]+n-i) % n]++;\r\n    for (int i=0;i<n;i++) if (w[i]>ans) ans=w[i];\r\n    printf(\"%d\\n\",n-ans);\r\n    return 0;\r\n}'),(262,'#include <cstdio>\r\n#include <cstring>\r\n#include <iostream>\r\nusing namespace std;\r\nint b[500010][3];\r\nint a[50010],w[50010],d[50010];\r\nint ans,n;\r\nint main(){\r\n    scanf(\"%d\",&n);\r\n    for (int i=1;i<=n;i++){\r\n        scanf(\"%d%d\",&b[i][1],&b[i][2]);\r\n        d[b[i][1]]++;\r\n        d[b[i][2]]++;\r\n    }\r\n    for (int i=1;i<=n;i++){\r\n        if (d[i]!=2){printf(\"-1\\n\");return 0;}\r\n    }\r\n    a[1]=1;\r\n    a[2]=b[1][1];\r\n    for (int i=3;i<=n;i++){\r\n        if (a[i-2]!=b[a[i-1]][1]) a[i]=b[a[i-1]][1];else a[i]=b[a[i-1]][2];\r\n    }\r\n    if (a[n]!=b[1][2]){printf(\"-1\\n\");return 0;}\r\n    ans=0;\r\n    for (int i=1;i<=n;i++) w[(a[i]-i+n) % n]++;\r\n    for (int i=0;i<n;i++) if (ans<w[i]) ans=w[i];\r\n    memset(w,0,sizeof(w));\r\n    for (int i=1;i<=(n+1) >> 1;i++){\r\n        int t=a[i];a[i]=a[n-i+1];a[n-i+1]=t;\r\n    }\r\n    for (int i=1;i<=n;i++) w[(a[i]+n-i) % n]++;\r\n    for (int i=0;i<n;i++) if (w[i]>ans) ans=w[i];\r\n    printf(\"%d\\n\",n-ans);\r\n    return 0;\r\n}'),(263,'#include <cstdio>\r\n#include <cstring>\r\nint a[110],b[110],c[110],d[110],ans[110];\r\nint t[110];\r\nint K;\r\nvoid Init()\r\n{\r\n    int i,l;\r\n    char s[110];\r\n    scanf(\"%s%d\",s,&K);\r\n    l=strlen(s);\r\n    for (i=0;i<l;++i) a[i]=b[i]=d[i]=s[l-i-1]-48;\r\n    c[0]=ans[0]=1;\r\n}\r\nvoid Mult1(int x)\r\n{\r\n    int i;\r\n    for (i=0;i<101;++i) ans[i]*=x;\r\n    for (i=0;i<101;++i)\r\n        if (ans[i]>9)\r\n        {\r\n            ans[i+1]+=ans[i]/10;\r\n            ans[i]%=10;\r\n        }\r\n}\r\nvoid Mult2(int (&e)[110])\r\n{\r\n    int i,j;\r\n    memset(t,0,sizeof(t));\r\n    for (i=0;i<100;++i)\r\n        for (j=100-i-1;j>=0;--j) t[i+j]+=b[i]*e[j];\r\n    for (i=0;i<100;++i)\r\n    {\r\n        if (t[i]>9)\r\n        {\r\n            t[i+1]+=t[i]/10;\r\n            t[i]%=10;\r\n        }\r\n        e[i]=t[i];\r\n    }\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    char vis[10];\r\n    Init();\r\n    Mult2(c);\r\n    Mult2(d);\r\n    for (i=0;i<K;++i)\r\n    {\r\n        memset(vis,0,10);\r\n        vis[a[i]]=1;\r\n        for (j=2;!vis[d[i]];++j)\r\n        {\r\n            vis[d[i]]=j;\r\n            Mult2(c);\r\n            Mult2(d);\r\n        }\r\n        if (vis[d[i]]!=1) break;\r\n        Mult1(j-1);\r\n        for (j=0;j<100;++j) b[j]=c[j];\r\n    }\r\n    if (i!=K) printf(\"-1\");\r\n    else\r\n    {\r\n        for (i=100;!ans[i];--i);\r\n        for (;i>=0;--i) printf(\"%d\",ans[i]);\r\n    }\r\n    return 0;\r\n}'),(264,'#include <cstdio>\r\n#include <cstring>\r\nint a[110],b[110],c[110],d[110],ans[110];\r\nint t[110];\r\nint K;\r\nvoid Init()\r\n{\r\n    int i,l;\r\n    char s[110];\r\n    scanf(\"%s%d\",s,&K);\r\n    l=strlen(s);\r\n    for (i=0;i<l;++i) a[i]=b[i]=d[i]=s[l-i-1]-48;\r\n    c[0]=ans[0]=1;\r\n}\r\nvoid Mult1(int x)\r\n{\r\n    int i;\r\n    for (i=0;i<101;++i) ans[i]*=x;\r\n    for (i=0;i<101;++i)\r\n        if (ans[i]>9)\r\n        {\r\n            ans[i+1]+=ans[i]/10;\r\n            ans[i]%=10;\r\n        }\r\n}\r\nvoid Mult2(int (&e)[110])\r\n{\r\n    int i,j;\r\n    memset(t,0,sizeof(t));\r\n    for (i=0;i<100;++i)\r\n        for (j=100-i-1;j>=0;--j) t[i+j]+=b[i]*e[j];\r\n    for (i=0;i<100;++i)\r\n    {\r\n        if (t[i]>9)\r\n        {\r\n            t[i+1]+=t[i]/10;\r\n            t[i]%=10;\r\n        }\r\n        e[i]=t[i];\r\n    }\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    char vis[10];\r\n    Init();\r\n    Mult2(c);\r\n    Mult2(d);\r\n    for (i=0;i<K;++i)\r\n    {\r\n        memset(vis,0,10);\r\n        vis[a[i]]=1;\r\n        for (j=2;!vis[d[i]];++j)\r\n        {\r\n            vis[d[i]]=j;\r\n            Mult2(c);\r\n            Mult2(d);\r\n        }\r\n        if (vis[d[i]]!=1) break;\r\n        Mult1(j-1);\r\n        for (j=0;j<100;++j) b[j]=c[j];\r\n    }\r\n    if (i!=K) printf(\"-1\");\r\n    else\r\n    {\r\n        for (i=100;!ans[i];--i);\r\n        for (;i>=0;--i) printf(\"%d\",ans[i]);\r\n    }\r\n    return 0;\r\n}'),(265,'#include <iostream>   \r\nusing namespace std;   \r\nstruct money   \r\n{   \r\n    char name[25];   \r\n    long a;   \r\n    long b;   \r\n    char p;   \r\n    char q;   \r\n    long s;   \r\n    long long mon;   \r\n};   \r\nint main()   \r\n{   \r\n    struct money money[110]={0};   \r\n    long n,i;   \r\n    long long allm=0;   \r\n    cin>>n;   \r\n    for(i=0;i<n;i++)   \r\n    {   \r\n        cin>>money[i].name>>money[i].a>>money[i].b>>money[i].p>>money[i].q>>money[i].s;   \r\n        money[i].mon=0;   \r\n        if(money[i].a>80 && money[i].s>0)   \r\n            money[i].mon+=8000;   \r\n        if(money[i].a>85 && money[i].b>80)   \r\n            money[i].mon+=4000;   \r\n        if(money[i].a>90)   \r\n            money[i].mon+=2000;   \r\n        if(money[i].a>85 && money[i].q==\'Y\')   \r\n            money[i].mon+=1000;   \r\n        if(money[i].b>80 && money[i].p==\'Y\')   \r\n            money[i].mon+=850;   \r\n        allm+=money[i].mon;   \r\n    }   \r\n    int max=money[0].mon,tt=0;   \r\n    for(int dd=0;dd<n;dd++)   \r\n    {   \r\n        if(money[dd].mon>max)   \r\n        {   \r\n            max=money[dd].mon;   \r\n            tt=dd;   \r\n        }   \r\n    }   \r\n    cout<<money[tt].name<<\"\\n\"<<money[tt].mon<<\"\\n\"<<allm<<endl;   \r\n    return 0;   \r\n} '),(266,'#include<iostream>\r\nusing namespace std;\r\nchar name[110][25]={0};\r\nint sch[110]={0};\r\nint main()\r\n{\r\n    int i,n;\r\n    int qm,bj,lw;\r\n    int max=0,maxn=0;\r\n    char gb,xb;\r\n    cin >> n;\r\n    for (i=1 ; i<=n ; i++)\r\n      {\r\n             cin>>name[i]>>qm>>bj>>gb>>xb>>lw;\r\n             if (qm>80 && lw>0) sch[i]+=8000;\r\n             if (qm>85 && bj>80) sch[i] += 4000;\r\n             if (qm>90) sch[i] += 2000;\r\n             if (qm>85 && xb ==\'Y\') sch[i] +=1000;\r\n             if (bj>80 && gb ==\'Y\') sch[i] +=850;\r\n      }\r\n    for(i=1;i<=n;i++) max+=sch[i];\r\n    for(i=1;i<=n;i++) \r\n    if(sch[i]>maxn) {maxn=sch[i];qm=i;}\r\n    cout<<name[qm]<<endl<<maxn<<endl<<max; \r\n    return 0;\r\n}'),(267,'#include <cstdio>\r\n#include <cstring>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\nint L;\r\nint S,T,M;\r\nint a[110];\r\nint f[20000];\r\nint v[20000];\r\nint main(){\r\n    //freopen(\"input.txt\",\"r\",stdin);\r\n    //freopen(\"output.txt\",\"w\",stdout);\r\n    scanf(\"%d\",&L);\r\n    scanf(\"%d%d%d\",&S,&T,&M);\r\n    for (int i=1;i<=M;i++) scanf(\"%d\",&a[i]);\r\n    sort(a+1,a+1+M);\r\n    a[0]=0;\r\n    a[M+1]=L;\r\n    if (S==T){\r\n              int ans=0;\r\n              for (int i=1;i<=M;i++){\r\n                  if (!(a[i] % S)) ans++;\r\n              }\r\n              cout<<ans<<endl;\r\n              return 0;\r\n    }\r\n    for (int i=1;i<=M+1;i++){\r\n        if (a[i]-a[i-1]>100){\r\n                             int t=a[i]-a[i-1]-100;\r\n                             for (int j=i;j<=M+1;j++) a[j]-=t;\r\n        }\r\n    }\r\n    for (int i=1;i<=M;i++) v[a[i]]=1;\r\n    L=a[M+1];\r\n    memset(f,8,sizeof(f));\r\n    f[0]=0;\r\n    for (int i=1;i<=L;i++){\r\n        for (int j=i-T;j<=i-S;j++){\r\n            if (j>=0){\r\n                f[i]=min(f[i],f[j]+v[i]);\r\n            }\r\n        }\r\n    }\r\n    int ans=f[L];\r\n    printf(\"%d\\n\",ans);\r\n    return 0;\r\n}'),(268,'#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define MAXN 1000000;\r\nbool L[200000] = {0};\r\nint f[200000] = {0}, stone[110] = {0};\r\nint min(int x, int y){return x < y ? x : y;}\r\nvoid swap(int x, int y){\r\nint k = stone[x];\r\nstone[x] = stone[y];\r\nstone[y] = k;\r\n}\r\nint main(){\r\nint l, S, T, M, i, j;\r\nscanf(\"%d%d%d%d\", &l, &S, &T, &M);\r\nfor (i = 1; i <= M; i++) scanf(\"%d\", &stone[i]);\r\nstone[0] = 0;\r\nfor (i = 1; i < M; i++)\r\nfor (j = i+1; j <= M; j++)\r\nif (stone[i] > stone[j]) swap(i, j);\r\nstone[++M] = l;\r\nfor (i = 1; i <= M; i++){\r\nwhile (stone[i] - stone[i-1] > 2520) stone[i] -= 2520;\r\nif (i != M) L[stone[i]] = 1;\r\n}\r\nl = stone[M--];\r\nfor (i = 0; i <= l; i++) f[i] = MAXN; f[0] = 0;\r\nfor (i = 0; i < l; i++)\r\nfor (j = S; j <= T; j++){\r\nint k = i+j;\r\nif (i + j >= l) k = l;\r\nf[k] = min(f[k], f[i]+L[i]);\r\n}\r\nprintf(\"%d\\n\", f[l]);\r\n} '),(269,'#include <iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<stdlib.h> \r\n\r\nusing namespace std;\r\n\r\ntypedef struct\r\n{\r\n    char op;\r\n    long long v;\r\n    bool ok;\r\n}node1;\r\n\r\ntypedef struct\r\n{\r\n    int cnt;\r\n    node1 I[1010];\r\n}node2;\r\n\r\nnode2 E[30],H[30];\r\nint w[255];\r\nint N;\r\n\r\nbool big(char o1,char o2)\r\n{\r\n    if (o1==\'(\') return true;\r\n    if (o2==\'(\') return true;\r\n    return w[o1]>w[o2];\r\n}\r\nvoid postfix(int Q)\r\n{\r\n    char stack1[1010];\r\n    int top=0,p=0;\r\n    stack1[0]=\'@\';\r\n    for (int i=1;i<=E[Q].cnt;i++)\r\n    {\r\n        if (E[Q].I[i].op==0)\r\n        {\r\n            H[Q].I[++p].v=E[Q].I[i].v;\r\n            H[Q].I[p].ok=E[Q].I[i].ok;\r\n        }\r\n        else\r\n        {\r\n            if (E[Q].I[i].op==\')\')\r\n            {\r\n                while (stack1[top]!=\'(\')\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[top--]=0;\r\n            }\r\n            else if (big(E[Q].I[i].op,stack1[top]))\r\n                stack1[++top]=E[Q].I[i].op;\r\n            else\r\n            {\r\n                while (!big(E[Q].I[i].op,stack1[top]) && top>0)\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[++top]=E[Q].I[i].op;\r\n            }\r\n        }\r\n    }\r\n    H[Q].cnt=p;\r\n}\r\n\r\nlong long power(long long a,long long b)\r\n{\r\n    long long Q=1;\r\n    for (int i=1;i<=b;i++) Q*=a;\r\n    return Q;\r\n}\r\nlong long evaluate(int Q)\r\n{\r\n    int top=-1;\r\n    long long stack1[1010],a,b;\r\n    for (int i=1;i<=H[Q].cnt;i++)\r\n    {\r\n        if (H[Q].I[i].op==0)\r\n        {\r\n            stack1[++top]=H[Q].I[i].v;\r\n        }\r\n        else\r\n        {\r\n            b=stack1[top--]; a=stack1[top--];\r\n            switch(H[Q].I[i].op)\r\n            {\r\n                case \'+\':\r\n                    stack1[++top]=a+b;\r\n                    break;\r\n                case \'-\':\r\n                    stack1[++top]=a-b;\r\n                    break;\r\n                case \'*\':\r\n                    stack1[++top]=a*b;\r\n                    break;\r\n                case \'/\':\r\n                    stack1[++top]=a/b;\r\n                    break;\r\n                case \'^\':\r\n                    stack1[++top]=power(a,b);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return stack1[0];\r\n}\r\nbool is_operator(char c)\r\n{\r\n    return (c==\'+\' || c==\'-\' || c==\'*\' || c==\'/\' || c==\'^\' || c==\'(\' ||c==\')\');\r\n}\r\n\r\nvoid readf(int Q)\r\n{\r\n    int i=0; char c;\r\n    while (!cin.eof())\r\n    {\r\n        while ((c=cin.get())==\' \');\r\n            if (c==10 || c==13 || cin.eof()) break;\r\n        i++;\r\n        if (is_operator(c)) E[Q].I[i].op=c;\r\n        else if (c==\'a\') E[Q].I[i].ok=true;\r\n        else\r\n        {\r\n            cin.putback(c);\r\n            E[Q].I[i].op=0;\r\n            cin >> E[Q].I[i].v;\r\n        }\r\n    }\r\n    E[Q].I[ E[Q].cnt=i+1 ].op=\'@\';\r\n}\r\nvoid replace_letter(int P)\r\n{\r\n    int i,j;\r\n    for (i=0;i<=N;i++)\r\n        for (j=1;j<=H[i].cnt;j++)\r\n            if (H[i].I[j].ok) H[i].I[j].v=P;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    long long A,B,C;\r\n    bool right[30];\r\n    for (int i=1;i<=N;i++) right[i]=true;\r\n    for (int i=1;i<=10;i++)\r\n    {\r\n        replace_letter(rand()%100);\r\n        A=evaluate(0);\r\n        for (int j=1;j<=N;j++)\r\n        {\r\n            B=evaluate(j); C=A-B;\r\n            if (C<0) C=-C;\r\n            if (C>0.1) right[j]=false;\r\n        }\r\n    }\r\n    for (int i=1;i<=N;i++)\r\n        if (right[i]) printf(\"%c\",i-1+\'A\');\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    w[\'@\']=0; w[\'^\']=3;\r\n    w[\'+\']=w[\'-\']=1;\r\n    w[\'*\']=w[\'/\']=2;\r\n    readf(0); postfix(0);\r\n    cin>>N; getchar();\r\n    for (int i=1;i<=N;i++)\r\n    {\r\n        readf(i); postfix(i);\r\n    }\r\n    solve();\r\n    return 0;\r\n}'),(270,'#include <iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<stdlib.h> \r\n\r\nusing namespace std;\r\n\r\ntypedef struct\r\n{\r\n    char op;\r\n    long long v;\r\n    bool ok;\r\n}node1;\r\n\r\ntypedef struct\r\n{\r\n    int cnt;\r\n    node1 I[1010];\r\n}node2;\r\n\r\nnode2 E[30],H[30];\r\nint w[255];\r\nint N;\r\n\r\nbool big(char o1,char o2)\r\n{\r\n    if (o1==\'(\') return true;\r\n    if (o2==\'(\') return true;\r\n    return w[o1]>w[o2];\r\n}\r\nvoid postfix(int Q)\r\n{\r\n    char stack1[1010];\r\n    int top=0,p=0;\r\n    stack1[0]=\'@\';\r\n    for (int i=1;i<=E[Q].cnt;i++)\r\n    {\r\n        if (E[Q].I[i].op==0)\r\n        {\r\n            H[Q].I[++p].v=E[Q].I[i].v;\r\n            H[Q].I[p].ok=E[Q].I[i].ok;\r\n        }\r\n        else\r\n        {\r\n            if (E[Q].I[i].op==\')\')\r\n            {\r\n                while (stack1[top]!=\'(\')\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[top--]=0;\r\n            }\r\n            else if (big(E[Q].I[i].op,stack1[top]))\r\n                stack1[++top]=E[Q].I[i].op;\r\n            else\r\n            {\r\n                while (!big(E[Q].I[i].op,stack1[top]) && top>0)\r\n                {\r\n                    H[Q].I[++p].op=stack1[top];\r\n                    stack1[top--]=0;\r\n                }\r\n                stack1[++top]=E[Q].I[i].op;\r\n            }\r\n        }\r\n    }\r\n    H[Q].cnt=p;\r\n}\r\n\r\nlong long power(long long a,long long b)\r\n{\r\n    long long Q=1;\r\n    for (int i=1;i<=b;i++) Q*=a;\r\n    return Q;\r\n}\r\nlong long evaluate(int Q)\r\n{\r\n    int top=-1;\r\n    long long stack1[1010],a,b;\r\n    for (int i=1;i<=H[Q].cnt;i++)\r\n    {\r\n        if (H[Q].I[i].op==0)\r\n        {\r\n            stack1[++top]=H[Q].I[i].v;\r\n        }\r\n        else\r\n        {\r\n            b=stack1[top--]; a=stack1[top--];\r\n            switch(H[Q].I[i].op)\r\n            {\r\n                case \'+\':\r\n                    stack1[++top]=a+b;\r\n                    break;\r\n                case \'-\':\r\n                    stack1[++top]=a-b;\r\n                    break;\r\n                case \'*\':\r\n                    stack1[++top]=a*b;\r\n                    break;\r\n                case \'/\':\r\n                    stack1[++top]=a/b;\r\n                    break;\r\n                case \'^\':\r\n                    stack1[++top]=power(a,b);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    return stack1[0];\r\n}\r\nbool is_operator(char c)\r\n{\r\n    return (c==\'+\' || c==\'-\' || c==\'*\' || c==\'/\' || c==\'^\' || c==\'(\' ||c==\')\');\r\n}\r\n\r\nvoid readf(int Q)\r\n{\r\n    int i=0; char c;\r\n    while (!cin.eof())\r\n    {\r\n        while ((c=cin.get())==\' \');\r\n            if (c==10 || c==13 || cin.eof()) break;\r\n        i++;\r\n        if (is_operator(c)) E[Q].I[i].op=c;\r\n        else if (c==\'a\') E[Q].I[i].ok=true;\r\n        else\r\n        {\r\n            cin.putback(c);\r\n            E[Q].I[i].op=0;\r\n            cin >> E[Q].I[i].v;\r\n        }\r\n    }\r\n    E[Q].I[ E[Q].cnt=i+1 ].op=\'@\';\r\n}\r\nvoid replace_letter(int P)\r\n{\r\n    int i,j;\r\n    for (i=0;i<=N;i++)\r\n        for (j=1;j<=H[i].cnt;j++)\r\n            if (H[i].I[j].ok) H[i].I[j].v=P;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    long long A,B,C;\r\n    bool right[30];\r\n    for (int i=1;i<=N;i++) right[i]=true;\r\n    for (int i=1;i<=10;i++)\r\n    {\r\n        replace_letter(rand()%100);\r\n        A=evaluate(0);\r\n        for (int j=1;j<=N;j++)\r\n        {\r\n            B=evaluate(j); C=A-B;\r\n            if (C<0) C=-C;\r\n            if (C>0.1) right[j]=false;\r\n        }\r\n    }\r\n    for (int i=1;i<=N;i++)\r\n        if (right[i]) printf(\"%c\",i-1+\'A\');\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    w[\'@\']=0; w[\'^\']=3;\r\n    w[\'+\']=w[\'-\']=1;\r\n    w[\'*\']=w[\'/\']=2;\r\n    readf(0); postfix(0);\r\n    cin>>N; getchar();\r\n    for (int i=1;i<=N;i++)\r\n    {\r\n        readf(i); postfix(i);\r\n    }\r\n    solve();\r\n    return 0;\r\n}'),(271,'#include <cstdio>\r\n#include <cstring>\r\n#include <iostream>\r\nusing namespace std;\r\nint b[500010][3];\r\nint a[50010],w[50010],d[50010];\r\nint ans,n;\r\nint main(){\r\n	//freopen(\"input.txt\",\"r\",stdin);\r\n    //freopen(\"output.txt\",\"w\",stdout);\r\n    scanf(\"%d\",&n);\r\n    for (int i=1;i<=n;i++){\r\n        scanf(\"%d%d\",&b[i][1],&b[i][2]);\r\n        d[b[i][1]]++;\r\n        d[b[i][2]]++;\r\n    }\r\n    for (int i=1;i<=n;i++){\r\n        if (d[i]!=2){printf(\"-1\\n\");return 0;}\r\n    }\r\n    a[1]=1;\r\n    a[2]=b[1][1];\r\n    for (int i=3;i<=n;i++){\r\n        if (a[i-2]!=b[a[i-1]][1]) a[i]=b[a[i-1]][1];else a[i]=b[a[i-1]][2];\r\n    }\r\n    if (a[n]!=b[1][2]){printf(\"-1\\n\");return 0;}\r\n    ans=0;\r\n    for (int i=1;i<=n;i++) w[(a[i]-i+n) % n]++;\r\n    for (int i=0;i<n;i++) if (ans<w[i]) ans=w[i];\r\n    memset(w,0,sizeof(w));\r\n    for (int i=1;i<=(n+1) >> 1;i++){\r\n        int t=a[i];a[i]=a[n-i+1];a[n-i+1]=t;\r\n    }\r\n    for (int i=1;i<=n;i++) w[(a[i]+n-i) % n]++;\r\n    for (int i=0;i<n;i++) if (w[i]>ans) ans=w[i];\r\n    printf(\"%d\\n\",n-ans);\r\n    return 0;\r\n}'),(272,'#include <cstdio>\r\n#include <cstring>\r\n#include <iostream>\r\nusing namespace std;\r\nint b[500010][3];\r\nint a[50010],w[50010],d[50010];\r\nint ans,n;\r\nint main(){\r\n	//freopen(\"input.txt\",\"r\",stdin);\r\n    //freopen(\"output.txt\",\"w\",stdout);\r\n    scanf(\"%d\",&n);\r\n    for (int i=1;i<=n;i++){\r\n        scanf(\"%d%d\",&b[i][1],&b[i][2]);\r\n        d[b[i][1]]++;\r\n        d[b[i][2]]++;\r\n    }\r\n    for (int i=1;i<=n;i++){\r\n        if (d[i]!=2){printf(\"-1\\n\");return 0;}\r\n    }\r\n    a[1]=1;\r\n    a[2]=b[1][1];\r\n    for (int i=3;i<=n;i++){\r\n        if (a[i-2]!=b[a[i-1]][1]) a[i]=b[a[i-1]][1];else a[i]=b[a[i-1]][2];\r\n    }\r\n    if (a[n]!=b[1][2]){printf(\"-1\\n\");return 0;}\r\n    ans=0;\r\n    for (int i=1;i<=n;i++) w[(a[i]-i+n) % n]++;\r\n    for (int i=0;i<n;i++) if (ans<w[i]) ans=w[i];\r\n    memset(w,0,sizeof(w));\r\n    for (int i=1;i<=(n+1) >> 1;i++){\r\n        int t=a[i];a[i]=a[n-i+1];a[n-i+1]=t;\r\n    }\r\n    for (int i=1;i<=n;i++) w[(a[i]+n-i) % n]++;\r\n    for (int i=0;i<n;i++) if (w[i]>ans) ans=w[i];\r\n    printf(\"%d\\n\",n-ans);\r\n    return 0;\r\n}'),(273,'#include <cstdio>\r\n#include <cstring>\r\nint a[110],b[110],c[110],d[110],ans[110];\r\nint t[110];\r\nint K;\r\nvoid Init()\r\n{\r\n    int i,l;\r\n    char s[110];\r\n    scanf(\"%s%d\",s,&K);\r\n    l=strlen(s);\r\n    for (i=0;i<l;++i) a[i]=b[i]=d[i]=s[l-i-1]-48;\r\n    c[0]=ans[0]=1;\r\n}\r\nvoid Mult1(int x)\r\n{\r\n    int i;\r\n    for (i=0;i<101;++i) ans[i]*=x;\r\n    for (i=0;i<101;++i)\r\n        if (ans[i]>9)\r\n        {\r\n            ans[i+1]+=ans[i]/10;\r\n            ans[i]%=10;\r\n        }\r\n}\r\nvoid Mult2(int (&e)[110])\r\n{\r\n    int i,j;\r\n    memset(t,0,sizeof(t));\r\n    for (i=0;i<100;++i)\r\n        for (j=100-i-1;j>=0;--j) t[i+j]+=b[i]*e[j];\r\n    for (i=0;i<100;++i)\r\n    {\r\n        if (t[i]>9)\r\n        {\r\n            t[i+1]+=t[i]/10;\r\n            t[i]%=10;\r\n        }\r\n        e[i]=t[i];\r\n    }\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    char vis[10];\r\n    Init();\r\n    Mult2(c);\r\n    Mult2(d);\r\n    for (i=0;i<K;++i)\r\n    {\r\n        memset(vis,0,10);\r\n        vis[a[i]]=1;\r\n        for (j=2;!vis[d[i]];++j)\r\n        {\r\n            vis[d[i]]=j;\r\n            Mult2(c);\r\n            Mult2(d);\r\n        }\r\n        if (vis[d[i]]!=1) break;\r\n        Mult1(j-1);\r\n        for (j=0;j<100;++j) b[j]=c[j];\r\n    }\r\n    if (i!=K) printf(\"-1\");\r\n    else\r\n    {\r\n        for (i=100;!ans[i];--i);\r\n        for (;i>=0;--i) printf(\"%d\",ans[i]);\r\n    }\r\n    return 0;\r\n}'),(274,'#include <cstdio>\r\n#include <cstring>\r\nint a[110],b[110],c[110],d[110],ans[110];\r\nint t[110];\r\nint K;\r\nvoid Init()\r\n{\r\n    int i,l;\r\n    char s[110];\r\n    scanf(\"%s%d\",s,&K);\r\n    l=strlen(s);\r\n    for (i=0;i<l;++i) a[i]=b[i]=d[i]=s[l-i-1]-48;\r\n    c[0]=ans[0]=1;\r\n}\r\nvoid Mult1(int x)\r\n{\r\n    int i;\r\n    for (i=0;i<101;++i) ans[i]*=x;\r\n    for (i=0;i<101;++i)\r\n        if (ans[i]>9)\r\n        {\r\n            ans[i+1]+=ans[i]/10;\r\n            ans[i]%=10;\r\n        }\r\n}\r\nvoid Mult2(int (&e)[110])\r\n{\r\n    int i,j;\r\n    memset(t,0,sizeof(t));\r\n    for (i=0;i<100;++i)\r\n        for (j=100-i-1;j>=0;--j) t[i+j]+=b[i]*e[j];\r\n    for (i=0;i<100;++i)\r\n    {\r\n        if (t[i]>9)\r\n        {\r\n            t[i+1]+=t[i]/10;\r\n            t[i]%=10;\r\n        }\r\n        e[i]=t[i];\r\n    }\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    char vis[10];\r\n    Init();\r\n    Mult2(c);\r\n    Mult2(d);\r\n    for (i=0;i<K;++i)\r\n    {\r\n        memset(vis,0,10);\r\n        vis[a[i]]=1;\r\n        for (j=2;!vis[d[i]];++j)\r\n        {\r\n            vis[d[i]]=j;\r\n            Mult2(c);\r\n            Mult2(d);\r\n        }\r\n        if (vis[d[i]]!=1) break;\r\n        Mult1(j-1);\r\n        for (j=0;j<100;++j) b[j]=c[j];\r\n    }\r\n    if (i!=K) printf(\"-1\");\r\n    else\r\n    {\r\n        for (i=100;!ans[i];--i);\r\n        for (;i>=0;--i) printf(\"%d\",ans[i]);\r\n    }\r\n    return 0;\r\n}'),(275,'#include <iostream>\r\n#include <cstdio>\r\n#include <set>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n   // freopen(\"random.in\",\"r\",stdin);\r\n   // freopen(\"random.out\",\"w\",stdout);\r\n    int n;\r\n    int a[1000];\r\n    set<int > s;\r\n    set<int >::iterator it;\r\n    cin>>n;\r\n    for(int i =0; i < n; i++)\r\n    {\r\n        cin>>a[i];\r\n        s.insert(a[i]);\r\n    }\r\n    cout<<s.size()<<endl;\r\n    int ok = 0;\r\n    for(it = s.begin(); it != s.end(); it++)\r\n    {\r\n        if(ok == 0)\r\n        {\r\n            cout<<*it;\r\n            ok =1;\r\n        }\r\n        else\r\n            cout<<\" \"<<*it;\r\n    }\r\n    cout<<endl;\r\n\r\n    return 0;\r\n}\r\n'),(276,'#include<cstdio>\r\n#include<iostream>\r\n#include<set>\r\nusing namespace std;\r\nint main(){\r\nset<int> a;\r\nint n;\r\ncin>>n;\r\nint t;\r\nwhile(n--){\r\ncin>>t;\r\na.insert(t);\r\n}\r\ncout<<a.size()<<endl;\r\nset<int>::iterator i=a.begin();\r\ncout<<*i;\r\nfor(i++;i!=a.end();i++)cout<<\' \'<<*i;\r\ncout<<endl;\r\n}'),(277,'#include <iostream>  \r\n#include <memory.h>  \r\nusing namespace std;  \r\n  \r\nint money[26],importance[26],dp[30001]={0};  \r\n  \r\nint main()  \r\n{  \r\n    int n,m;  \r\n    while(cin>>n>>m) //n为总钱数，m为总物品数  \r\n    {  \r\n        for(int j=1;j<=m;j++)  \r\n        {  \r\n            int v,p;  //v为该物品价格，p为该物品重要度  \r\n            cin>>v>>p;  \r\n            for(int i=n;i>=v;i--)  \r\n                if(dp[i]<dp[i-v]+v*p)  \r\n                    dp[i]=dp[i-v]+v*p;  \r\n        }  \r\n        int max=0;  \r\n        for(int i=1;i<n;i++)  \r\n            if(dp[i]>max)  \r\n                max=dp[i];  \r\n        cout<<max<<endl;  \r\n        memset(dp,0,sizeof(dp));  \r\n    }  \r\n    return 0;  \r\n}  '),(278,'#include <stdio.h>\r\n#define max(a, b) ((a)>(b)?(a):(b))\r\nint f[30000];\r\n\r\nint main(void)\r\n{\r\n    int n, m;\r\n    int i, j;\r\n    int a, b;\r\n    scanf(\"%d%d\", &n, &m);\r\n    for(i = 0; i < m; i++){\r\n        scanf(\"%d%d\", &a, &b);\r\n        for(j = n; j >= a; j--){\r\n            f[j] = max(f[j], f[j - a] + a * b);\r\n        }\r\n    }\r\n    printf(\"%d\\n\", f[n]);\r\n    return 0;\r\n}\r\n'),(279,'#include<iostream>\r\n#include<string.h>\r\n#define maxn 107\r\nusing namespace std;\r\nlong s,t,w,counter=0;\r\nchar r[maxn],ans[maxn];\r\nbool first,used[maxn];\r\n\r\nvoid dfs(long depth)\r\n{\r\n    if(counter>=5) return;\r\n    if(depth>=w)\r\n    {\r\n        if(first)\r\n        {\r\n            first=false;\r\n            return;\r\n        }\r\n        cout<<ans<<endl;\r\n        counter++;\r\n        return;\r\n    }\r\n    for(long i=(first?r[depth]-\'a\'+1:ans[depth-1]-\'a\'+2);i<=t;i++)\r\n        if(!used[i])\r\n        {\r\n            used[i]=true;\r\n            ans[depth]=i+\'a\'-1;\r\n            dfs(depth+1);\r\n            used[i]=false;\r\n        }\r\n}\r\n\r\nint main()\r\n{\r\n    cin>>s>>t>>w>>r;\r\n    //  Input\r\n    memset(ans,0,sizeof(ans));\r\n    memset(used,false,sizeof(used));\r\n    counter=0;\r\n    first=true;\r\n    dfs(0);\r\nreturn 0;\r\n}'),(280,'#include<iostream>\r\n#include<string.h>\r\n#define maxn 107\r\nusing namespace std;\r\nlong s,t,w,counter=0;\r\nchar r[maxn],ans[maxn];\r\nbool first,used[maxn];\r\n\r\nvoid dfs(long depth)\r\n{\r\n    if(counter>=5) return;\r\n    if(depth>=w)\r\n    {\r\n        if(first)\r\n        {\r\n            first=false;\r\n            return;\r\n        }\r\n        cout<<ans<<endl;\r\n        counter++;\r\n        return;\r\n    }\r\n    for(long i=(first?r[depth]-\'a\'+1:ans[depth-1]-\'a\'+2);i<=t;i++)\r\n        if(!used[i])\r\n        {\r\n            used[i]=true;\r\n            ans[depth]=i+\'a\'-1;\r\n            dfs(depth+1);\r\n            used[i]=false;\r\n        }\r\n}\r\n\r\nint main()\r\n{\r\n    cin>>s>>t>>w>>r;\r\n    //  Input\r\n    memset(ans,0,sizeof(ans));\r\n    memset(used,false,sizeof(used));\r\n    counter=0;\r\n    first=true;\r\n    dfs(0);\r\nreturn 0;\r\n}'),(281,'#include <iostream> \r\nusing namespace std; \r\nint main() \r\n{ \r\n   int n,k,p=1,m=0; \r\n   cin>>k>>n; \r\n   while(n) \r\n   {m+=(n%2)*p; \r\n   p*=k; \r\n   n/=2; \r\n   } \r\n   cout<<m<<endl;  \r\n   return 0; \r\n} '),(282,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\nint a,b;\r\nint re=0;\r\nint r=1;\r\nint t=1;\r\ncin>>a>>b;\r\nwhile(t<2048)\r\n{\r\nif(t&b) re+=r;\r\nr*=a;\r\nt<<=1;\r\n}\r\ncout<<re;\r\n}'),(283,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\ntypedef struct student\r\n{\r\n    int w,s,y,sum,n;\r\n}stu;\r\nbool cmp(stu x, stu y)\r\n{\r\n    if(x.sum==y.sum)\r\n        if(x.w==y.w)\r\n            return x.n<y.n;\r\n        else\r\n            return x.w>y.w;\r\n    else\r\n        return x.sum>y.sum;\r\n}\r\nint main()\r\n{\r\n    int i,m;\r\n    stu a[1000];\r\n    scanf(\"%d\",&m);\r\n    for(i=0;i<m;i++)\r\n    {\r\n        scanf(\"%d%d%d\",&a[i].w,&a[i].s,&a[i].y);\r\n        a[i].n=i+1;\r\n        a[i].sum=a[i].y+a[i].s+a[i].w;\r\n    }\r\n    sort(a,a+m,cmp);\r\n    for(i=0;i<5;i++)\r\n        printf(\"%d %d\\n\",a[i].n,a[i].sum);\r\n    return 0;\r\n}'),(284,'#include <algorithm>\r\nusing namespace std;\r\nstruct St\r\n{\r\n	int a,b,c;\r\n	int sum;\r\n	int id;\r\n};\r\nint cmp(const St &a, const St &b)\r\n{\r\n	return ( a.sum>b.sum || a.sum == b.sum &&(a.a>b.a) ) || a.sum == b.sum && a.a == b.a && a.id < b.id;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	St x[301];\r\n	scanf(\"%d\",&n);\r\n	for(int i = 1; i<=n; i++)\r\n	{\r\n		scanf(\"%d%d%d\",&x[i].a,&x[i].b,&x[i].c);\r\n		x[i].sum = x[i].a+x[i].b+x[i].c;\r\n		x[i].id = i;\r\n	}\r\n	sort(x+1,x+n+1,cmp);\r\n	for(int i = 1; i<=5; i++)\r\n	{\r\n		printf(\"%d %d\\n\",x[i].id,x[i].sum);\r\n	}\r\n	\r\n	return 0;\r\n}\r\n'),(285,'#include<stdio.h>\r\nstruct th{\r\n       int price;}num[30001],temp;\r\nint min(int a,int b){\r\nreturn a<b?a:b;}\r\nint part(int s,int e){\r\n    int i,j,x;\r\n    x=num[e].price;\r\n    i=s-1;\r\n    for(j=s;j<e;++j)\r\n             if(num[j].price>x){\r\n                       ++i;\r\n                       temp=num[j];\r\n                       num[j]=num[i];\r\n                       num[i]=temp;}\r\n    temp=num[e];\r\n    num[e]=num[i+1];\r\n    num[i+1]=temp;\r\n    return i+1;}\r\nvoid quick(int s,int e){\r\n     int q;\r\n     if(s<e){\r\n            q=part(s,e);\r\n            quick(s,q-1);\r\n            quick(q+1,e);}\r\n            }\r\nint main()\r\n{\r\n    int n,w,i,max,j,last;\r\n    scanf(\"%d %d\",&w,&n);\r\n    max=0;\r\n    for(i=1;i<=n;++i)\r\n           scanf(\"%d\",&num[i].price);\r\n    quick(1,n);\r\n    for(i=1,j=n;i<=j;)\r\n           if(num[i].price+num[j].price<=w){++max;++i;--j;}\r\n           else{++i;++max;}\r\n    \r\n    printf(\"%d\\n\",max);\r\n}'),(286,'#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n\r\nvoid in(int*);\r\nint count(int*,int,int);\r\n\r\nint main()\r\n{\r\n	int max(0),n(0);\r\n	std::cin>>max>>n;\r\n	int* arr=new int[n];\r\n	in(arr);\r\n	std::sort(arr,arr+n);\r\n	std::cout<<count(arr,n,max);\r\n	delete [] arr;\r\n}\r\n\r\nvoid in(int* beg)\r\n{\r\n	int temp;\r\n	while(std::cin>>temp)\r\n		*beg++=temp;\r\n}\r\n\r\nint count(int* arr,int n,int max)\r\n{\r\n	int* p0(arr+n-1);\r\n	while(arr<p0){\r\n		if(*p0+*arr<=max){\r\n			--n;\r\n			--p0;\r\n			++arr;\r\n		}else\r\n			--p0;\r\n	}\r\n	return n;\r\n}'),(287,'#include<stdio.h> \r\n#include<math.h> \r\n#include<string.h> \r\nlong max(long x,long y) \r\n{ \r\n    if (x>y) return x; else return y; \r\n} \r\nlong min(long x,long y) \r\n{ \r\n    if (x<y) return x; else return y; \r\n} \r\nvoid swap(long& x,long& y) \r\n{ \r\n    long t; \r\n    t=x;x=y;y=t; \r\n} \r\nint main() \r\n{ \r\n    long n,m,s,i,j,k,t,ans,p=0,now; \r\n    long a[31][2]; \r\n    scanf(\"%ld %ld %ld\",&m,&s,&t); \r\n    k=m/10; \r\n    m=m%10; \r\n    ans=k*60; \r\n    if (k>t){ans=t*60;} \r\n    for (i=0;i<=1;i++){ \r\n        for (j=0;j<=30;j++){ \r\n            a[j][i]=-1; \r\n        } \r\n    } \r\n    if (k*60>s){ \r\n        ans=s/60+1; \r\n        if (s%60==0){ans--;} \r\n        if (ans>=t){ \r\n            printf(\"Yes\\n\");printf(\"%d\\n\",ans); \r\n        } \r\n        p=1; \r\n    } \r\n    now=0; \r\n    a[m][0]=k*60; \r\n    if (!p){ \r\n        for (i=k+1;i<=t;i++){ \r\n            now=1-now; \r\n            for (j=0;j<=20;j++){ \r\n                if (a[j+10][1-now]>=0) a[j][now]=max(a[j][now],a[j+10][1-now]+60); \r\n                if (a[j][1-now]>=0) a[j][now]=max(a[j][now],a[j][1-now]+17); \r\n                if (j>=4 && a[j-4][1-now]>=0){a[j][now]=max(a[j][now],a[j-4][1-now]);} \r\n                if (a[j][now]>=s){printf(\"Yes\\n\");printf(\"%d\\n\",i);p=1;break;} \r\n                if (a[j][now]>ans){ans=a[j][now];} \r\n            } \r\n            if (p){break;} \r\n        } \r\n    } \r\n    if (!p){ \r\n        printf(\"No\\n\"); \r\n        printf(\"%ld\\n\",ans); \r\n    } \r\n  \r\n    return 0; \r\n} '),(288,'#include<stdio.h>\r\n#include<math.h>\r\n#include<string.h>\r\nlong max(long x,long y)\r\n{\r\n	if (x>y) return x; else return y;\r\n}\r\nlong min(long x,long y)\r\n{\r\n	if (x<y) return x; else return y;\r\n}\r\nvoid swap(long& x,long& y)\r\n{\r\n	long t;\r\n	t=x;x=y;y=t;\r\n}\r\nint main()\r\n{\r\n	long n,m,s,i,j,k,t,ans,p=0,now;\r\n	long a[31][2];\r\n	scanf(\"%ld %ld %ld\",&m,&s,&t);\r\n	k=m/10;\r\n	m=m%10;\r\n	ans=k*60;\r\n	if (k>t){ans=t*60;}\r\n	for (i=0;i<=1;i++){\r\n		for (j=0;j<=30;j++){\r\n			a[j][i]=-1;\r\n		}\r\n	}\r\n	if (k*60>s){\r\n		ans=s/60+1;\r\n		if (s%60==0){ans--;}\r\n		if (ans>=t){\r\n			printf(\"Yes\\n\");printf(\"%d\\n\",ans);\r\n		}\r\n		p=1;\r\n	}\r\n	now=0;\r\n	a[m][0]=k*60;\r\n	if (!p){\r\n		for (i=k+1;i<=t;i++){\r\n			now=1-now;\r\n			for (j=0;j<=20;j++){\r\n				if (a[j+10][1-now]>=0) a[j][now]=max(a[j][now],a[j+10][1-now]+60);\r\n				if (a[j][1-now]>=0) a[j][now]=max(a[j][now],a[j][1-now]+17);\r\n				if (j>=4 && a[j-4][1-now]>=0){a[j][now]=max(a[j][now],a[j-4][1-now]);}\r\n				if (a[j][now]>=s){printf(\"Yes\\n\");printf(\"%d\\n\",i);p=1;break;}\r\n				if (a[j][now]>ans){ans=a[j][now];}\r\n			}\r\n			if (p){break;}\r\n		}\r\n	}\r\n	if (!p){\r\n		printf(\"No\\n\");\r\n		printf(\"%ld\\n\",ans);\r\n	}\r\n\r\n	return 0;\r\n}'),(289,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nconst int MAXN = 200;\r\nint num[MAXN];\r\nint bit[MAXN];\r\n\r\nvoid print()\r\n{\r\n     int k;\r\n     \r\n     for (k = 0; k < MAXN; k ++)\r\n     if (num[k] != 0)\r\n     break;\r\n          \r\n     for (int i = k; i < MAXN; i ++)\r\n     printf(\"%d\", num[i]);\r\n     \r\n     printf(\"\\n\");\r\n}\r\n\r\nvoid sub()\r\n{\r\n     memset(bit, 0, sizeof(bit));\r\n     bit[MAXN - 1] = 2;\r\n     \r\n     for (int i = MAXN - 1; i > 0; i --)\r\n     {\r\n         if (num[i] < bit[i])\r\n         {\r\n             num[i] = 10 + num[i] - bit[i];\r\n             bit[i - 1] = 1;\r\n         }\r\n         else\r\n         num[i] -= bit[i];\r\n     }\r\n}\r\n\r\nvoid mul(int t)\r\n{\r\n     int temp;\r\n     \r\n     memset(bit, 0, sizeof(bit));\r\n     \r\n     for (int i = 1; i <= t; i ++)\r\n     {\r\n         for (int j = MAXN - 1; j > 0; j --)\r\n         {\r\n             temp = num[j];\r\n             num[j] = (temp * 2 + bit[j]) % 10;\r\n             bit[j - 1] = (temp * 2 + bit[j]) / 10;\r\n         }\r\n     }\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen(\"input.txt\", \"r\", stdin);\r\n    //freopen(\"output.txt\", \"w\", stdout);\r\n    \r\n    int n;\r\n    bool flag;\r\n    \r\n    flag = true;\r\n    while (scanf(\"%d\", &n) != EOF)\r\n    {\r\n        memset(num, 0, sizeof(num));\r\n          \r\n        num[MAXN - 1] = 1;\r\n        \r\n        mul(n + 1);\r\n        sub();\r\n        \r\n        if (flag)\r\n        {\r\n            print();\r\n            flag = false;\r\n        }\r\n        else\r\n        {\r\n            printf(\"\\n\");\r\n            print();\r\n        }\r\n    }\r\n    return 0;\r\n}'),(290,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nconst int MAXN = 200;\r\nint num[MAXN];\r\nint bit[MAXN];\r\n\r\nvoid print()\r\n{\r\n     int k;\r\n     \r\n     for (k = 0; k < MAXN; k ++)\r\n     if (num[k] != 0)\r\n     break;\r\n          \r\n     for (int i = k; i < MAXN; i ++)\r\n     printf(\"%d\", num[i]);\r\n     \r\n     printf(\"\\n\");\r\n}\r\n\r\nvoid sub()\r\n{\r\n     memset(bit, 0, sizeof(bit));\r\n     bit[MAXN - 1] = 2;\r\n     \r\n     for (int i = MAXN - 1; i > 0; i --)\r\n     {\r\n         if (num[i] < bit[i])\r\n         {\r\n             num[i] = 10 + num[i] - bit[i];\r\n             bit[i - 1] = 1;\r\n         }\r\n         else\r\n         num[i] -= bit[i];\r\n     }\r\n}\r\n\r\nvoid mul(int t)\r\n{\r\n     int temp;\r\n     \r\n     memset(bit, 0, sizeof(bit));\r\n     \r\n     for (int i = 1; i <= t; i ++)\r\n     {\r\n         for (int j = MAXN - 1; j > 0; j --)\r\n         {\r\n             temp = num[j];\r\n             num[j] = (temp * 2 + bit[j]) % 10;\r\n             bit[j - 1] = (temp * 2 + bit[j]) / 10;\r\n         }\r\n     }\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen(\"input.txt\", \"r\", stdin);\r\n    //freopen(\"output.txt\", \"w\", stdout);\r\n    \r\n    int n;\r\n    bool flag;\r\n    \r\n    flag = true;\r\n    while (scanf(\"%d\", &n) != EOF)\r\n    {\r\n        memset(num, 0, sizeof(num));\r\n          \r\n        num[MAXN - 1] = 1;\r\n        \r\n        mul(n + 1);\r\n        sub();\r\n        \r\n        if (flag)\r\n        {\r\n            print();\r\n            flag = false;\r\n        }\r\n        else\r\n        {\r\n            printf(\"\\n\");\r\n            print();\r\n        }\r\n    }\r\n    return 0;\r\n}'),(291,'#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n  \r\n#define INF 0x7FFFFFFF \r\n#define gmax(a,b) ((a)>(b)?(a):(b)) \r\n#define gmin(a,b) ((a)<(b)?(a):(b)) \r\n#define fill(a,b) memset(a,b,sizeof(a)) \r\n#define MAXV 600000 \r\n#define MAXE 600000 \r\n  \r\n  \r\ntypedef struct Edge2{ \r\n    int ver; \r\n    struct Edge2 *next; \r\n  \r\n    }Edge; \r\n  \r\nvoid SetData( Edge *P ,int V,  Edge *N) \r\n{ \r\n    P->ver = V; \r\n    P->next = N; \r\n} \r\nEdge edgepool[MAXE << 1]; \r\nint edger; \r\nEdge *onet[MAXV]; \r\nEdge *net[MAXV]; \r\nint dis[MAXV]; \r\nint Q[MAXV]; \r\nint inQ[MAXV]; \r\nint w[MAXV]; \r\nint maxv; \r\nint n, m; \r\nint sccer; \r\nint scc[MAXV]; \r\nint dfn[MAXV]; \r\nint low[MAXV]; \r\nint dfner; \r\nint S[MAXV]; \r\nint inS[MAXV]; \r\nint g[MAXV]; \r\n  \r\nvoid SPFA(int src){ \r\n    for (int i=1; i<maxv+1; i++){ \r\n        dis[i] = 0; \r\n        } \r\n    fill(inQ, 0); \r\n    int head, tail; \r\n    head = tail = 0; \r\n    dis[src] = 0; \r\n    if (++tail == maxv) \r\n        tail = 0; \r\n    Q[tail] = src; \r\n    inQ[src] = 1; \r\n    while (head != tail){ \r\n        if (++head == maxv) \r\n            head = 0; \r\n        int u = Q[head]; \r\n        inQ[u] = 0; \r\n        for (Edge *e=net[u]; e; e=e->next){ \r\n            if (dis[e->ver] < dis[u] + w[e->ver]){ \r\n                dis[e->ver] = dis[u] + w[e->ver]; \r\n                if (!inQ[e->ver]){ \r\n                    if (++tail == maxv) \r\n                        tail = 0; \r\n                    Q[tail] = e->ver; \r\n                    inQ[e->ver] = 1; \r\n                    } \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\nvoid InsOEdge(int u, int v){ \r\n    SetData(&edgepool[++edger],v,onet[u]); \r\n    onet[u] = &edgepool[edger]; \r\n    } \r\n  \r\nvoid InsEdge(int u, int v){ \r\n    SetData(&edgepool[++edger],v, net[u]); \r\n    net[u] = &edgepool[edger]; \r\n    } \r\n  \r\nvoid DfsSCC(int u){ \r\n    dfn[u] = low[u] = ++dfner; \r\n    S[++S[0]] = u; \r\n    inS[u] = 1; \r\n    for (Edge *e=onet[u]; e; e=e->next){ \r\n        if (!dfn[e->ver]){ \r\n            DfsSCC(e->ver); \r\n            low[u] = gmin(low[u], low[e->ver]); \r\n            } \r\n        else\r\n        if (inS[e->ver]){ \r\n            low[u] = gmin(low[u], dfn[e->ver]); \r\n            } \r\n        } \r\n    // \r\n    if (low[u] == dfn[u]){ \r\n        sccer++; \r\n        while (1){ \r\n            int t = S[S[0]--]; \r\n            inS[t] = 0; \r\n            scc[t] = sccer; \r\n            if (t == u) \r\n                break; \r\n            } \r\n        } \r\n    } \r\n      \r\nint main(){ \r\n      \r\n  //  freopen(\"atm.in\", \"r\", stdin); \r\n  //  freopen(\"atm.out\", \"w\", stdout); \r\n      \r\n    int i; \r\n    scanf(\"%d %d\", &n, &m); \r\n    while (m--){ \r\n        int u, v; \r\n        scanf(\"%d %d\", &u, &v); \r\n        InsOEdge(u, v); \r\n        } \r\n    // \r\n    fill(dfn, 0); \r\n    fill(scc, 0); \r\n    dfner = sccer = 0; \r\n    for (i=1; i<n+1; i++){ \r\n        if (!dfn[i]) \r\n            DfsSCC(i); \r\n        } \r\n    for (i=1; i<n+1; i++){ \r\n        for (Edge *e=onet[i]; e; e=e->next){ \r\n            if (scc[i] != scc[e->ver]){ \r\n                InsEdge(scc[i], scc[e->ver]); \r\n                } \r\n            } \r\n        } \r\n    // \r\n    maxv = sccer; \r\n    for (i=1; i<n+1; i++){ \r\n        int t; \r\n        scanf(\"%d\", &t); \r\n        w[scc[i]] += t; \r\n        } \r\n    // \r\n    int src; \r\n    scanf(\"%d\", &src); \r\n    src = scc[src]; \r\n    SPFA(src); \r\n    // \r\n    scanf(\"%d\", &m); \r\n    int ans = 0; \r\n    while (m--){ \r\n        int t; \r\n        scanf(\"%d\", &t); \r\n        t = scc[t]; \r\n        ans = gmax(ans, dis[t]); \r\n        } \r\n    ans += w[src]; \r\n    printf(\"%d\\n\", ans); \r\n      \r\n    // \r\n   // fclose(stdin); \r\n   // fclose(stdout); \r\n      \r\n    return 0; \r\n    }'),(292,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define INF 0x7FFFFFFF\r\n#define gmax(a,b) ((a)>(b)?(a):(b))\r\n#define gmin(a,b) ((a)<(b)?(a):(b))\r\n#define fill(a,b) memset(a,b,sizeof(a))\r\n#define MAXV 600000\r\n#define MAXE 600000\r\n\r\n\r\ntypedef struct Edge2{\r\n    int ver;\r\n    struct Edge2 *next;\r\n\r\n    }Edge;\r\n\r\nvoid SetData( Edge *P ,int V,  Edge *N)\r\n{\r\n	P->ver = V;\r\n	P->next = N;\r\n}\r\nEdge edgepool[MAXE << 1];\r\nint edger;\r\nEdge *onet[MAXV];\r\nEdge *net[MAXV];\r\nint dis[MAXV];\r\nint Q[MAXV];\r\nint inQ[MAXV];\r\nint w[MAXV];\r\nint maxv;\r\nint n, m;\r\nint sccer;\r\nint scc[MAXV];\r\nint dfn[MAXV];\r\nint low[MAXV];\r\nint dfner;\r\nint S[MAXV];\r\nint inS[MAXV];\r\nint g[MAXV];\r\n\r\nvoid SPFA(int src){\r\n    for (int i=1; i<maxv+1; i++){\r\n        dis[i] = 0;\r\n        }\r\n    fill(inQ, 0);\r\n    int head, tail;\r\n    head = tail = 0;\r\n    dis[src] = 0;\r\n    if (++tail == maxv)\r\n        tail = 0;\r\n    Q[tail] = src;\r\n    inQ[src] = 1;\r\n    while (head != tail){\r\n        if (++head == maxv)\r\n            head = 0;\r\n        int u = Q[head];\r\n        inQ[u] = 0;\r\n        for (Edge *e=net[u]; e; e=e->next){\r\n            if (dis[e->ver] < dis[u] + w[e->ver]){\r\n                dis[e->ver] = dis[u] + w[e->ver];\r\n                if (!inQ[e->ver]){\r\n                    if (++tail == maxv)\r\n                        tail = 0;\r\n                    Q[tail] = e->ver;\r\n                    inQ[e->ver] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nvoid InsOEdge(int u, int v){\r\n    SetData(&edgepool[++edger],v,onet[u]);\r\n    onet[u] = &edgepool[edger];\r\n    }\r\n\r\nvoid InsEdge(int u, int v){\r\n    SetData(&edgepool[++edger],v, net[u]);\r\n    net[u] = &edgepool[edger];\r\n    }\r\n\r\nvoid DfsSCC(int u){\r\n    dfn[u] = low[u] = ++dfner;\r\n    S[++S[0]] = u;\r\n    inS[u] = 1;\r\n    for (Edge *e=onet[u]; e; e=e->next){\r\n        if (!dfn[e->ver]){\r\n            DfsSCC(e->ver);\r\n            low[u] = gmin(low[u], low[e->ver]);\r\n            }\r\n        else\r\n        if (inS[e->ver]){\r\n            low[u] = gmin(low[u], dfn[e->ver]);\r\n            }\r\n        }\r\n    //\r\n    if (low[u] == dfn[u]){\r\n        sccer++;\r\n        while (1){\r\n            int t = S[S[0]--];\r\n            inS[t] = 0;\r\n            scc[t] = sccer;\r\n            if (t == u)\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\nint main(){\r\n    \r\n  //  freopen(\"atm.in\", \"r\", stdin);\r\n  //  freopen(\"atm.out\", \"w\", stdout);\r\n    \r\n    int i;\r\n    scanf(\"%d %d\", &n, &m);\r\n    while (m--){\r\n        int u, v;\r\n        scanf(\"%d %d\", &u, &v);\r\n        InsOEdge(u, v);\r\n        }\r\n    //\r\n    fill(dfn, 0);\r\n    fill(scc, 0);\r\n    dfner = sccer = 0;\r\n    for (i=1; i<n+1; i++){\r\n        if (!dfn[i])\r\n            DfsSCC(i);\r\n        }\r\n    for (i=1; i<n+1; i++){\r\n        for (Edge *e=onet[i]; e; e=e->next){\r\n            if (scc[i] != scc[e->ver]){\r\n                InsEdge(scc[i], scc[e->ver]);\r\n                }\r\n            }\r\n        }\r\n    //\r\n    maxv = sccer;\r\n    for (i=1; i<n+1; i++){\r\n        int t;\r\n        scanf(\"%d\", &t);\r\n        w[scc[i]] += t;\r\n        }\r\n    //\r\n    int src;\r\n    scanf(\"%d\", &src);\r\n    src = scc[src];\r\n    SPFA(src);\r\n    //\r\n    scanf(\"%d\", &m);\r\n    int ans = 0;\r\n    while (m--){\r\n        int t;\r\n        scanf(\"%d\", &t);\r\n        t = scc[t];\r\n        ans = gmax(ans, dis[t]);\r\n        }\r\n    ans += w[src];\r\n    printf(\"%d\\n\", ans);\r\n    \r\n    //\r\n   // fclose(stdin);\r\n   // fclose(stdout);\r\n    \r\n    return 0;\r\n    }\r\n\r\n'),(293,'#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* List of ASCII characters representing chess pieces for side 0 and side 1 */\nconst string PIECE[2] = { \"kqbrn\", \"KQBRN\" };\n\n/* Enumerated type indexing either side\'s PIECE[0] or PIECE[1] string */\nenum { KING, QUEEN, BISHOP, ROOK, KNIGHT };\n\n/* Structure encoding possible movement types for each piece */\ntypedef struct {\n    bool free;     /* True for rook/bishop/queen which move multiple spaces */\n    int count;     /* Number of valid entries in the following dir[] array */\n    int dir[8][2]; /* Array of (row, col) allowed movement directions */\n} movement_t;\n\n/*\n * Movement definitions for each piece. These are in the same order as the\n * PIECE strings, so they can be indexed by the enumerated type. By using a\n * data structure like this, the movement definitions can be shared by both\n * the ischecked() and ismate() functions.\n */\nconst movement_t MOVEMENT[] = {\n  /* KING */\n  { false, 8, { {-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1} } },\n  \n  /* QUEEN */\n  { true, 8,  { {-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1} } },\n\n  /* BISHOP */\n  { true, 4,  { {-1,-1},{-1,1},{1,-1},{1,1} } },\n\n  /* ROOK */\n  { true, 4,  { {-1,0},{0,-1},{0,1},{1,0} } },\n\n  /* KNIGHT */\n  { false, 8, { {-2,-1},{-2,1},{-1,-2},{-1,2},{2,-1},{2,1},{1,-2},{1,2} } }\n};\n\n/* Array holding the chess board layout for the current data set */\nchar board[8][8];\n\n/* Either 0 or 1 depending on which side gets analyzed for current data set */\nint side;\n\n/* Row and column containing the king piece to be analyzed in this data set */\nint kingrow = -1, kingcol = -1;\n\n/* Return true if coordinate pair (row, col) is within chess board area */\ninline bool isinside(int row, int col)\n{\n    return row >= 0 && row < 8 && col >= 0 && col < 8;\n}\n\n#ifdef STEP\n/* DEBUG ONLY: Print chess board to stderr along with row and column headings */\nvoid dump(void)\n{\n  cerr << \" 01234567\" << endl;\n  \n  for(int row = 0; row < 8; row++) {  \n      cerr << row;\n      \n      for(int col = 0; col < 8; col++) {\n          cerr << board[row][col];\n      }\n      \n      cerr << endl;\n  }\n}\n#endif\n\n/*\n * Detect if this side\'s current king is in check by searching all the possible\n * locations around the king for pieces that could possibly threaten the king.\n * Starting with the king\'s current position (kingrow, kingcol) seach all the\n * positions around him from which an enemy piece could threaten based on the\n * movement directions defined in the MOVEMENT array. If an enemy piece is\n * found which can threaten the king in the specified movement direction, then\n * return true since the king is checked. If any other piece (from either side)\n * is found along the specified movement direction found, then return false\n * since this other piece will block any enemy pieces on the other side from\n * possibly threatening the king. Likewise return false if no pieces are found\n * along any of the directions that the king could be threatened from.\n */\nbool ischecked(void)\n{\n    bool checked = false;\n\n#ifdef STEP\n    dump();\n#endif\n\n    /* Check for each enemy piece that could threaten the king */\n    for(int piece = 0; piece < 5; piece++) {\n        const char ascii = PIECE[!side][piece];\n        const movement_t &move = MOVEMENT[piece];\n\n        /* Search in each direction from which this piece could threaten */\n        for(int dir = 0; dir < move.count; dir++) {\n            int row = kingrow, col = kingcol;\n\n            do {\n                /* Advance search location by current direction */\n                row += move.dir[dir][0];\n                col += move.dir[dir][1];\n\n                /* Abort this direction if location is past board edge */\n                if(!isinside(row, col)) {\n                    break;\n                }\n\n                /* Detect if the threatening piece was found */\n                if(board[row][col] == ascii) {\n#ifdef STEP\n                    cerr << ascii << \" @ \" << row << \",\" << col << endl;\n#endif\n                    checked = true;\n                    break;\n                }\n\n                /* Other pieces block further threats from this direction */\n                if(board[row][col] != \'.\') {\n                    break;\n                }\n\n            /*\n             * A rook, bishop, or queen can move multiple spaces in the same\n             * direction so keep searching until either the edge of the board\n             * is reached, the threatening piece was found, or some other piece\n             * was found that blocks any further threats from that direction.\n             */\n            } while(move.free);\n        }\n    }\n\n    return checked;\n}\n\nbool ismate(void)\n{\n    bool mate = true;\n\n    /* Search the board for a piece to try moving */\n    for(int row = 0; row < 8; row++) {\n        for(int col = 0; col < 8; col++) {\n            int piece = PIECE[side].find(board[row][col]);\n            \n            /* If our side\'s piece has been found try moving it around */\n            if(piece != -1) {\n                const char ascii = PIECE[side][piece];\n                const movement_t &move = MOVEMENT[piece];\n\n                /* Try moving in all directions allowed by this piece */\n                for(int dir = 0; dir < move.count; dir++) {\n                    int newrow = row, newcol = col;\n                    char oldpiece;\n\n                    do {\n                        /* Advance search location by current direction */\n                        newrow += move.dir[dir][0];\n                        newcol += move.dir[dir][1];\n\n                        /* Abort this direction if location past board edge */\n                        if(!isinside(newrow, newcol)) {\n                            break;\n                        }\n\n                        /* Other friendly pieces block further movement */\n                        if(PIECE[side].find(board[newrow][newcol]) != -1) {\n                            break;\n                        }\n                        \n                        /* Enemy kings block movement; they can\'t be captured */\n                        if(board[newrow][newcol] == PIECE[!side][KING]) {\n                            break;\n                        }\n\n                        /*\n                         * Move piece to new location; if an enemy piece already\n                         * occupies the new location, it will be captured (i.e.\n                         * removed from the board) so a temporary copy of the\n                         * captured enemy piece is saved in \"oldpiece\".\n                         */\n                        oldpiece = board[newrow][newcol];\n                        board[newrow][newcol] = ascii;\n                        board[row][col] = \'.\';\n                        \n                        /* If the king was moved, update his coordinates */\n                        if(piece == KING) {\n                            kingrow = newrow;\n                            kingcol = newcol;\n                        }\n#ifdef STEP\n                        cerr << endl << ascii << \" @ \" << row << \",\" << col;\n                        cerr << \" --> \" << newrow << \",\" << newcol << endl;\n#endif\n                        /* Determine if the king is in check after this move */\n                        mate &= ischecked();\n\n                        /*\n                         * Restore the piece to its previous location and\n                         * restore any enemy piece that was captured by this\n                         * piece.\n                         */\n                        board[newrow][newcol] = oldpiece;\n                        board[row][col] = ascii;\n\n                        /* If the king was moved, restore his coordinates */\n                        if(piece == KING) {\n                            kingrow = row;\n                            kingcol = col;\n                        }\n\n                    /*\n                     * A rook, bishop, or queen can move multiple spaces in the\n                     * same direction until either the edge of the board is\n                     * reached or an enemy piece was captured (i.e. oldpiece is\n                     * not an empty \'.\' square).\n                     */\n                    } while(move.free && oldpiece == \'.\');\n                }\n            }\n        }\n    }\n    \n    return mate;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        bool check = false, mate = false;\n            \n        /* Read in which side (white or black) to analyze */\n        char c;\n        cin >> c;\n        ASSERT(c == \'w\' || c == \'B\');\n        side = (c == \'w\') ? 0 : 1;\n\n        /* Reset the king\'s cooridante position for each data set */\n        kingrow = -1;\n        kingcol = -1;\n        \n        /* Read in the chess board layout */\n        for(int row = 0; row < 8; row++) {\n            for(int col = 0; col < 8; col++) {\n                char &c = board[row][col];            \n                cin >> c;\n                \n                /* Check for location of the king for the side we\'re analyzing */\n                if(c == PIECE[side][KING]) {\n                \n                    /* SANITY CHECK: Make sure only one king was found */\n                    ASSERT(kingrow == -1 && kingcol == -1);\n                    \n                    kingrow = row;\n                    kingcol = col;\n                }\n            }\n        }\n        \n        /* SANITY CHECK: Make sure that a king was found */\n        ASSERT(kingrow != -1 && kingcol != -1);\n\n        /* Detect a check and checkmate condition */\n        check = ischecked();\n        mate = ismate();\n\n        /* Print the result */\n        cout << (side ? \"BLACK\" : \"WHITE\") << \" IS \";\n        cout << (mate ? \"CHECKMATED\" : (check ? \"CHECKED\" : \"SAFE\")) << endl;\n#ifdef STEP\n        cerr << (side ? \"BLACK\" : \"WHITE\") << \" IS \";\n        cerr << (mate ? \"CHECKMATED\" : (check ? \"CHECKED\" : \"SAFE\")) << endl;\n#endif\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(294,'#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* List of ASCII characters representing chess pieces for side 0 and side 1 */\nconst string PIECE[2] = { \"kqbrn\", \"KQBRN\" };\n\n/* Enumerated type indexing either side\'s PIECE[0] or PIECE[1] string */\nenum { KING, QUEEN, BISHOP, ROOK, KNIGHT };\n\n/* Structure encoding possible movement types for each piece */\ntypedef struct {\n    bool free;     /* True for rook/bishop/queen which move multiple spaces */\n    int count;     /* Number of valid entries in the following dir[] array */\n    int dir[8][2]; /* Array of (row, col) allowed movement directions */\n} movement_t;\n\n/*\n * Movement definitions for each piece. These are in the same order as the\n * PIECE strings, so they can be indexed by the enumerated type. By using a\n * data structure like this, the movement definitions can be shared by both\n * the ischecked() and ismate() functions.\n */\nconst movement_t MOVEMENT[] = {\n  /* KING */\n  { false, 8, { {-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1} } },\n  \n  /* QUEEN */\n  { true, 8,  { {-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1} } },\n\n  /* BISHOP */\n  { true, 4,  { {-1,-1},{-1,1},{1,-1},{1,1} } },\n\n  /* ROOK */\n  { true, 4,  { {-1,0},{0,-1},{0,1},{1,0} } },\n\n  /* KNIGHT */\n  { false, 8, { {-2,-1},{-2,1},{-1,-2},{-1,2},{2,-1},{2,1},{1,-2},{1,2} } }\n};\n\n/* Array holding the chess board layout for the current data set */\nchar board[8][8];\n\n/* Either 0 or 1 depending on which side gets analyzed for current data set */\nint side;\n\n/* Row and column containing the king piece to be analyzed in this data set */\nint kingrow = -1, kingcol = -1;\n\n/* Return true if coordinate pair (row, col) is within chess board area */\ninline bool isinside(int row, int col)\n{\n    return row >= 0 && row < 8 && col >= 0 && col < 8;\n}\n\n#ifdef STEP\n/* DEBUG ONLY: Print chess board to stderr along with row and column headings */\nvoid dump(void)\n{\n  cerr << \" 01234567\" << endl;\n  \n  for(int row = 0; row < 8; row++) {  \n      cerr << row;\n      \n      for(int col = 0; col < 8; col++) {\n          cerr << board[row][col];\n      }\n      \n      cerr << endl;\n  }\n}\n#endif\n\n/*\n * Detect if this side\'s current king is in check by searching all the possible\n * locations around the king for pieces that could possibly threaten the king.\n * Starting with the king\'s current position (kingrow, kingcol) seach all the\n * positions around him from which an enemy piece could threaten based on the\n * movement directions defined in the MOVEMENT array. If an enemy piece is\n * found which can threaten the king in the specified movement direction, then\n * return true since the king is checked. If any other piece (from either side)\n * is found along the specified movement direction found, then return false\n * since this other piece will block any enemy pieces on the other side from\n * possibly threatening the king. Likewise return false if no pieces are found\n * along any of the directions that the king could be threatened from.\n */\nbool ischecked(void)\n{\n    bool checked = false;\n\n#ifdef STEP\n    dump();\n#endif\n\n    /* Check for each enemy piece that could threaten the king */\n    for(int piece = 0; piece < 5; piece++) {\n        const char ascii = PIECE[!side][piece];\n        const movement_t &move = MOVEMENT[piece];\n\n        /* Search in each direction from which this piece could threaten */\n        for(int dir = 0; dir < move.count; dir++) {\n            int row = kingrow, col = kingcol;\n\n            do {\n                /* Advance search location by current direction */\n                row += move.dir[dir][0];\n                col += move.dir[dir][1];\n\n                /* Abort this direction if location is past board edge */\n                if(!isinside(row, col)) {\n                    break;\n                }\n\n                /* Detect if the threatening piece was found */\n                if(board[row][col] == ascii) {\n#ifdef STEP\n                    cerr << ascii << \" @ \" << row << \",\" << col << endl;\n#endif\n                    checked = true;\n                    break;\n                }\n\n                /* Other pieces block further threats from this direction */\n                if(board[row][col] != \'.\') {\n                    break;\n                }\n\n            /*\n             * A rook, bishop, or queen can move multiple spaces in the same\n             * direction so keep searching until either the edge of the board\n             * is reached, the threatening piece was found, or some other piece\n             * was found that blocks any further threats from that direction.\n             */\n            } while(move.free);\n        }\n    }\n\n    return checked;\n}\n\nbool ismate(void)\n{\n    bool mate = true;\n\n    /* Search the board for a piece to try moving */\n    for(int row = 0; row < 8; row++) {\n        for(int col = 0; col < 8; col++) {\n            int piece = PIECE[side].find(board[row][col]);\n            \n            /* If our side\'s piece has been found try moving it around */\n            if(piece != -1) {\n                const char ascii = PIECE[side][piece];\n                const movement_t &move = MOVEMENT[piece];\n\n                /* Try moving in all directions allowed by this piece */\n                for(int dir = 0; dir < move.count; dir++) {\n                    int newrow = row, newcol = col;\n                    char oldpiece;\n\n                    do {\n                        /* Advance search location by current direction */\n                        newrow += move.dir[dir][0];\n                        newcol += move.dir[dir][1];\n\n                        /* Abort this direction if location past board edge */\n                        if(!isinside(newrow, newcol)) {\n                            break;\n                        }\n\n                        /* Other friendly pieces block further movement */\n                        if(PIECE[side].find(board[newrow][newcol]) != -1) {\n                            break;\n                        }\n                        \n                        /* Enemy kings block movement; they can\'t be captured */\n                        if(board[newrow][newcol] == PIECE[!side][KING]) {\n                            break;\n                        }\n\n                        /*\n                         * Move piece to new location; if an enemy piece already\n                         * occupies the new location, it will be captured (i.e.\n                         * removed from the board) so a temporary copy of the\n                         * captured enemy piece is saved in \"oldpiece\".\n                         */\n                        oldpiece = board[newrow][newcol];\n                        board[newrow][newcol] = ascii;\n                        board[row][col] = \'.\';\n                        \n                        /* If the king was moved, update his coordinates */\n                        if(piece == KING) {\n                            kingrow = newrow;\n                            kingcol = newcol;\n                        }\n#ifdef STEP\n                        cerr << endl << ascii << \" @ \" << row << \",\" << col;\n                        cerr << \" --> \" << newrow << \",\" << newcol << endl;\n#endif\n                        /* Determine if the king is in check after this move */\n                        mate &= ischecked();\n\n                        /*\n                         * Restore the piece to its previous location and\n                         * restore any enemy piece that was captured by this\n                         * piece.\n                         */\n                        board[newrow][newcol] = oldpiece;\n                        board[row][col] = ascii;\n\n                        /* If the king was moved, restore his coordinates */\n                        if(piece == KING) {\n                            kingrow = row;\n                            kingcol = col;\n                        }\n\n                    /*\n                     * A rook, bishop, or queen can move multiple spaces in the\n                     * same direction until either the edge of the board is\n                     * reached or an enemy piece was captured (i.e. oldpiece is\n                     * not an empty \'.\' square).\n                     */\n                    } while(move.free && oldpiece == \'.\');\n                }\n            }\n        }\n    }\n    \n    return mate;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        bool check = false, mate = false;\n            \n        /* Read in which side (white or black) to analyze */\n        char c;\n        cin >> c;\n        ASSERT(c == \'w\' || c == \'B\');\n        side = (c == \'w\') ? 0 : 1;\n\n        /* Reset the king\'s cooridante position for each data set */\n        kingrow = -1;\n        kingcol = -1;\n        \n        /* Read in the chess board layout */\n        for(int row = 0; row < 8; row++) {\n            for(int col = 0; col < 8; col++) {\n                char &c = board[row][col];            \n                cin >> c;\n                \n                /* Check for location of the king for the side we\'re analyzing */\n                if(c == PIECE[side][KING]) {\n                \n                    /* SANITY CHECK: Make sure only one king was found */\n                    ASSERT(kingrow == -1 && kingcol == -1);\n                    \n                    kingrow = row;\n                    kingcol = col;\n                }\n            }\n        }\n        \n        /* SANITY CHECK: Make sure that a king was found */\n        ASSERT(kingrow != -1 && kingcol != -1);\n\n        /* Detect a check and checkmate condition */\n        check = ischecked();\n        mate = ismate();\n\n        /* Print the result */\n        cout << (side ? \"BLACK\" : \"WHITE\") << \" IS \";\n        cout << (mate ? \"CHECKMATED\" : (check ? \"CHECKED\" : \"SAFE\")) << endl;\n#ifdef STEP\n        cerr << (side ? \"BLACK\" : \"WHITE\") << \" IS \";\n        cerr << (mate ? \"CHECKMATED\" : (check ? \"CHECKED\" : \"SAFE\")) << endl;\n#endif\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(295,'#include <functional>\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, the intermediate state of the disk after\n * each step of the defrag pass is printed to stderr.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* A single extent represented as a (block, count) tuple. */\ntypedef pair<int, int> ext_t;\ntypedef vector<ext_t> extlist_t;\n\n/* Representation of a single file in the data set */\ntypedef struct {\n  string name;           /* File name from data set */\n  bool immobile;         /* True if file is immobile */\n  int size;              /* Size in blocks of file (not including metadata) */\n  int defrag;            /* How many defrag passes has this file been through */\n  int print;             /* Number times printed (see output() function) */\n  vector<ext_t> extlist; /* List of extents for this file */\n} file_t;\n\n/*\n * The extent map tracks all the currently allocated blocks on disk. Individual\n * extents are the keys and they map to the actual file_t structures that own\n * the extent. Since STL maps are sorted, we can use one in ascending order and\n * one in descending to determine the order in which files are processed during\n * the two defrag steps.\n */\ntypedef map<ext_t, file_t *, bool (*)(ext_t const &,ext_t const &)> extmap_t;\n\n/* Comparison functions for the two extent maps */\nbool ascending(ext_t const &a, ext_t const &b)\n{\n    return a.first < b.first;\n}\nbool descending(ext_t const &a, ext_t const &b)\n{\n    return a.second > b.second;\n}\n\n/*\n * Print info about all the files on disk. Files are printed in the order that\n * their first extent appears in \"first\". As each file is printed, its \"print\"\n * flag is incremented so that if we find another extend in \"first\" that belongs\n * to this file, then we skip printing that file during this print pass. The\n * extent list for each file is also sorted in ascending order.\n */\nvoid output(ostream &out, extmap_t &first)\n{\n    static int print_count = 0;\n    extmap_t::iterator i;\n    extlist_t::iterator j;\n\n    print_count++;\n          \n    for(i = first.begin(); i != first.end(); ++i) {\n        file_t &file = *i->second;\n        \n        /* Print each file only once per output() call */\n        if(file.print == print_count)\n            continue;        \n        file.print = print_count;\n        \n        out << file.name << (file.immobile ? \" I \" : \" M \");\n        out << file.extlist.size();\n                \n        /* Print the extent list in numerically ascending order */\n        sort(file.extlist.begin(), file.extlist.end());        \n        for(j = file.extlist.begin(); j != file.extlist.end(); ++j) {\n            out << \" \" << j->first << \"-\" << j->second;\n        }\n        \n        out << endl;\n    }    \n}\n\n/*\n * These are helper functions for use by the generic find_free(). Depending on\n * which order we iterate over the *used* extents, these helpers compute and\n * return the size of the *free* extent that is found between the currently\n * allocated \"prev\" and \"next\" extents.\n */\ntypedef ext_t (*free_helper_t)(ext_t, ext_t);\next_t first_free(ext_t prev, ext_t next)\n{\n    return ext_t(prev.second + 1, next.first - 1);\n}\next_t last_free(ext_t prev, ext_t next)\n{\n    return ext_t(next.second + 1, prev.first - 1);\n}\n\n/*\n * These helper functions are for use by defrag() to align \"size\" blocks either\n * to the front of or the back of the available \"free\" extent. Here \"size\" does\n * not include the metadata so these functions account for it.\n */\ntypedef ext_t (*alloc_helper_t)(ext_t, int);\next_t to_front(ext_t free, int size)\n{\n    return ext_t(free.first, free.first + size);\n}\next_t to_back(ext_t free, int size)\n{\n    return ext_t(free.second - size, free.second);\n}\n\n/*\n * Using the sort ordering of the extent map \"extmap\", find the first or last\n * available extent on the disk that is big enough to hold a file \"size\"\n * blocks long. The \"size\" parameter does not include metadata so this\n * function takes it into account. Return \"true\" if an available extent was\n * found, in which case \"free\" will contain the available extent.\n *\n * The \"initial\" and \"final\" arguments are needed to find the gaps at the very\n * beginning and end of the disk (if N is the number of used extends, there\n * could be N - 1, N, or N + 1 free extents *betweem* the used extents).\n *\n * The \"helper\" function returns an extent representing the free space between\n * the two already allocated extents \"prev\" and \"next\".\n */\nbool find_free(extmap_t &extmap, free_helper_t helper,\n    ext_t initial, ext_t final, ext_t &free, int size)\n{   \n    extmap_t::iterator i = extmap.begin();\n    ext_t prev;\n    \n    for(prev = initial; i != extmap.end(); ++i) {\n        free = helper(prev, i->first);\n        if(free.second - free.first + 1 >= size + 1)\n            return true;        \n        prev = i->first;\n    }\n   \n    free = helper(prev, final);\n    if(free.second - free.first + 1 >= size + 1)\n        return true;\n       \n    return false;  \n}\n\n/*\n * Defragment the disk by picking files in order from \"first\" and putting them,\n * in order, into any free space found between the extents in \"last\". By calling\n * this function twice but with \"first\" and \"last\" reversed, we can do both\n * steps of a defragmentation pass. The \"defrag\" flag is incremented for\n * each file as we process it since \"first\" can have multiple extents for the\n * same file, but each file must be processed only once per step/pass.\n */\nvoid defrag(extmap_t &first, extmap_t &last, free_helper_t free_helper,\n    alloc_helper_t alloc_helper, ext_t initial, ext_t final)\n{\n    static int defrag_count = 0;\n    extmap_t::iterator i;\n    \n    defrag_count++;\n    \n    /* Defragment files in ascending order by their first blocks */\n    for(i = first.begin(); i != first.end(); ++i) {\n        file_t &file = *i->second;\n\n        /* Defrag each file only once per defrag() call */\n        if(file.defrag == defrag_count)\n            continue;        \n        file.defrag = defrag_count;\n\n        /* Do not attempt moving an immobile file */\n        if(file.immobile)\n            continue;\n\n        /*\n         * Search through the extents in reverse order and try to find an empty\n         * spot between allocated extents that\'s big enough to hold our file.\n         * If a free spot was found, move the file info the free spot by\n         * updating the file\'s own extent list and updating the \"last\" extent\n         * map to reflect the new allocation. Note that at this point we\n         * cannot update \"first\" yet because that would invalidate the iterator\n         * on it.\n         */\n        ext_t free;\n        if(find_free(last, free_helper, initial, final, free, file.size)) {\n            ext_t used = alloc_helper(free, file.size);\n            vector<ext_t>::iterator j;\n                \n            /* Release old file extents from the global \"last\" map */\n            for(j = file.extlist.begin(); j != file.extlist.end(); ++j) {\n                last.erase(*j);\n            }\n            \n            /* Allocate new single file extent into the global \"last\" map */\n            last[used] = &file;\n            \n            /* Update the file\'s own extent list */\n            file.extlist.clear();\n            file.extlist.push_back(used);\n        }\n    }\n    \n    /* Now we can rebuild \"first\" map by using the updated \"last\" map */\n    first.clear();\n    first.insert(last.begin(), last.end());\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {        \n        int file_idx, file_num;    /* Looping over filenames */\n        int ext_idx, ext_num;      /* Looping over file extents */\n        int pass_idx, pass_num;    /* Looping over defrag passes */\n        int size;                  /* Total size of disk in blocks */\n        int passes;                /* How many defrag passes to run */\n        vector<file_t> files;      /* Detailed info about each file */\n        extmap_t first(ascending); /* Extent map sorted by first block */\n        extmap_t last(descending); /* Extent map sorted by last block */\n        \n        /* Read total disk size */        \n        cin >> size;\n        ASSERT(2 <= size && size <= 100000);\n             \n        /*\n         * Read count of files and pre-populate \"files\" vector so that addresses\n         * to vector elements are guaranteed to not change because we\'ll do no\n         * further modifications to the vector.\n         */\n        cin >> file_num;\n        ASSERT(1 <= file_num && file_num <= 100);\n        files.resize(file_num);\n        \n        /* Read file info, fill in file_t structures, populate extent maps */   \n        for(file_idx = 0; file_idx < file_num; file_idx++) {\n            file_t &file = files[file_idx];\n            int ext_idx, ext_num;\n            char flag;\n            \n            file.defrag = 0;\n            file.print = 0;            \n            file.size = 0;\n            \n            cin >> file.name;\n            \n            cin >> flag;            \n            ASSERT(flag == \'M\' || flag == \'I\');\n            file.immobile = (flag == \'I\');\n            \n            /* Read number of extents and parse extent list */\n            cin >> ext_num;\n            ASSERT(1 <= ext_num && ext_num <= 20);            \n            for(ext_idx = 0; ext_idx < ext_num; ext_idx++) {\n                char dummy;     /* To skip over the \'-\' character */\n                ext_t ext;\n                \n                cin >> ext.first >> dummy >> ext.second;\n                ASSERT(1 <= ext.first && ext.first <= size);\n                ASSERT(1 <= ext.second && ext.second <= size);\n                ASSERT(ext.first <= ext.second);\n                \n                file.extlist.push_back(ext);\n                file.size += ext.second - ext.first;\n\n                first[ext] = &file;\n                last[ext] = &file;\n            }\n        }\n        \n        /* Print the data set label */\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n#ifdef DEBUG\n        cerr << \"\\nDATA SET #\" << data_idx + 1 << endl;\n        cerr << \"Initial layout:\" << endl;\n        output(cerr, first);\n#endif\n       \n        /* Perform the requested number of defrag passes */\n        cin >> pass_num;\n        ASSERT(1 <= pass_num && pass_num <= 100);\n        for(pass_idx = 0; pass_idx < pass_num; pass_idx++) {\n\n            defrag(first, last, last_free, to_back,\n                ext_t(size + 1, 0), ext_t(0, 0));\n#ifdef DEBUG\n            cerr << \"\\nPass \" << pass_idx + 1 << \" (to the back):\" << endl;\n            output(cerr, first);\n#endif\n\n            defrag(last, first, first_free, to_front,\n                ext_t(0, 0), ext_t(size + 1, 0));\n#ifdef DEBUG\n            cerr << \"\\nPass \" << pass_idx + 1 << \" (to the front):\" << endl;\n            output(cerr, first);\n#endif\n        }\n        \n        /* Print the final disk layout */\n        output(cout, first);\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(296,'#include <functional>\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, the intermediate state of the disk after\n * each step of the defrag pass is printed to stderr.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* A single extent represented as a (block, count) tuple. */\ntypedef pair<int, int> ext_t;\ntypedef vector<ext_t> extlist_t;\n\n/* Representation of a single file in the data set */\ntypedef struct {\n  string name;           /* File name from data set */\n  bool immobile;         /* True if file is immobile */\n  int size;              /* Size in blocks of file (not including metadata) */\n  int defrag;            /* How many defrag passes has this file been through */\n  int print;             /* Number times printed (see output() function) */\n  vector<ext_t> extlist; /* List of extents for this file */\n} file_t;\n\n/*\n * The extent map tracks all the currently allocated blocks on disk. Individual\n * extents are the keys and they map to the actual file_t structures that own\n * the extent. Since STL maps are sorted, we can use one in ascending order and\n * one in descending to determine the order in which files are processed during\n * the two defrag steps.\n */\ntypedef map<ext_t, file_t *, bool (*)(ext_t const &,ext_t const &)> extmap_t;\n\n/* Comparison functions for the two extent maps */\nbool ascending(ext_t const &a, ext_t const &b)\n{\n    return a.first < b.first;\n}\nbool descending(ext_t const &a, ext_t const &b)\n{\n    return a.second > b.second;\n}\n\n/*\n * Print info about all the files on disk. Files are printed in the order that\n * their first extent appears in \"first\". As each file is printed, its \"print\"\n * flag is incremented so that if we find another extend in \"first\" that belongs\n * to this file, then we skip printing that file during this print pass. The\n * extent list for each file is also sorted in ascending order.\n */\nvoid output(ostream &out, extmap_t &first)\n{\n    static int print_count = 0;\n    extmap_t::iterator i;\n    extlist_t::iterator j;\n\n    print_count++;\n          \n    for(i = first.begin(); i != first.end(); ++i) {\n        file_t &file = *i->second;\n        \n        /* Print each file only once per output() call */\n        if(file.print == print_count)\n            continue;        \n        file.print = print_count;\n        \n        out << file.name << (file.immobile ? \" I \" : \" M \");\n        out << file.extlist.size();\n                \n        /* Print the extent list in numerically ascending order */\n        sort(file.extlist.begin(), file.extlist.end());        \n        for(j = file.extlist.begin(); j != file.extlist.end(); ++j) {\n            out << \" \" << j->first << \"-\" << j->second;\n        }\n        \n        out << endl;\n    }    \n}\n\n/*\n * These are helper functions for use by the generic find_free(). Depending on\n * which order we iterate over the *used* extents, these helpers compute and\n * return the size of the *free* extent that is found between the currently\n * allocated \"prev\" and \"next\" extents.\n */\ntypedef ext_t (*free_helper_t)(ext_t, ext_t);\next_t first_free(ext_t prev, ext_t next)\n{\n    return ext_t(prev.second + 1, next.first - 1);\n}\next_t last_free(ext_t prev, ext_t next)\n{\n    return ext_t(next.second + 1, prev.first - 1);\n}\n\n/*\n * These helper functions are for use by defrag() to align \"size\" blocks either\n * to the front of or the back of the available \"free\" extent. Here \"size\" does\n * not include the metadata so these functions account for it.\n */\ntypedef ext_t (*alloc_helper_t)(ext_t, int);\next_t to_front(ext_t free, int size)\n{\n    return ext_t(free.first, free.first + size);\n}\next_t to_back(ext_t free, int size)\n{\n    return ext_t(free.second - size, free.second);\n}\n\n/*\n * Using the sort ordering of the extent map \"extmap\", find the first or last\n * available extent on the disk that is big enough to hold a file \"size\"\n * blocks long. The \"size\" parameter does not include metadata so this\n * function takes it into account. Return \"true\" if an available extent was\n * found, in which case \"free\" will contain the available extent.\n *\n * The \"initial\" and \"final\" arguments are needed to find the gaps at the very\n * beginning and end of the disk (if N is the number of used extends, there\n * could be N - 1, N, or N + 1 free extents *betweem* the used extents).\n *\n * The \"helper\" function returns an extent representing the free space between\n * the two already allocated extents \"prev\" and \"next\".\n */\nbool find_free(extmap_t &extmap, free_helper_t helper,\n    ext_t initial, ext_t final, ext_t &free, int size)\n{   \n    extmap_t::iterator i = extmap.begin();\n    ext_t prev;\n    \n    for(prev = initial; i != extmap.end(); ++i) {\n        free = helper(prev, i->first);\n        if(free.second - free.first + 1 >= size + 1)\n            return true;        \n        prev = i->first;\n    }\n   \n    free = helper(prev, final);\n    if(free.second - free.first + 1 >= size + 1)\n        return true;\n       \n    return false;  \n}\n\n/*\n * Defragment the disk by picking files in order from \"first\" and putting them,\n * in order, into any free space found between the extents in \"last\". By calling\n * this function twice but with \"first\" and \"last\" reversed, we can do both\n * steps of a defragmentation pass. The \"defrag\" flag is incremented for\n * each file as we process it since \"first\" can have multiple extents for the\n * same file, but each file must be processed only once per step/pass.\n */\nvoid defrag(extmap_t &first, extmap_t &last, free_helper_t free_helper,\n    alloc_helper_t alloc_helper, ext_t initial, ext_t final)\n{\n    static int defrag_count = 0;\n    extmap_t::iterator i;\n    \n    defrag_count++;\n    \n    /* Defragment files in ascending order by their first blocks */\n    for(i = first.begin(); i != first.end(); ++i) {\n        file_t &file = *i->second;\n\n        /* Defrag each file only once per defrag() call */\n        if(file.defrag == defrag_count)\n            continue;        \n        file.defrag = defrag_count;\n\n        /* Do not attempt moving an immobile file */\n        if(file.immobile)\n            continue;\n\n        /*\n         * Search through the extents in reverse order and try to find an empty\n         * spot between allocated extents that\'s big enough to hold our file.\n         * If a free spot was found, move the file info the free spot by\n         * updating the file\'s own extent list and updating the \"last\" extent\n         * map to reflect the new allocation. Note that at this point we\n         * cannot update \"first\" yet because that would invalidate the iterator\n         * on it.\n         */\n        ext_t free;\n        if(find_free(last, free_helper, initial, final, free, file.size)) {\n            ext_t used = alloc_helper(free, file.size);\n            vector<ext_t>::iterator j;\n                \n            /* Release old file extents from the global \"last\" map */\n            for(j = file.extlist.begin(); j != file.extlist.end(); ++j) {\n                last.erase(*j);\n            }\n            \n            /* Allocate new single file extent into the global \"last\" map */\n            last[used] = &file;\n            \n            /* Update the file\'s own extent list */\n            file.extlist.clear();\n            file.extlist.push_back(used);\n        }\n    }\n    \n    /* Now we can rebuild \"first\" map by using the updated \"last\" map */\n    first.clear();\n    first.insert(last.begin(), last.end());\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {        \n        int file_idx, file_num;    /* Looping over filenames */\n        int ext_idx, ext_num;      /* Looping over file extents */\n        int pass_idx, pass_num;    /* Looping over defrag passes */\n        int size;                  /* Total size of disk in blocks */\n        int passes;                /* How many defrag passes to run */\n        vector<file_t> files;      /* Detailed info about each file */\n        extmap_t first(ascending); /* Extent map sorted by first block */\n        extmap_t last(descending); /* Extent map sorted by last block */\n        \n        /* Read total disk size */        \n        cin >> size;\n        ASSERT(2 <= size && size <= 100000);\n             \n        /*\n         * Read count of files and pre-populate \"files\" vector so that addresses\n         * to vector elements are guaranteed to not change because we\'ll do no\n         * further modifications to the vector.\n         */\n        cin >> file_num;\n        ASSERT(1 <= file_num && file_num <= 100);\n        files.resize(file_num);\n        \n        /* Read file info, fill in file_t structures, populate extent maps */   \n        for(file_idx = 0; file_idx < file_num; file_idx++) {\n            file_t &file = files[file_idx];\n            int ext_idx, ext_num;\n            char flag;\n            \n            file.defrag = 0;\n            file.print = 0;            \n            file.size = 0;\n            \n            cin >> file.name;\n            \n            cin >> flag;            \n            ASSERT(flag == \'M\' || flag == \'I\');\n            file.immobile = (flag == \'I\');\n            \n            /* Read number of extents and parse extent list */\n            cin >> ext_num;\n            ASSERT(1 <= ext_num && ext_num <= 20);            \n            for(ext_idx = 0; ext_idx < ext_num; ext_idx++) {\n                char dummy;     /* To skip over the \'-\' character */\n                ext_t ext;\n                \n                cin >> ext.first >> dummy >> ext.second;\n                ASSERT(1 <= ext.first && ext.first <= size);\n                ASSERT(1 <= ext.second && ext.second <= size);\n                ASSERT(ext.first <= ext.second);\n                \n                file.extlist.push_back(ext);\n                file.size += ext.second - ext.first;\n\n                first[ext] = &file;\n                last[ext] = &file;\n            }\n        }\n        \n        /* Print the data set label */\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n#ifdef DEBUG\n        cerr << \"\\nDATA SET #\" << data_idx + 1 << endl;\n        cerr << \"Initial layout:\" << endl;\n        output(cerr, first);\n#endif\n       \n        /* Perform the requested number of defrag passes */\n        cin >> pass_num;\n        ASSERT(1 <= pass_num && pass_num <= 100);\n        for(pass_idx = 0; pass_idx < pass_num; pass_idx++) {\n\n            defrag(first, last, last_free, to_back,\n                ext_t(size + 1, 0), ext_t(0, 0));\n#ifdef DEBUG\n            cerr << \"\\nPass \" << pass_idx + 1 << \" (to the back):\" << endl;\n            output(cerr, first);\n#endif\n\n            defrag(last, first, first_free, to_front,\n                ext_t(0, 0), ext_t(size + 1, 0));\n#ifdef DEBUG\n            cerr << \"\\nPass \" << pass_idx + 1 << \" (to the front):\" << endl;\n            output(cerr, first);\n#endif\n        }\n        \n        /* Print the final disk layout */\n        output(cout, first);\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(297,'#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* An stream is an ordered list of floating point samples */\ntypedef vector<double> stream_t;\n\n/* A filter network consists of named filter equations */\ntypedef map<char, string> filterset_t;\n\n/* A collection of named input and output streams */\ntypedef map<char, stream_t> streamset_t;\n\n/*\n * Function prototypes for the recursive descent parser. The first argument is\n * a string buffer holding part of the equation still remaining to be parsed.\n * The other arguments are the samples and filter definitions as read in from\n * the input (or previously computed). Each of these functions returns a new\n * sample stream corresponding to the non-terminal symbol handled by the\n * function.\n */\nstream_t parse_sum(istringstream &, streamset_t &, filterset_t &, int);\nstream_t parse_term(istringstream &, streamset_t &, filterset_t &, int);\nstream_t parse_expr(istringstream &, streamset_t &, filterset_t &, int);\n\n/* Insertion operator prints out the individual samples in a stream */\nostream &operator<<(ostream &sout, stream_t const &data)\n{\n    for(int i = 0; i < data.size(); i++) {\n        sout << \" \" << (int) data[i];\n    }\n    \n    return sout;\n}\n\n/* Adding two streams together adds the individual samples */\nstream_t &operator+=(stream_t &a, stream_t const &b)\n{\n    transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());\n    return a;\n}\n\n/* Subtracting two streams subtracts the individual samples */\nstream_t &operator-=(stream_t &a, stream_t const &b)\n{\n    transform(a.begin(), a.end(), b.begin(), a.begin(), minus<double>());\n    return a;\n}\n\n/* Multiplying two streams together multiplies the individual samples */\nstream_t &operator*=(stream_t &a, stream_t const &b)\n{\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<double>());\n    return a;\n}\n\n/*\n * Return a new stream that is time-shifted by the specified offset. A positive\n * offset (i.e. forward in time) shifts the stream to the left with trailing\n * zeroes at the end. A negative offset (i.e. backward in time) shifts\n * the stream to the right with leading zeroes at the beginning. If the\n * absolute value of offset is larger than the number of available samples,\n * then the output vector will contain all zeroes.\n */\nstream_t shift(stream_t const &in, int offset)\n{\n    /* Initialize output vector with all zeroes */\n    stream_t out(in.size(), 0);\n    \n    /* Iterators which define the range copied from \"in\" stream to \"out\" */\n    stream_t::iterator outbegin = out.begin();\n    stream_t::const_iterator inbegin = in.begin();\n    stream_t::const_iterator inend = in.end();\n    \n    /* A positive (forward in time) offset gives trailing zeroes in \"out\" */\n    if(offset >= 0) {\n        inbegin += offset;\n    }\n    \n    /* A negative (bacward in time) offset gives leading zeroes in \"out\" */\n    else {\n        outbegin += -offset;\n        inend -= -offset;\n    }\n\n    /* If the offset it too large or too small, output will have all zeroes */\n    if(inbegin < inend) {\n        copy(inbegin, inend,outbegin);\n    }\n    \n    return out;\n}\n\n/*\n * If the samples for stream \"name\" have not already been computed and stored\n * in \"streams\", then compute them by parsing the appropriate equation in\n * \"filters\". This function uses a recursive descent parser to recognize the\n * filter equation grammer. The original grammar has to be slightly rewritten\n * to remove the ambigiuity associated with operator precedence. Below is\n * the modified grammar in Extended Backus-Naur Form (the __ symbol is left\n * out for clarity):\n *\n * EQUATION ::= STREAM \"=\" SUM\n * SUM      ::= TERM { SUMOPER TERM }*\n * TERM     ::= EXPR { MULOPER EXPR }*\n * EXPR     ::= VALUE | SAMPLE | \"(\" SUM \")\"\n * SUMOPER  ::= \"+\" | \"-\"\n * MULOPER  ::= \"*\"\n */\nvoid compute(char name, streamset_t &streams, filterset_t &filters,\n    int sample_num)\n{\n    /* SANITY CHECK: Detect undefined stream names */\n    ASSERT(streams.find(name) != streams.end() || filters.find(name) !=\n        filters.end())\n\n    /* SANITY CHECK: Detect feedback loops */\n    ASSERT(streams.find(name) == streams.end() || streams[name].size());\n\n    /* Do nothing if this stream has been already computed */\n    if(streams[name].size()) {\n        return;\n    }\n    \n    /* Parse this filter equation and compute its sample stream */\n    istringstream text(filters[name]);\n    stream_t value = parse_sum(text, streams, filters, sample_num);\n    ASSERT(text.eof());\n    \n    /* Round and clip the output samples to integers in the [0,255] range */\n    ASSERT(value.size() == sample_num);\n    for(int i = 0; i < sample_num; i++) {\n        int integer = (int) value[i];\n        \n        if(integer < 0) {\n            value[i] = 0;\n        }\n        else if(integer > 255) {\n            value[i] = 255;\n        }\n        else {\n            value[i] = integer;\n        }\n    }\n\n    /* Assign the computed stream to the stream set */\n    streams[name] = value;\n}\n\n/* Parse SUM ::= TERM { SUMOPER TERM }* */\nstream_t parse_sum(istringstream &text, streamset_t &streams,\n    filterset_t &filters, int sample_num)\n{\n    /* The left hand side expression must always be present */\n    stream_t result = parse_term(text, streams, filters, sample_num);\n\n    /* Look ahead one token into the input stream */\n    char oper;\n    text >> oper;\n    \n    /* Keep parsing as long as any \"+\" or \"-\" operators exist */\n    while(!text.eof()) {\n        ASSERT(!text.fail());\n \n        /* Add or subtract the right hand side expression */\n        if(oper == \'+\') {\n            result += parse_term(text, streams, filters, sample_num);\n        }\n        else if(oper == \'-\') {\n            result -= parse_term(text, streams, filters, sample_num);\n        }\n\n        /* Otherwise this is the end of the SUM non-terminal */\n        else {\n            text.putback(oper);            \n            break;\n        }\n\n        /* Look ahead one token into the input stream */\n        text >> oper;        \n    }\n\n    return result;\n}\n\n/* Parse TERM ::= EXPR { MULOPER EXPR }* */\nstream_t parse_term(istringstream &text, streamset_t &streams,\n    filterset_t &filters, int sample_num)\n{\n    /* The left hand side expression must always be present */\n    stream_t result = parse_expr(text, streams, filters, sample_num);\n    \n    /* Look ahead one token into the input stream */\n    char oper;\n    text >> oper;\n\n    /* Keep parsing as long as any \"*\" operators exist */\n    while(!text.eof()) {\n        ASSERT(!text.fail());\n\n        /* Multiply the result by the right hand side expression */\n        if(oper == \'*\') {\n            result *= parse_expr(text, streams, filters, sample_num);\n        }\n\n        /* Otherwise this is the end of the TERM non-terminal */\n        else {\n            text.putback(oper);\n            break;\n        }\n\n        /* Look ahead one token into the input stream */\n        text >> oper;\n    }\n   \n    return result;\n}\n\n/* Parse EXPR ::= VALUE | SAMPLE | \"(\" SUM \")\" */\nstream_t parse_expr(istringstream &text, streamset_t &streams,\n    filterset_t &filters, int sample_num)\n{\n    stream_t result;\n\n    /* Extract the next token from the input stream */\n    string token;\n    text >> token;\n    ASSERT(!text.fail());\n   \n    /* An opening parenthesis signals the start of a nested sub expression */\n    if(token == \"(\") {\n        result = parse_sum(text, streams, filters, sample_num);\n\n        /* Match the closing parenthesis */\n        char oper;        \n        text >> oper;        \n        ASSERT(!text.fail());\n        ASSERT(oper == \')\');\n    }\n    \n    /* An uppercase letter signals a sample definition of the form \"X[N]\" */\n    else if(isupper(token[0])) {\n        istringstream str(token);\n        char name, dummy1, dummy2;\n        int offset;\n        \n        str >> name >> dummy1 >> offset >> dummy2;\n        ASSERT(dummy1 == \'[\' && dummy2 == \']\');\n        ASSERT(offset >= -100 && offset <= 100);\n        ASSERT(!str.fail() && !(str >> dummy1));\n\n        /* Ensure the requested input stream has been calculated already */\n        compute(name, streams, filters, sample_num);\n\n        /* Return a time-shifted version of the requested input stream */\n        result = shift(streams[name], offset);\n    }\n    \n    /* Otherwise this token must be a floating point constant */\n    else {\n        istringstream str(token);\n        double value;\n        char dummy;\n        \n        str >> value;\n        ASSERT(!str.fail() && !(str >> dummy));\n\n        /* Return a sample stream initialized to the floating point constant */\n        result = stream_t(sample_num, value);\n    }\n    \n    return result;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        int sample_num, input_num, input_idx;\n        streamset_t streams;\n        filterset_t filters;\n        \n        /* Read in the number of streams and samples */\n        cin >> input_num >> sample_num;\n        \n        /* Read in each of the stream definitions */\n        for(input_idx = 0; input_idx < input_num; input_idx++) {\n            char name, oper;\n            int sample_idx;\n            \n            /* Read in the stream name and % or = operator */\n            cin >> name >> oper;\n            ASSERT(name >= \'A\' && name <= \'Z\');\n            ASSERT(oper == \'%\' || oper == \'=\');\n\n            /* SANITY CHECK: Check for duplicate stream definitions */\n            ASSERT(filters.find(name) == filters.end());\n            ASSERT(streams.find(name) == streams.end());\n            \n            /* A % operator is an input stream */\n            if(oper == \'%\') {\n                for(sample_idx = 0; sample_idx < sample_num; sample_idx++) {\n                    int sample;\n                                \n                    cin >> sample;\n                    ASSERT(sample >= 0 && sample <= 255);\n                    \n                    streams[name].push_back(sample);\n                }\n            }\n            \n            /* A = operator is a filter definition */\n            else {\n                string filter;                \n                getline(cin, filter);\n                filters[name] = filter;\n            }\n        }\n\n        /* SANITY CHECK: Need at least one input and output stream */\n        ASSERT(filters.size() && streams.size());\n\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n        \n        /*\n         * Compute and print out the samples in each output stream. The STL map\n         * in filterset_t guarantees the filter names are already sorted in\n         * alphabetical order.\n         */\n        filterset_t::iterator i;\n        for(i = filters.begin(); i != filters.end(); ++i) {\n            compute(i->first, streams, filters, sample_num);\n            cout << i->first << \" %\" << streams[i->first] << endl;\n        }\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(298,'#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* An stream is an ordered list of floating point samples */\ntypedef vector<double> stream_t;\n\n/* A filter network consists of named filter equations */\ntypedef map<char, string> filterset_t;\n\n/* A collection of named input and output streams */\ntypedef map<char, stream_t> streamset_t;\n\n/*\n * Function prototypes for the recursive descent parser. The first argument is\n * a string buffer holding part of the equation still remaining to be parsed.\n * The other arguments are the samples and filter definitions as read in from\n * the input (or previously computed). Each of these functions returns a new\n * sample stream corresponding to the non-terminal symbol handled by the\n * function.\n */\nstream_t parse_sum(istringstream &, streamset_t &, filterset_t &, int);\nstream_t parse_term(istringstream &, streamset_t &, filterset_t &, int);\nstream_t parse_expr(istringstream &, streamset_t &, filterset_t &, int);\n\n/* Insertion operator prints out the individual samples in a stream */\nostream &operator<<(ostream &sout, stream_t const &data)\n{\n    for(int i = 0; i < data.size(); i++) {\n        sout << \" \" << (int) data[i];\n    }\n    \n    return sout;\n}\n\n/* Adding two streams together adds the individual samples */\nstream_t &operator+=(stream_t &a, stream_t const &b)\n{\n    transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());\n    return a;\n}\n\n/* Subtracting two streams subtracts the individual samples */\nstream_t &operator-=(stream_t &a, stream_t const &b)\n{\n    transform(a.begin(), a.end(), b.begin(), a.begin(), minus<double>());\n    return a;\n}\n\n/* Multiplying two streams together multiplies the individual samples */\nstream_t &operator*=(stream_t &a, stream_t const &b)\n{\n    transform(a.begin(), a.end(), b.begin(), a.begin(), multiplies<double>());\n    return a;\n}\n\n/*\n * Return a new stream that is time-shifted by the specified offset. A positive\n * offset (i.e. forward in time) shifts the stream to the left with trailing\n * zeroes at the end. A negative offset (i.e. backward in time) shifts\n * the stream to the right with leading zeroes at the beginning. If the\n * absolute value of offset is larger than the number of available samples,\n * then the output vector will contain all zeroes.\n */\nstream_t shift(stream_t const &in, int offset)\n{\n    /* Initialize output vector with all zeroes */\n    stream_t out(in.size(), 0);\n    \n    /* Iterators which define the range copied from \"in\" stream to \"out\" */\n    stream_t::iterator outbegin = out.begin();\n    stream_t::const_iterator inbegin = in.begin();\n    stream_t::const_iterator inend = in.end();\n    \n    /* A positive (forward in time) offset gives trailing zeroes in \"out\" */\n    if(offset >= 0) {\n        inbegin += offset;\n    }\n    \n    /* A negative (bacward in time) offset gives leading zeroes in \"out\" */\n    else {\n        outbegin += -offset;\n        inend -= -offset;\n    }\n\n    /* If the offset it too large or too small, output will have all zeroes */\n    if(inbegin < inend) {\n        copy(inbegin, inend,outbegin);\n    }\n    \n    return out;\n}\n\n/*\n * If the samples for stream \"name\" have not already been computed and stored\n * in \"streams\", then compute them by parsing the appropriate equation in\n * \"filters\". This function uses a recursive descent parser to recognize the\n * filter equation grammer. The original grammar has to be slightly rewritten\n * to remove the ambigiuity associated with operator precedence. Below is\n * the modified grammar in Extended Backus-Naur Form (the __ symbol is left\n * out for clarity):\n *\n * EQUATION ::= STREAM \"=\" SUM\n * SUM      ::= TERM { SUMOPER TERM }*\n * TERM     ::= EXPR { MULOPER EXPR }*\n * EXPR     ::= VALUE | SAMPLE | \"(\" SUM \")\"\n * SUMOPER  ::= \"+\" | \"-\"\n * MULOPER  ::= \"*\"\n */\nvoid compute(char name, streamset_t &streams, filterset_t &filters,\n    int sample_num)\n{\n    /* SANITY CHECK: Detect undefined stream names */\n    ASSERT(streams.find(name) != streams.end() || filters.find(name) !=\n        filters.end())\n\n    /* SANITY CHECK: Detect feedback loops */\n    ASSERT(streams.find(name) == streams.end() || streams[name].size());\n\n    /* Do nothing if this stream has been already computed */\n    if(streams[name].size()) {\n        return;\n    }\n    \n    /* Parse this filter equation and compute its sample stream */\n    istringstream text(filters[name]);\n    stream_t value = parse_sum(text, streams, filters, sample_num);\n    ASSERT(text.eof());\n    \n    /* Round and clip the output samples to integers in the [0,255] range */\n    ASSERT(value.size() == sample_num);\n    for(int i = 0; i < sample_num; i++) {\n        int integer = (int) value[i];\n        \n        if(integer < 0) {\n            value[i] = 0;\n        }\n        else if(integer > 255) {\n            value[i] = 255;\n        }\n        else {\n            value[i] = integer;\n        }\n    }\n\n    /* Assign the computed stream to the stream set */\n    streams[name] = value;\n}\n\n/* Parse SUM ::= TERM { SUMOPER TERM }* */\nstream_t parse_sum(istringstream &text, streamset_t &streams,\n    filterset_t &filters, int sample_num)\n{\n    /* The left hand side expression must always be present */\n    stream_t result = parse_term(text, streams, filters, sample_num);\n\n    /* Look ahead one token into the input stream */\n    char oper;\n    text >> oper;\n    \n    /* Keep parsing as long as any \"+\" or \"-\" operators exist */\n    while(!text.eof()) {\n        ASSERT(!text.fail());\n \n        /* Add or subtract the right hand side expression */\n        if(oper == \'+\') {\n            result += parse_term(text, streams, filters, sample_num);\n        }\n        else if(oper == \'-\') {\n            result -= parse_term(text, streams, filters, sample_num);\n        }\n\n        /* Otherwise this is the end of the SUM non-terminal */\n        else {\n            text.putback(oper);            \n            break;\n        }\n\n        /* Look ahead one token into the input stream */\n        text >> oper;        \n    }\n\n    return result;\n}\n\n/* Parse TERM ::= EXPR { MULOPER EXPR }* */\nstream_t parse_term(istringstream &text, streamset_t &streams,\n    filterset_t &filters, int sample_num)\n{\n    /* The left hand side expression must always be present */\n    stream_t result = parse_expr(text, streams, filters, sample_num);\n    \n    /* Look ahead one token into the input stream */\n    char oper;\n    text >> oper;\n\n    /* Keep parsing as long as any \"*\" operators exist */\n    while(!text.eof()) {\n        ASSERT(!text.fail());\n\n        /* Multiply the result by the right hand side expression */\n        if(oper == \'*\') {\n            result *= parse_expr(text, streams, filters, sample_num);\n        }\n\n        /* Otherwise this is the end of the TERM non-terminal */\n        else {\n            text.putback(oper);\n            break;\n        }\n\n        /* Look ahead one token into the input stream */\n        text >> oper;\n    }\n   \n    return result;\n}\n\n/* Parse EXPR ::= VALUE | SAMPLE | \"(\" SUM \")\" */\nstream_t parse_expr(istringstream &text, streamset_t &streams,\n    filterset_t &filters, int sample_num)\n{\n    stream_t result;\n\n    /* Extract the next token from the input stream */\n    string token;\n    text >> token;\n    ASSERT(!text.fail());\n   \n    /* An opening parenthesis signals the start of a nested sub expression */\n    if(token == \"(\") {\n        result = parse_sum(text, streams, filters, sample_num);\n\n        /* Match the closing parenthesis */\n        char oper;        \n        text >> oper;        \n        ASSERT(!text.fail());\n        ASSERT(oper == \')\');\n    }\n    \n    /* An uppercase letter signals a sample definition of the form \"X[N]\" */\n    else if(isupper(token[0])) {\n        istringstream str(token);\n        char name, dummy1, dummy2;\n        int offset;\n        \n        str >> name >> dummy1 >> offset >> dummy2;\n        ASSERT(dummy1 == \'[\' && dummy2 == \']\');\n        ASSERT(offset >= -100 && offset <= 100);\n        ASSERT(!str.fail() && !(str >> dummy1));\n\n        /* Ensure the requested input stream has been calculated already */\n        compute(name, streams, filters, sample_num);\n\n        /* Return a time-shifted version of the requested input stream */\n        result = shift(streams[name], offset);\n    }\n    \n    /* Otherwise this token must be a floating point constant */\n    else {\n        istringstream str(token);\n        double value;\n        char dummy;\n        \n        str >> value;\n        ASSERT(!str.fail() && !(str >> dummy));\n\n        /* Return a sample stream initialized to the floating point constant */\n        result = stream_t(sample_num, value);\n    }\n    \n    return result;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        int sample_num, input_num, input_idx;\n        streamset_t streams;\n        filterset_t filters;\n        \n        /* Read in the number of streams and samples */\n        cin >> input_num >> sample_num;\n        \n        /* Read in each of the stream definitions */\n        for(input_idx = 0; input_idx < input_num; input_idx++) {\n            char name, oper;\n            int sample_idx;\n            \n            /* Read in the stream name and % or = operator */\n            cin >> name >> oper;\n            ASSERT(name >= \'A\' && name <= \'Z\');\n            ASSERT(oper == \'%\' || oper == \'=\');\n\n            /* SANITY CHECK: Check for duplicate stream definitions */\n            ASSERT(filters.find(name) == filters.end());\n            ASSERT(streams.find(name) == streams.end());\n            \n            /* A % operator is an input stream */\n            if(oper == \'%\') {\n                for(sample_idx = 0; sample_idx < sample_num; sample_idx++) {\n                    int sample;\n                                \n                    cin >> sample;\n                    ASSERT(sample >= 0 && sample <= 255);\n                    \n                    streams[name].push_back(sample);\n                }\n            }\n            \n            /* A = operator is a filter definition */\n            else {\n                string filter;                \n                getline(cin, filter);\n                filters[name] = filter;\n            }\n        }\n\n        /* SANITY CHECK: Need at least one input and output stream */\n        ASSERT(filters.size() && streams.size());\n\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n        \n        /*\n         * Compute and print out the samples in each output stream. The STL map\n         * in filterset_t guarantees the filter names are already sorted in\n         * alphabetical order.\n         */\n        filterset_t::iterator i;\n        for(i = filters.begin(); i != filters.end(); ++i) {\n            compute(i->first, streams, filters, sample_num);\n            cout << i->first << \" %\" << streams[i->first] << endl;\n        }\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(299,'#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, the program will print the computed water\n * layout to stderr for each of the four rotations. If compiled -DSTEP, it\n * will print an intermediate grid state showing the puddle id assignments\n * after scanning each row of the grid. The -DSTEP can be used to trace the\n * execution of the algorithm.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Maximum integer value used to represent closed walls in the grid */\n#define MAXINT (numeric_limits<int>::max())\n\n/* Max width/height of a Stick-Tite construction */\n#define MAXSIZE 40\n\n/*\n * This array type holds the initial input layout and the intermediate states\n * of the board as the computation proceeds. A 0 indicates an empty space (\n * either one that can\'t hold water or one that hasn\'t been analyzed yet). A\n * MAXINT indicates a space with a Stick-Tite bock. Any number in between\n * identifies a puddle. The structure is scanned bottom to top and independant\n * puddles are assigned numbers starting from 1.\n */\ntypedef int grid_t[MAXSIZE][MAXSIZE];\n\n/*\n * This data structure maps each puddle id number to the maximum water height\n * the puddle can achieve. This is necessary to account for the effect of\n * static water pressure which causes all connected pools to drain down to the\n * same height as the lowest opening in any of the connected pools.\n */\ntypedef set<int> heightset_t;\n\n#if defined(STEP) || defined(DEBUG)\n/* \n * DEBUG ONLY: Print out (to stderr) the current state of the grid. In \"water\"\n * mode all the puddles that have a defined height (i.e. that are not totally\n * enclosed) are marked with a ~ character. If \"water\" is false then  it prints\n * the  numbers that show how puddles have been identified and grouped together.\n * The first 9 puddles are printed as ASCII digits. Any higher numbers than that\n * are printed as capital letters A-Z. Any higher than that is printed as a ?\n * since we would need two characters to represent the space.\n */\nvoid print_grid(grid_t grid, int height, int width, bool water,\n    heightset_t &heightset)\n{\n    cerr << \"   \";\n    for(int col = 0; col < width; col++) {\n        cerr << col % 10;\n    }\n    cerr << endl;\n\n    for(int row = 0; row < height; row++) {\n        cerr << setw(2) << row << \" \";\n        for(int col = 0; col < width; col++) {\n            int id = grid[row][col];\n            \n            if(id == 0) {\n                cerr << \".\";\n            } else if(id == MAXINT) {\n                cerr << \"X\";\n            } else if(water) {\n                if(heightset.find(id) != heightset.end()) {\n                    cerr << \'~\';\n                } else {\n                    cerr << \'.\';\n                }\n            } else {\n                if(id >= 1 && id <= 9) {\n                    cerr << (char) (\'0\' + id);\n                } else if(id >= 10 && id <= 36) {\n                    cerr << (char) (\'A\' + id - 10);\n                } else {\n                    cerr << \'?\';\n                }\n            }                \n        }\n        cerr << endl;\n    }\n}\n#endif\n\n/*\n * Count and return the total number of grid cells that will hold water. This\n * function counts all cells marked as belonging to a puddle but only if that\n * puddle id has already reached its maximum height (i.e. it\'s not completely\n * enclosed).\n */\nint count_water(grid_t grid, int height, int width, heightset_t &heightset)\n{\n    int total = 0;\n\n    for(int row = 0; row < height; row++) {\n        for(int col = 0; col < width; col++) {\n            int id = grid[row][col];\n            \n            if(id != 0 && id != MAXINT) {\n                if(heightset.find(id) != heightset.end()) {\n                    total++;\n                }\n            }\n        }\n    }\n\n    return total;\n}\n\n/*\n * Since grid[row][col] contains an open space, this space sets the maximum\n * height of any pool below it (and to the lower left and right). Setting the\n * max height of the pool will prevent it from growing any further since it\n * would always drain out through this open space.\n */\nvoid check_height(grid_t grid, int row, int col, int width,\n    heightset_t &heightset)\n{\n    int id;\n    \n    /* Check directly below */\n    id = grid[row + 1][col];        \n    if(id != MAXINT && id != 0) {\n        heightset.insert(id);\n    }\n    \n    /* Check in the lower left */\n    if(col >= 1) {\n        id = grid[row + 1][col - 1];\n        if(id != MAXINT && id != 0) {\n            heightset.insert(id);\n        }\n    }\n\n    /* Check in the lower right */\n    if(col < width - 1) {\n        id = grid[row + 1][col + 1];\n        if(id != MAXINT && id != 0) {\n            heightset.insert(id);\n        }\n    }\n}\n\n/*\n * When a puddle is being merged, this function helps with merging any other\n * previously separate puddles connected to us. Given a merge id and a location\n * in the grid to start merging from, this function uses a recursive flood\n * fill to merge any other connected puddles by assigning the merge id to them.\n * The recursion stops when a wall, empty space, or an already merged grid\n * cell is hit, and the recursion continues across any cells with puddle ids\n * that are not yet merged.\n */\nvoid merge_recursive(grid_t grid, int row, int col, int width, int merge)\n{\n    /* The 8 possible adjacent locations encoded into row, col offsets */\n    int rowoff[] = { 1, -1,  0,  0,  1,  1, -1, -1 };\n    int coloff[] = { 0,  0,  1, -1,  1, -1,  1, -1 };\n\n    /*\n     * Stop recursion on out of bounds. There\'s no max height check here\n     * because there will always be a floor beneath us; otherwise the puddle\n     * above that initiated the merge in the first place would have never\n     * formed.\n     */\n    if(row < 0 || col < 0 || col >= width) {\n        return;\n    }\n\n    /* Merge current grid cell */\n    grid[row][col] = merge;\n\n    /* Merge current grid cell and recurse in every direction */\n    for(int dir = 0; dir < 8; dir++) {\n        int newrow = row + rowoff[dir];\n        int newcol = col + coloff[dir];\n        int id = grid[newrow][newcol];\n        \n        /* Stop recursion on wall, empty space, or already merged puddle */\n        if(id == 0 || id == MAXINT || id == merge) {\n            continue;\n        }\n        \n        merge_recursive(grid, newrow, newcol, width, merge);\n    }    \n}\n\n/* \n * Return true if the grid location (row, col) really is a hole that will let\n * water drain out. Return false if the location is a wall since a wall will\n * always support water. If the location is another pool, then return true\n * (can\'t hold water) if the other pool has already reached its max height;\n * otherwise return false (will hold water) because the other pool is still\n * allowed to increase in height. If another pool is present, we also set\n * the \"merge\" variable to its id so that the pool above can be assigned the\n * same id as this one. This merging behavior is necessary to \"transfer\"\n * max height information (i.e. static water pressure acts on all connected\n * pools).\n */\nbool check_hole(grid_t grid, int row, int col, int &merge,\n    heightset_t &heightset)\n{\n    int id = grid[row][col];\n\n    /* If hole drains into empty space, then this pool can\'t hold water */\n    if(id == 0) {\n        return true;\n    }\n    \n    /* If there is a solid wall beneath us, then it\'ll hold water */\n    if(id == MAXINT) {\n        return false;\n    }\n    \n    /* If pool beneath us reached it\'s max height, then it can\'t hold water */\n    if(heightset.find(id) != heightset.end()) {\n        return true;\n    }\n    \n    /* Since the pool beneath can still grow; merge and use common id */     \n    merge = id;\n    return false;\n}\n\n/*\n * Rotate the entire grid 90 degrees to the right. While at it, all puddle\n * ids are reset back to 0 (i.e. empty spaces) to prepare for the next\n * analysis round. The width and height are also swapped to reflect the\n * new geometry. Finally, a local temporary grid copy is used while performing\n * the rotation.\n */\nvoid rotate_grid(grid_t grid, int &width, int &height)\n{\n    grid_t temp;\n    swap(width, height);\n    memcpy(temp, grid, sizeof(grid_t));\n\n    for(int row = 0; row < height; row++) {\n        for(int col = 0; col < width; col++) {\n            int oldid = temp[width - col - 1][row];                    \n            grid[row][col] = oldid == MAXINT ? MAXINT : 0;\n        }\n    }\n}\n\n/*\n * Scan across (from left to right) a single \"row\" in the \"grid\" and mark any\n * puddles that can potentially hold water. To hold water, the puddle must have\n * walls and it must not have any holes that drain into empty space. The grid\n * locations of the puddle are marked with \"count\" and the the global \"count\"\n * is incremented so the next puddle can get a unique number. If the puddle\n * does have holes but they drain into another puddle beneath, then this\n * puddle may or may not merge with the one below (see check_hole).\n */\nvoid scan_line(grid_t grid, int row, int width, int &count,\n    heightset_t &heightset)\n{\n    int start, end = 0;\n\n    /* Keep running until the entire row is analyzed */\n    while(end < width) {\n        int merge = MAXINT;\n\n        /* Skip over blank spaces that can\'t hold any water */\n        for(start = end; start < width; start++) {\n            if(grid[row][start] == MAXINT) {\n                break;\n            }\n            check_height(grid, row, start, width, heightset);\n        }\n\n        /* Skip over the solid wall that will hold the water in */\n        for(; start < width; start++) {\n            if(grid[row][start] == 0) {\n                break;\n            }\n        }\n\n        /*\n         * Check for any holes beneath this row. Note that we don\'t have to\n         * check the lower-right space because the next loop iteration will\n         * take care of that. If no holes are found and we find a wall to the\n         * right of the pool, then we can mark the pool with either a new\n         * \"count\" id or we can merge it with the pool beneath us.\n         */\n        for(end = start; end < width; end++) {\n\n            /* Check for holes diretly beneath and to the lower left */\n            if(check_hole(grid, row + 1, end, merge, heightset)) {\n                break;\n            }\n            if(check_hole(grid, row + 1, end - 1, merge, heightset)) {\n                break;\n            }\n\n            /*\n             * If new wall found to hold the right side of the puddle, then mark\n             * the [start, end) interval on this as either a new or a merged\n             * puddle. If merging this puddle with one below, there may also\n             * be other unrelated puddles under this one, therefore we have to\n             * descent and merge those to ourselves as well.\n             */\n            if(grid[row][end] == MAXINT) {\n                int id = merge;\n            \n                /* If not merging, use the next higher \"count\" as puddle id */\n                if(merge == MAXINT) {\n                    count++;\n                    id = count;\n                }\n                \n                /* Mark this puddle as viable */\n                for(; start < end; start++) {\n                    grid[row][start] = id;\n                    \n                    /* If merging, recursively merge all puddles below */\n                    if(merge == id) {\n                        merge_recursive(grid, row, start, width, id);\n                    }\n                }\n                \n                break;\n            }\n        }\n        \n        /* If pool couldn\'t hold water, set max height for pools below */\n        for(int i = start; i < end; i++) {\n            check_height(grid, row, i, width, heightset);\n        }\n    }\n    \n    /* Correct any pools that may have grown too high too early */\n    for(int i = 0; i < width; i++) {\n        int id = grid[row][i];\n        \n        if(id != 0 && id != MAXINT) {\n            if(heightset.find(id) != heightset.end()) {\n                grid[row][i] = 0;\n            }\n        }\n    }\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        int height, width, count = 0;\n        vector<int> results;\n        grid_t grid;\n                \n        cin >> height >> width;\n        ASSERT(1 <= height && height <= MAXSIZE);\n        ASSERT(1 <= width && width <= MAXSIZE);\n        \n        /*\n         * Read in the input layout but convert \".\" spacezs to 0 and \"X\" to\n         * MAXINT. During the analysis phase, as puddles get identified they\n         * are assigned integers starting from 1.\n         */\n        for(int row = 0; row < height; row++) {\n            for(int col = 0; col < width; col++) {\n                char c;\n                \n                cin >> c;\n                ASSERT(c == \'.\' || c == \'X\');\n                grid[row][col] = c == \'.\' ? 0 : MAXINT;                \n            }\n        }\n                \n        /* Analyze the grid from each of the four directions */\n        for(int rot_idx = 0; rot_idx < 4; rot_idx++) {\n            heightset_t heightset;\n#ifdef STEP\n            cerr << \"Initial layout (rotation \" << rot_idx << \")\" << endl;\n            print_grid(grid, height, width, false, heightset);\n#endif        \n            /* Scan from bottom to top identifying all puddles */\n            for(int row = height - 2; row >= 0; row--) {\n                scan_line(grid, row, width, count, heightset);\n#ifdef STEP\n                cerr << \"Scanning row \" << row << endl;\n                print_grid(grid, height, width, false, heightset);\n#endif        \n            }\n\n            /* Assign max heights to any puddles open at the top */\n            for(int col = 0; col < width; col++) {\n                check_height(grid, -1, col, width, heightset);\n            }\n\n#if defined(DEBUG) || defined(STEP)\n            cerr << \"Water layout (rotation \" << rot_idx << \")\" << endl;\n            print_grid(grid, height, width, true, heightset);        \n#endif\n            /* Count retained water and add to result vector */\n            results.push_back(count_water(grid, height, width, heightset));\n\n            /* Rotate and reset grid for next analysis */\n            rotate_grid(grid, width, height);\n        }        \n\n\n        /* Print out the results in descending sorted order */\n        sort(results.begin(), results.end(), greater<int>());\n        for(int i = 0; i < results.size(); i++) {\n            cout << results[i];\n            if (i < results.size() - 1) {\n                cout << \" \";\n            }\n#if defined(DEBUG) || defined(STEP)\n            cerr << results[i] << \" \";\n#endif        \n        }\n            cout << endl;\n#if defined(DEBUG) || defined(STEP)\n            cerr << endl << endl;\n#endif        \n    }    \n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(300,'#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, the program will print the computed water\n * layout to stderr for each of the four rotations. If compiled -DSTEP, it\n * will print an intermediate grid state showing the puddle id assignments\n * after scanning each row of the grid. The -DSTEP can be used to trace the\n * execution of the algorithm.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Maximum integer value used to represent closed walls in the grid */\n#define MAXINT (numeric_limits<int>::max())\n\n/* Max width/height of a Stick-Tite construction */\n#define MAXSIZE 40\n\n/*\n * This array type holds the initial input layout and the intermediate states\n * of the board as the computation proceeds. A 0 indicates an empty space (\n * either one that can\'t hold water or one that hasn\'t been analyzed yet). A\n * MAXINT indicates a space with a Stick-Tite bock. Any number in between\n * identifies a puddle. The structure is scanned bottom to top and independant\n * puddles are assigned numbers starting from 1.\n */\ntypedef int grid_t[MAXSIZE][MAXSIZE];\n\n/*\n * This data structure maps each puddle id number to the maximum water height\n * the puddle can achieve. This is necessary to account for the effect of\n * static water pressure which causes all connected pools to drain down to the\n * same height as the lowest opening in any of the connected pools.\n */\ntypedef set<int> heightset_t;\n\n#if defined(STEP) || defined(DEBUG)\n/* \n * DEBUG ONLY: Print out (to stderr) the current state of the grid. In \"water\"\n * mode all the puddles that have a defined height (i.e. that are not totally\n * enclosed) are marked with a ~ character. If \"water\" is false then  it prints\n * the  numbers that show how puddles have been identified and grouped together.\n * The first 9 puddles are printed as ASCII digits. Any higher numbers than that\n * are printed as capital letters A-Z. Any higher than that is printed as a ?\n * since we would need two characters to represent the space.\n */\nvoid print_grid(grid_t grid, int height, int width, bool water,\n    heightset_t &heightset)\n{\n    cerr << \"   \";\n    for(int col = 0; col < width; col++) {\n        cerr << col % 10;\n    }\n    cerr << endl;\n\n    for(int row = 0; row < height; row++) {\n        cerr << setw(2) << row << \" \";\n        for(int col = 0; col < width; col++) {\n            int id = grid[row][col];\n            \n            if(id == 0) {\n                cerr << \".\";\n            } else if(id == MAXINT) {\n                cerr << \"X\";\n            } else if(water) {\n                if(heightset.find(id) != heightset.end()) {\n                    cerr << \'~\';\n                } else {\n                    cerr << \'.\';\n                }\n            } else {\n                if(id >= 1 && id <= 9) {\n                    cerr << (char) (\'0\' + id);\n                } else if(id >= 10 && id <= 36) {\n                    cerr << (char) (\'A\' + id - 10);\n                } else {\n                    cerr << \'?\';\n                }\n            }                \n        }\n        cerr << endl;\n    }\n}\n#endif\n\n/*\n * Count and return the total number of grid cells that will hold water. This\n * function counts all cells marked as belonging to a puddle but only if that\n * puddle id has already reached its maximum height (i.e. it\'s not completely\n * enclosed).\n */\nint count_water(grid_t grid, int height, int width, heightset_t &heightset)\n{\n    int total = 0;\n\n    for(int row = 0; row < height; row++) {\n        for(int col = 0; col < width; col++) {\n            int id = grid[row][col];\n            \n            if(id != 0 && id != MAXINT) {\n                if(heightset.find(id) != heightset.end()) {\n                    total++;\n                }\n            }\n        }\n    }\n\n    return total;\n}\n\n/*\n * Since grid[row][col] contains an open space, this space sets the maximum\n * height of any pool below it (and to the lower left and right). Setting the\n * max height of the pool will prevent it from growing any further since it\n * would always drain out through this open space.\n */\nvoid check_height(grid_t grid, int row, int col, int width,\n    heightset_t &heightset)\n{\n    int id;\n    \n    /* Check directly below */\n    id = grid[row + 1][col];        \n    if(id != MAXINT && id != 0) {\n        heightset.insert(id);\n    }\n    \n    /* Check in the lower left */\n    if(col >= 1) {\n        id = grid[row + 1][col - 1];\n        if(id != MAXINT && id != 0) {\n            heightset.insert(id);\n        }\n    }\n\n    /* Check in the lower right */\n    if(col < width - 1) {\n        id = grid[row + 1][col + 1];\n        if(id != MAXINT && id != 0) {\n            heightset.insert(id);\n        }\n    }\n}\n\n/*\n * When a puddle is being merged, this function helps with merging any other\n * previously separate puddles connected to us. Given a merge id and a location\n * in the grid to start merging from, this function uses a recursive flood\n * fill to merge any other connected puddles by assigning the merge id to them.\n * The recursion stops when a wall, empty space, or an already merged grid\n * cell is hit, and the recursion continues across any cells with puddle ids\n * that are not yet merged.\n */\nvoid merge_recursive(grid_t grid, int row, int col, int width, int merge)\n{\n    /* The 8 possible adjacent locations encoded into row, col offsets */\n    int rowoff[] = { 1, -1,  0,  0,  1,  1, -1, -1 };\n    int coloff[] = { 0,  0,  1, -1,  1, -1,  1, -1 };\n\n    /*\n     * Stop recursion on out of bounds. There\'s no max height check here\n     * because there will always be a floor beneath us; otherwise the puddle\n     * above that initiated the merge in the first place would have never\n     * formed.\n     */\n    if(row < 0 || col < 0 || col >= width) {\n        return;\n    }\n\n    /* Merge current grid cell */\n    grid[row][col] = merge;\n\n    /* Merge current grid cell and recurse in every direction */\n    for(int dir = 0; dir < 8; dir++) {\n        int newrow = row + rowoff[dir];\n        int newcol = col + coloff[dir];\n        int id = grid[newrow][newcol];\n        \n        /* Stop recursion on wall, empty space, or already merged puddle */\n        if(id == 0 || id == MAXINT || id == merge) {\n            continue;\n        }\n        \n        merge_recursive(grid, newrow, newcol, width, merge);\n    }    \n}\n\n/* \n * Return true if the grid location (row, col) really is a hole that will let\n * water drain out. Return false if the location is a wall since a wall will\n * always support water. If the location is another pool, then return true\n * (can\'t hold water) if the other pool has already reached its max height;\n * otherwise return false (will hold water) because the other pool is still\n * allowed to increase in height. If another pool is present, we also set\n * the \"merge\" variable to its id so that the pool above can be assigned the\n * same id as this one. This merging behavior is necessary to \"transfer\"\n * max height information (i.e. static water pressure acts on all connected\n * pools).\n */\nbool check_hole(grid_t grid, int row, int col, int &merge,\n    heightset_t &heightset)\n{\n    int id = grid[row][col];\n\n    /* If hole drains into empty space, then this pool can\'t hold water */\n    if(id == 0) {\n        return true;\n    }\n    \n    /* If there is a solid wall beneath us, then it\'ll hold water */\n    if(id == MAXINT) {\n        return false;\n    }\n    \n    /* If pool beneath us reached it\'s max height, then it can\'t hold water */\n    if(heightset.find(id) != heightset.end()) {\n        return true;\n    }\n    \n    /* Since the pool beneath can still grow; merge and use common id */     \n    merge = id;\n    return false;\n}\n\n/*\n * Rotate the entire grid 90 degrees to the right. While at it, all puddle\n * ids are reset back to 0 (i.e. empty spaces) to prepare for the next\n * analysis round. The width and height are also swapped to reflect the\n * new geometry. Finally, a local temporary grid copy is used while performing\n * the rotation.\n */\nvoid rotate_grid(grid_t grid, int &width, int &height)\n{\n    grid_t temp;\n    swap(width, height);\n    memcpy(temp, grid, sizeof(grid_t));\n\n    for(int row = 0; row < height; row++) {\n        for(int col = 0; col < width; col++) {\n            int oldid = temp[width - col - 1][row];                    \n            grid[row][col] = oldid == MAXINT ? MAXINT : 0;\n        }\n    }\n}\n\n/*\n * Scan across (from left to right) a single \"row\" in the \"grid\" and mark any\n * puddles that can potentially hold water. To hold water, the puddle must have\n * walls and it must not have any holes that drain into empty space. The grid\n * locations of the puddle are marked with \"count\" and the the global \"count\"\n * is incremented so the next puddle can get a unique number. If the puddle\n * does have holes but they drain into another puddle beneath, then this\n * puddle may or may not merge with the one below (see check_hole).\n */\nvoid scan_line(grid_t grid, int row, int width, int &count,\n    heightset_t &heightset)\n{\n    int start, end = 0;\n\n    /* Keep running until the entire row is analyzed */\n    while(end < width) {\n        int merge = MAXINT;\n\n        /* Skip over blank spaces that can\'t hold any water */\n        for(start = end; start < width; start++) {\n            if(grid[row][start] == MAXINT) {\n                break;\n            }\n            check_height(grid, row, start, width, heightset);\n        }\n\n        /* Skip over the solid wall that will hold the water in */\n        for(; start < width; start++) {\n            if(grid[row][start] == 0) {\n                break;\n            }\n        }\n\n        /*\n         * Check for any holes beneath this row. Note that we don\'t have to\n         * check the lower-right space because the next loop iteration will\n         * take care of that. If no holes are found and we find a wall to the\n         * right of the pool, then we can mark the pool with either a new\n         * \"count\" id or we can merge it with the pool beneath us.\n         */\n        for(end = start; end < width; end++) {\n\n            /* Check for holes diretly beneath and to the lower left */\n            if(check_hole(grid, row + 1, end, merge, heightset)) {\n                break;\n            }\n            if(check_hole(grid, row + 1, end - 1, merge, heightset)) {\n                break;\n            }\n\n            /*\n             * If new wall found to hold the right side of the puddle, then mark\n             * the [start, end) interval on this as either a new or a merged\n             * puddle. If merging this puddle with one below, there may also\n             * be other unrelated puddles under this one, therefore we have to\n             * descent and merge those to ourselves as well.\n             */\n            if(grid[row][end] == MAXINT) {\n                int id = merge;\n            \n                /* If not merging, use the next higher \"count\" as puddle id */\n                if(merge == MAXINT) {\n                    count++;\n                    id = count;\n                }\n                \n                /* Mark this puddle as viable */\n                for(; start < end; start++) {\n                    grid[row][start] = id;\n                    \n                    /* If merging, recursively merge all puddles below */\n                    if(merge == id) {\n                        merge_recursive(grid, row, start, width, id);\n                    }\n                }\n                \n                break;\n            }\n        }\n        \n        /* If pool couldn\'t hold water, set max height for pools below */\n        for(int i = start; i < end; i++) {\n            check_height(grid, row, i, width, heightset);\n        }\n    }\n    \n    /* Correct any pools that may have grown too high too early */\n    for(int i = 0; i < width; i++) {\n        int id = grid[row][i];\n        \n        if(id != 0 && id != MAXINT) {\n            if(heightset.find(id) != heightset.end()) {\n                grid[row][i] = 0;\n            }\n        }\n    }\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        int height, width, count = 0;\n        vector<int> results;\n        grid_t grid;\n                \n        cin >> height >> width;\n        ASSERT(1 <= height && height <= MAXSIZE);\n        ASSERT(1 <= width && width <= MAXSIZE);\n        \n        /*\n         * Read in the input layout but convert \".\" spacezs to 0 and \"X\" to\n         * MAXINT. During the analysis phase, as puddles get identified they\n         * are assigned integers starting from 1.\n         */\n        for(int row = 0; row < height; row++) {\n            for(int col = 0; col < width; col++) {\n                char c;\n                \n                cin >> c;\n                ASSERT(c == \'.\' || c == \'X\');\n                grid[row][col] = c == \'.\' ? 0 : MAXINT;                \n            }\n        }\n                \n        /* Analyze the grid from each of the four directions */\n        for(int rot_idx = 0; rot_idx < 4; rot_idx++) {\n            heightset_t heightset;\n#ifdef STEP\n            cerr << \"Initial layout (rotation \" << rot_idx << \")\" << endl;\n            print_grid(grid, height, width, false, heightset);\n#endif        \n            /* Scan from bottom to top identifying all puddles */\n            for(int row = height - 2; row >= 0; row--) {\n                scan_line(grid, row, width, count, heightset);\n#ifdef STEP\n                cerr << \"Scanning row \" << row << endl;\n                print_grid(grid, height, width, false, heightset);\n#endif        \n            }\n\n            /* Assign max heights to any puddles open at the top */\n            for(int col = 0; col < width; col++) {\n                check_height(grid, -1, col, width, heightset);\n            }\n\n#if defined(DEBUG) || defined(STEP)\n            cerr << \"Water layout (rotation \" << rot_idx << \")\" << endl;\n            print_grid(grid, height, width, true, heightset);        \n#endif\n            /* Count retained water and add to result vector */\n            results.push_back(count_water(grid, height, width, heightset));\n\n            /* Rotate and reset grid for next analysis */\n            rotate_grid(grid, width, height);\n        }        \n\n\n        /* Print out the results in descending sorted order */\n        sort(results.begin(), results.end(), greater<int>());\n        for(int i = 0; i < results.size(); i++) {\n            cout << results[i];\n            if (i < results.size() - 1) {\n                cout << \" \";\n            }\n#if defined(DEBUG) || defined(STEP)\n            cerr << results[i] << \" \";\n#endif        \n        }\n            cout << endl;\n#if defined(DEBUG) || defined(STEP)\n            cerr << endl << endl;\n#endif        \n    }    \n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(301,'#include <ctype.h>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, the program will show the transformed\n * scripts (on stderr) for each NPC that avoid collisions and are always\n * inherently cyclic. If compiled -DSTEP, the program will show the town state\n * (also on stderr) after every single turn. Note that using -DSTEP makes the\n * entire program too slow to actually finish running the master data sets.\n * With -DSTEP we no longer do the \"modulo optimization\" that takes advantage\n * of cyclic nature of the NPCs walk scripts.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Max width/height of a town */\n#define MAXSIZE 40\n\n/* Return the minimum of two values */\n#define min(a,b) ((a) < (b) ? (a) : (b))\n\n/* Generic integer pair used for several things in the program */\ntypedef pair<int, int> coord_t;\n\n/* Dictionary to map verb names to indices into the VERB array */\nmap<string, int> NAMES;\n\n/* DEBUG ONLY: Array mapping VERB array indices to string names for printing */\nconst char *PRINT[] = {\n    \"NORTH\", \"SOUTH\", \"EAST\", \"WEST\", \"PAUSE\"\n};\n\n/* These are the \"reversed\" verb numbers for each of the commands in NAMES[] */\nconst int REVERSE[] = { 1, 0, 3, 2, 4 };\n\n/*\n * The effect that each of the command verbs has on a NPC\'s position can be\n * encoded in terms of a row and column offset that\'s applied to the position\n * every turn. This array is in the same order as NAMES to facilitate easy\n * lookup. The offsets are of the form (row, col).\n */\nconst coord_t VERB[] = {\n    coord_t(-1, 0), coord_t(1, 0), coord_t(0, 1), coord_t(0, -1), coord_t(0, 0)\n};\n\n/* Index into VERB[] for the pause command */\n#define PAUSE 4\n\n/*\n * A command is a (verb, value) pair where \"verb\" is an integer between 0 and 4\n * (matching the VERB[] array) and \"value\" is an integer indicating how far to\n * move or how long to pause for. The command map associates each command list\n * with the NPC single character id as read from the input data set.\n */\ntypedef vector<coord_t> cmdlist_t;\ntypedef map<char, cmdlist_t> cmdmap_t;\n\n/* Maps an NPC char id (number or letter) to the NPC position as (row, col) */\ntypedef map<char, coord_t> npcmap_t;\n\n/*\n * The array is used to hold the town layout but only for tracking the\n * open vs wall spaces. Actual NPC locations are only stored in a datalist_t\n * object since that\'s an easier format to update as the NPCs move around.\n */\ntypedef char grid_t[MAXSIZE][MAXSIZE];\n\n/*\n * Print the town layout to the \"out\" stream and show the location of every\n * NPC in \"npcmap\" by printing the appropriate NPC character on top of the\n * layout.\n */\nvoid output(ostream &out, grid_t grid, npcmap_t &npcmap, int width, int height)\n{\n    npcmap_t::iterator i;\n\n    /* Temporarily add the NPCs to the grid for printing */\n    for(i = npcmap.begin(); i != npcmap.end(); ++i) {\n        grid[i->second.first][i->second.second] = i->first;\n    }\n\n    for(int row = 0; row < height; row++) {\n        for(int col = 0; col < width; col++) {\n            out << grid[row][col];\n        }\n        out << endl;\n    }    \n\n    /* Reset NPC locations back to empty spaces */\n    for(i = npcmap.begin(); i != npcmap.end(); ++i) {\n        grid[i->second.first][i->second.second] = \'.\';\n    }\n}\n\n/*\n * DEBUG ONLY: Simulate one turn for a given NPC. The current command in\n * \"cmdlist\" (current as determined by \"instptr\") is executed and the NPC\n * position \"pos\" updated. Once the current command has finished executing,\n * the \"instptr\" is advanced (possibly wrapping around) to the next command.\n */ \nvoid simulate_one(grid_t grid, int width, int height, coord_t &instptr,\n    cmdlist_t &cmdlist, coord_t &pos)\n{\n    int ip = instptr.first;\n    \n    /*\n     * If NPC\'s command is finished, increment instruction pointer but skip\n     * over any commands who had their delay value reduced to zero by fixup().\n     */\n    while(instptr.second == 0) {\n        ip = (ip + 1) %  cmdlist.size();\n        instptr.first = ip;\n        instptr.second = cmdlist[ip].second;\n    }\n\n    /* Execute current command and decrement instruction delay */\n    pos.first += VERB[cmdlist[ip].first].first;\n    pos.second += VERB[cmdlist[ip].first].second;\n    instptr.second--;\n}\n\n/*\n * DEBUG ONLY: Simulate one turn across all NPCs in the data set. The\n * \"instptr\" map holds \"instruction pointers\" for every NPC. Every\n * instruction pointer is a pair (cmdnum, delay) where \"cmdnum\" is an index\n * into cmdmap of the currently executing command and \"delay\" is the number\n * of turns remaining until the current command finishes executing.\n */\nvoid simulate_all(grid_t grid, int width, int height, npcmap_t &instptr,\n    cmdmap_t &cmdmap, npcmap_t &npcmap)\n{\n    npcmap_t::iterator i;\n\n    /* Move each NPC by one turn */\n    for(i = npcmap.begin(); i != npcmap.end(); ++i) {        \n        char npc = i->first;\n        \n        simulate_one(grid, width, height, instptr[npc],\n            cmdmap[npc], npcmap[npc]);\n    }\n}\n\n/*\n * Execute a command \"cmd\" a single turn by updating the position of \"oldpos\" If\n * this command caused the NPC to hit a solid object or the edge of the map,\n * then return true and don\'t update \"oldpos\". Used by fixup() to detect\n * collisions in the script and to re-write the script accordingly.\n */\nbool execute(coord_t cmd, coord_t &oldpos, grid_t grid, int width, int height)\n{\n    coord_t pos;\n\n    pos.first = oldpos.first + VERB[cmd.first].first;\n    pos.second = oldpos.second + VERB[cmd.first].second;\n\n    if(pos.first < 0 || pos.second < 0 || pos.first >= height ||\n        pos.second >= width || grid[pos.first][pos.second] != \'.\')\n        return true;\n    \n    oldpos = pos;\n    return false;\n}\n\n/*\n * Execute the \"cmdlist\" script one time through and if any collisions are\n * found, re-write it to a form that avoids the collisions all together by\n * inserting the appropriate number of PAUSEs. Also if the script is not\n * already inherently cyclic, make it so by appending a reversed version\n * of the collision-free script that will return the NPC to its original\n * location. Finally, this function computes the total cycle length (in turns)\n * of the NPC\'s walk script and returns it. The cycle length is used for\n * a modulo optimization later on.\n */\nint fixup(grid_t grid, coord_t pos, int width, int height, cmdlist_t &cmdlist)\n{\n    cmdlist_t::iterator i;\n    coord_t start = pos;\n    \n    /*\n     * Execute through all the commands in the list and run each command for the\n     * specified number of turns. If we hit a wall or edge, split this command\n     * into a shortened original and a PAUSE for the remainder of the\n     * \"collision\" time.\n     */\n    for(i = cmdlist.begin(); i != cmdlist.end(); ++i) {\n        coord_t cmd = *i;\n        \n        for(int j = 0; j < cmd.second; j++) {\n            if(execute(cmd, pos, grid, width, height)) {\n                *i = coord_t(cmd.first, j);\n                ++i;\n                i = cmdlist.insert(i, coord_t(PAUSE, cmd.second - j));\n                break;\n            }\n        }\n    }\n    \n    /* If the script is reversible, make it cyclic */\n    if(pos != start) {\n        int size = cmdlist.size();\n        cmdlist.resize(size * 2);\n        \n        /* Append a duplicated and reversed command list */\n        copy(&cmdlist[0], &cmdlist[size], &cmdlist[size]);\n        reverse(&cmdlist[size], &cmdlist[size * 2]);\n        \n        /* Reverse directions of individual commands in list */\n        for(int i = size; i < size * 2; i++) {\n            cmdlist[i].first = REVERSE[cmdlist[i].first];\n        }\n    }\n    \n    /* Calculate the total cycle length of the walk script */\n    int total = 0;\n    for(i = cmdlist.begin(); i != cmdlist.end(); ++i) {\n        total += i->second;\n    }\n    return total;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Initialize the global NAMES[] dictionary */\n    NAMES[\"NORTH\"] = 0;\n    NAMES[\"SOUTH\"] = 1;\n    NAMES[\"EAST\"] = 2;\n    NAMES[\"WEST\"] = 3;\n    NAMES[\"PAUSE\"] = 4;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {   \n        int npc_num, npc_idx;     /* For looping over command lists */\n        int width, height, turns; /* Parameters from data set input */\n        npcmap_t npcmap;          /* Tracks position of each NPC */\n        npcmap_t instptr;         /* DEBUG ONLY: current command during sim */\n        cmdmap_t cmdmap;          /* Command list per NPC */\n        map<char, int> cycle;     /* Total walk cycle length per NPC */        \n        grid_t grid;              /* Town layout */\n        \n        cin >> npc_num >> height >> width;\n        ASSERT(1 <= npc_num && npc_num <= 35);\n        ASSERT(1 <= height && height <= 40);\n        ASSERT(1 <= width && width <= 40);\n        \n        /* Read in the town grid */\n        for(int row = 0; row < height; row++) {\n            for(int col = 0; col < width; col++) {\n                char npc;\n                \n                cin >> npc;\n                \n                /* Numbers and letters are NPC locations; record in npcmap */\n                if(isalnum(npc)) {\n                    npcmap[npc] = coord_t(row, col);\n                    grid[row][col] = \'.\';\n                }\n                \n                /* Otherwise it\'s a wall or empty space; record in grid */\n                else {\n                    ASSERT(npc == \'.\' || npc == \'#\');\n                    grid[row][col] = npc;\n                }\n            }\n        }\n        \n#if defined(STEP) || defined(DEBUG)\n        cerr << \"DATA SET #\" << data_idx + 1 << endl;\n#endif        \n        /* Read in the command scripts for each NPC */\n        for(npc_idx = 0; npc_idx < npc_num; npc_idx++) {            \n            int cmd_idx, cmd_num;\n            char npc;\n\n            /* Read NPC id and command count */\n            cin >> npc >> cmd_num;\n            ASSERT(npcmap.find(npc) != npcmap.end());\n            ASSERT(1 <= cmd_num && cmd_num <= 20);\n            \n            /* DEBUG ONLY: Init \"instruction pointer\" used by simulate_all() */\n            instptr[npc] = coord_t(-1, 0);\n\n            /* Read the list of commands into cmdmap[npc] list */\n            for(cmd_idx = 0; cmd_idx < cmd_num; cmd_idx++) {\n                string word;\n                int value;\n                \n                cin >> word >> value;\n                ASSERT(NAMES.find(word) != NAMES.end());\n                ASSERT(1 <= value <= 40);\n                \n                cmdmap[npc].push_back(coord_t(NAMES[word], value));\n            }\n            \n            /* Detect collisions and make reversible walks cyclic */\n            cycle[npc] = fixup(grid, npcmap[npc], width, height, cmdmap[npc]);\n            \n#if defined(STEP) || defined(DEBUG)\n            /* DEBUG ONLY: Show transformed command list with no collisions */\n            cerr << \"Transformed script \" << npc << \":\" << endl;\n            \n            cmdlist_t::iterator i;\n            for(i = cmdmap[npc].begin(); i != cmdmap[npc].end(); ++i) {\n                cerr << PRINT[i->first] << \" \" << i->second << endl;\n            }\n            \n            cerr << \"Cycle length: \" << cycle[npc] << endl << endl;\n#endif\n        }\n        \n        /* Read the number of turns to simulate for */\n        cin >> turns;\n        ASSERT(1 <= turns && turns <= 1000000);\n\n#ifdef STEP\n        /* DEBUG ONLY: Show initial grid layout before simulation */\n        cerr << \"Initial layout:\" << endl;\n        output(cerr, grid, npcmap, width, height);\n        cerr << endl;\n\n        /* DEBUG ONLY: Run a full simulation to show how NPCs move */\n        for(int i = 0; i < turns; i++) {        \n            simulate_all(grid, width, height, instptr, cmdmap, npcmap);\n            \n            cerr << \"Turn \" << i + 1 << \":\" << endl;\n            output(cerr, grid, npcmap, width, height);\n            cerr << endl;\n        }\n#else\n        /*\n         * Because every NPC movement is cyclic, we can reduce the computation\n         * time by separately simulating only \"turns modulo cycle length\" for\n         * every NPC.\n         */      \n        for(npcmap_t::iterator i = npcmap.begin(); i != npcmap.end(); ++i) {\n            int ip = 0;\n            char npc = i->first;\n            int npcturns = turns % cycle[npc];\n\n            coord_t &pos = npcmap[npc];\n            cmdlist_t &cmdlist = cmdmap[npc];\n            \n            /*\n             * We can get a further optimization by executing a single command\n             * per loop iteration and \"scaling\" the distance moved by the\n             * command\'s \"value\".\n             */\n            while(npcturns) {                              \n                int verb = cmdlist[ip].first;\n                int value = min(npcturns, cmdlist[ip].second);\n\n                /* Execute current command and decrement instruction delay */\n                pos.first += VERB[verb].first * value;\n                pos.second += VERB[verb].second * value;\n                \n                /* Advance to next instruction in command list */\n                npcturns -= value;\n                ip = (ip + 1) % cmdlist.size();\n            }\n        }\n#endif     \n        /* Show the final state of the town */\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n        output(cout, grid, npcmap, width, height);        \n    }\n} \n\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(302,'#include <ctype.h>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, the program will show the transformed\n * scripts (on stderr) for each NPC that avoid collisions and are always\n * inherently cyclic. If compiled -DSTEP, the program will show the town state\n * (also on stderr) after every single turn. Note that using -DSTEP makes the\n * entire program too slow to actually finish running the master data sets.\n * With -DSTEP we no longer do the \"modulo optimization\" that takes advantage\n * of cyclic nature of the NPCs walk scripts.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Max width/height of a town */\n#define MAXSIZE 40\n\n/* Return the minimum of two values */\n#define min(a,b) ((a) < (b) ? (a) : (b))\n\n/* Generic integer pair used for several things in the program */\ntypedef pair<int, int> coord_t;\n\n/* Dictionary to map verb names to indices into the VERB array */\nmap<string, int> NAMES;\n\n/* DEBUG ONLY: Array mapping VERB array indices to string names for printing */\nconst char *PRINT[] = {\n    \"NORTH\", \"SOUTH\", \"EAST\", \"WEST\", \"PAUSE\"\n};\n\n/* These are the \"reversed\" verb numbers for each of the commands in NAMES[] */\nconst int REVERSE[] = { 1, 0, 3, 2, 4 };\n\n/*\n * The effect that each of the command verbs has on a NPC\'s position can be\n * encoded in terms of a row and column offset that\'s applied to the position\n * every turn. This array is in the same order as NAMES to facilitate easy\n * lookup. The offsets are of the form (row, col).\n */\nconst coord_t VERB[] = {\n    coord_t(-1, 0), coord_t(1, 0), coord_t(0, 1), coord_t(0, -1), coord_t(0, 0)\n};\n\n/* Index into VERB[] for the pause command */\n#define PAUSE 4\n\n/*\n * A command is a (verb, value) pair where \"verb\" is an integer between 0 and 4\n * (matching the VERB[] array) and \"value\" is an integer indicating how far to\n * move or how long to pause for. The command map associates each command list\n * with the NPC single character id as read from the input data set.\n */\ntypedef vector<coord_t> cmdlist_t;\ntypedef map<char, cmdlist_t> cmdmap_t;\n\n/* Maps an NPC char id (number or letter) to the NPC position as (row, col) */\ntypedef map<char, coord_t> npcmap_t;\n\n/*\n * The array is used to hold the town layout but only for tracking the\n * open vs wall spaces. Actual NPC locations are only stored in a datalist_t\n * object since that\'s an easier format to update as the NPCs move around.\n */\ntypedef char grid_t[MAXSIZE][MAXSIZE];\n\n/*\n * Print the town layout to the \"out\" stream and show the location of every\n * NPC in \"npcmap\" by printing the appropriate NPC character on top of the\n * layout.\n */\nvoid output(ostream &out, grid_t grid, npcmap_t &npcmap, int width, int height)\n{\n    npcmap_t::iterator i;\n\n    /* Temporarily add the NPCs to the grid for printing */\n    for(i = npcmap.begin(); i != npcmap.end(); ++i) {\n        grid[i->second.first][i->second.second] = i->first;\n    }\n\n    for(int row = 0; row < height; row++) {\n        for(int col = 0; col < width; col++) {\n            out << grid[row][col];\n        }\n        out << endl;\n    }    \n\n    /* Reset NPC locations back to empty spaces */\n    for(i = npcmap.begin(); i != npcmap.end(); ++i) {\n        grid[i->second.first][i->second.second] = \'.\';\n    }\n}\n\n/*\n * DEBUG ONLY: Simulate one turn for a given NPC. The current command in\n * \"cmdlist\" (current as determined by \"instptr\") is executed and the NPC\n * position \"pos\" updated. Once the current command has finished executing,\n * the \"instptr\" is advanced (possibly wrapping around) to the next command.\n */ \nvoid simulate_one(grid_t grid, int width, int height, coord_t &instptr,\n    cmdlist_t &cmdlist, coord_t &pos)\n{\n    int ip = instptr.first;\n    \n    /*\n     * If NPC\'s command is finished, increment instruction pointer but skip\n     * over any commands who had their delay value reduced to zero by fixup().\n     */\n    while(instptr.second == 0) {\n        ip = (ip + 1) %  cmdlist.size();\n        instptr.first = ip;\n        instptr.second = cmdlist[ip].second;\n    }\n\n    /* Execute current command and decrement instruction delay */\n    pos.first += VERB[cmdlist[ip].first].first;\n    pos.second += VERB[cmdlist[ip].first].second;\n    instptr.second--;\n}\n\n/*\n * DEBUG ONLY: Simulate one turn across all NPCs in the data set. The\n * \"instptr\" map holds \"instruction pointers\" for every NPC. Every\n * instruction pointer is a pair (cmdnum, delay) where \"cmdnum\" is an index\n * into cmdmap of the currently executing command and \"delay\" is the number\n * of turns remaining until the current command finishes executing.\n */\nvoid simulate_all(grid_t grid, int width, int height, npcmap_t &instptr,\n    cmdmap_t &cmdmap, npcmap_t &npcmap)\n{\n    npcmap_t::iterator i;\n\n    /* Move each NPC by one turn */\n    for(i = npcmap.begin(); i != npcmap.end(); ++i) {        \n        char npc = i->first;\n        \n        simulate_one(grid, width, height, instptr[npc],\n            cmdmap[npc], npcmap[npc]);\n    }\n}\n\n/*\n * Execute a command \"cmd\" a single turn by updating the position of \"oldpos\" If\n * this command caused the NPC to hit a solid object or the edge of the map,\n * then return true and don\'t update \"oldpos\". Used by fixup() to detect\n * collisions in the script and to re-write the script accordingly.\n */\nbool execute(coord_t cmd, coord_t &oldpos, grid_t grid, int width, int height)\n{\n    coord_t pos;\n\n    pos.first = oldpos.first + VERB[cmd.first].first;\n    pos.second = oldpos.second + VERB[cmd.first].second;\n\n    if(pos.first < 0 || pos.second < 0 || pos.first >= height ||\n        pos.second >= width || grid[pos.first][pos.second] != \'.\')\n        return true;\n    \n    oldpos = pos;\n    return false;\n}\n\n/*\n * Execute the \"cmdlist\" script one time through and if any collisions are\n * found, re-write it to a form that avoids the collisions all together by\n * inserting the appropriate number of PAUSEs. Also if the script is not\n * already inherently cyclic, make it so by appending a reversed version\n * of the collision-free script that will return the NPC to its original\n * location. Finally, this function computes the total cycle length (in turns)\n * of the NPC\'s walk script and returns it. The cycle length is used for\n * a modulo optimization later on.\n */\nint fixup(grid_t grid, coord_t pos, int width, int height, cmdlist_t &cmdlist)\n{\n    cmdlist_t::iterator i;\n    coord_t start = pos;\n    \n    /*\n     * Execute through all the commands in the list and run each command for the\n     * specified number of turns. If we hit a wall or edge, split this command\n     * into a shortened original and a PAUSE for the remainder of the\n     * \"collision\" time.\n     */\n    for(i = cmdlist.begin(); i != cmdlist.end(); ++i) {\n        coord_t cmd = *i;\n        \n        for(int j = 0; j < cmd.second; j++) {\n            if(execute(cmd, pos, grid, width, height)) {\n                *i = coord_t(cmd.first, j);\n                ++i;\n                i = cmdlist.insert(i, coord_t(PAUSE, cmd.second - j));\n                break;\n            }\n        }\n    }\n    \n    /* If the script is reversible, make it cyclic */\n    if(pos != start) {\n        int size = cmdlist.size();\n        cmdlist.resize(size * 2);\n        \n        /* Append a duplicated and reversed command list */\n        copy(&cmdlist[0], &cmdlist[size], &cmdlist[size]);\n        reverse(&cmdlist[size], &cmdlist[size * 2]);\n        \n        /* Reverse directions of individual commands in list */\n        for(int i = size; i < size * 2; i++) {\n            cmdlist[i].first = REVERSE[cmdlist[i].first];\n        }\n    }\n    \n    /* Calculate the total cycle length of the walk script */\n    int total = 0;\n    for(i = cmdlist.begin(); i != cmdlist.end(); ++i) {\n        total += i->second;\n    }\n    return total;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Initialize the global NAMES[] dictionary */\n    NAMES[\"NORTH\"] = 0;\n    NAMES[\"SOUTH\"] = 1;\n    NAMES[\"EAST\"] = 2;\n    NAMES[\"WEST\"] = 3;\n    NAMES[\"PAUSE\"] = 4;\n    \n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {   \n        int npc_num, npc_idx;     /* For looping over command lists */\n        int width, height, turns; /* Parameters from data set input */\n        npcmap_t npcmap;          /* Tracks position of each NPC */\n        npcmap_t instptr;         /* DEBUG ONLY: current command during sim */\n        cmdmap_t cmdmap;          /* Command list per NPC */\n        map<char, int> cycle;     /* Total walk cycle length per NPC */        \n        grid_t grid;              /* Town layout */\n        \n        cin >> npc_num >> height >> width;\n        ASSERT(1 <= npc_num && npc_num <= 35);\n        ASSERT(1 <= height && height <= 40);\n        ASSERT(1 <= width && width <= 40);\n        \n        /* Read in the town grid */\n        for(int row = 0; row < height; row++) {\n            for(int col = 0; col < width; col++) {\n                char npc;\n                \n                cin >> npc;\n                \n                /* Numbers and letters are NPC locations; record in npcmap */\n                if(isalnum(npc)) {\n                    npcmap[npc] = coord_t(row, col);\n                    grid[row][col] = \'.\';\n                }\n                \n                /* Otherwise it\'s a wall or empty space; record in grid */\n                else {\n                    ASSERT(npc == \'.\' || npc == \'#\');\n                    grid[row][col] = npc;\n                }\n            }\n        }\n        \n#if defined(STEP) || defined(DEBUG)\n        cerr << \"DATA SET #\" << data_idx + 1 << endl;\n#endif        \n        /* Read in the command scripts for each NPC */\n        for(npc_idx = 0; npc_idx < npc_num; npc_idx++) {            \n            int cmd_idx, cmd_num;\n            char npc;\n\n            /* Read NPC id and command count */\n            cin >> npc >> cmd_num;\n            ASSERT(npcmap.find(npc) != npcmap.end());\n            ASSERT(1 <= cmd_num && cmd_num <= 20);\n            \n            /* DEBUG ONLY: Init \"instruction pointer\" used by simulate_all() */\n            instptr[npc] = coord_t(-1, 0);\n\n            /* Read the list of commands into cmdmap[npc] list */\n            for(cmd_idx = 0; cmd_idx < cmd_num; cmd_idx++) {\n                string word;\n                int value;\n                \n                cin >> word >> value;\n                ASSERT(NAMES.find(word) != NAMES.end());\n                ASSERT(1 <= value <= 40);\n                \n                cmdmap[npc].push_back(coord_t(NAMES[word], value));\n            }\n            \n            /* Detect collisions and make reversible walks cyclic */\n            cycle[npc] = fixup(grid, npcmap[npc], width, height, cmdmap[npc]);\n            \n#if defined(STEP) || defined(DEBUG)\n            /* DEBUG ONLY: Show transformed command list with no collisions */\n            cerr << \"Transformed script \" << npc << \":\" << endl;\n            \n            cmdlist_t::iterator i;\n            for(i = cmdmap[npc].begin(); i != cmdmap[npc].end(); ++i) {\n                cerr << PRINT[i->first] << \" \" << i->second << endl;\n            }\n            \n            cerr << \"Cycle length: \" << cycle[npc] << endl << endl;\n#endif\n        }\n        \n        /* Read the number of turns to simulate for */\n        cin >> turns;\n        ASSERT(1 <= turns && turns <= 1000000);\n\n#ifdef STEP\n        /* DEBUG ONLY: Show initial grid layout before simulation */\n        cerr << \"Initial layout:\" << endl;\n        output(cerr, grid, npcmap, width, height);\n        cerr << endl;\n\n        /* DEBUG ONLY: Run a full simulation to show how NPCs move */\n        for(int i = 0; i < turns; i++) {        \n            simulate_all(grid, width, height, instptr, cmdmap, npcmap);\n            \n            cerr << \"Turn \" << i + 1 << \":\" << endl;\n            output(cerr, grid, npcmap, width, height);\n            cerr << endl;\n        }\n#else\n        /*\n         * Because every NPC movement is cyclic, we can reduce the computation\n         * time by separately simulating only \"turns modulo cycle length\" for\n         * every NPC.\n         */      \n        for(npcmap_t::iterator i = npcmap.begin(); i != npcmap.end(); ++i) {\n            int ip = 0;\n            char npc = i->first;\n            int npcturns = turns % cycle[npc];\n\n            coord_t &pos = npcmap[npc];\n            cmdlist_t &cmdlist = cmdmap[npc];\n            \n            /*\n             * We can get a further optimization by executing a single command\n             * per loop iteration and \"scaling\" the distance moved by the\n             * command\'s \"value\".\n             */\n            while(npcturns) {                              \n                int verb = cmdlist[ip].first;\n                int value = min(npcturns, cmdlist[ip].second);\n\n                /* Execute current command and decrement instruction delay */\n                pos.first += VERB[verb].first * value;\n                pos.second += VERB[verb].second * value;\n                \n                /* Advance to next instruction in command list */\n                npcturns -= value;\n                ip = (ip + 1) % cmdlist.size();\n            }\n        }\n#endif     \n        /* Show the final state of the town */\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n        output(cout, grid, npcmap, width, height);        \n    }\n} \n\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(303,'#include <math.h>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <utility>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, each data set will print a C*C table\n * showing the distances in kilometers between every pair of cities in the data\n * set. It also prints the distances that were selected for the minimum\n * spanning tree along with the total minimum cost of the tree. Finally, it\n * also produces a series of files named \"planetsN.dot\" (one for each data set)\n * which are Graphviz representations of the minimum spanning tree that was\n * computed. These can be fed to the \"neato\" program to produce a visual graph\n * layout for verification purposes.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/*\n * DEBUG ONLY: The \"neato\" output file currently being written out\n */\n#ifdef DEBUG\nofstream graphout;\n#endif\n\n/*\n * DEBUG ONLY: Data type for decimal numbers. This can be changed from double\n * precision to single precision float in order to evaluate the effect of\n * round off errors on the final answer.\n */\ntypedef double decimal_t;\n\n/*\n * This data structure holds the distances (in km) between every pair of cities\n * in the data set. It maps a pair of city numbers to the scalar distance\n * between them. Even though distances are commutative (i.e. distnace (N. M) is\n * the same as (M, N)), this data structure holds the full C*C matrix simply\n * because it\'s easier to look up these values when running the minimum spanning\n * tree algorithm.\n */\ntypedef pair<int, int> edge_t;\ntypedef map<edge_t, decimal_t> distmap_t;\n\n/*\n * Priority queue for selecting the next lowest cost edge in Prim\'s minimum\n * spanning tree algorithm. The priority queue is ordered in ascending order by\n * edge cost (i.e. distance) and each queue entry also contains the (from, to)\n * city numbers that define this edge. The TO city number is needed to find the\n * next set of outgoing edges from this city on the next iteration of Prim\'s\n * algorithm. The FROM city number is there purely for debug output purposes.\n */\ntypedef pair<decimal_t, edge_t> queuedata_t;\ntypedef priority_queue<queuedata_t, vector<queuedata_t>, greater<queuedata_t> >\n    queue_t;\n\n/* A (latitude, longitude) coordinate pair */\ntypedef pair<decimal_t, decimal_t> coord_t;\n\n/* A 3D vector in rectangular coordinates */\ntypedef struct { decimal_t x, y, z; } rect_t;\n\n/* Multiplying 3D vectors together computes dot product */\ninline decimal_t operator*(rect_t const &a, rect_t const &b)\n{\n    return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\n/*\n * The (latitude, longitude) coordinate pair can be treated as spherical\n * coordinates in 3D space, where latitude is theta (i.e. zenith) and longitude\n * is phi (i.e. azimuth). This allows us to convert the coordinates into a\n * rectangular form. For this conversion we assume a unit sphere (radius 1).\n *\n * Since the rectangular coordinates are only used for computing angles between\n * pairs of vectors, the sphere radius does not actually matter at this point.\n * In fact, using a unit sphere means that we don\'t have to find the magnitude\n * of each vector later on since all the vectors we return are of unit length.\n *\n * Finally, the angular measurements in the dataset are given as degrees while\n * the math.h trigonometric functions expect radians so we have to do the\n * conversion before calling sin() and cos().\n */\nrect_t torect(coord_t coord)\n{\n    /* Convert angle measurements from degrees to radians */\n    coord.first = coord.first * 2 * M_PI / 360;\n    coord.second = coord.second * 2 * M_PI / 360;\n   \n    /* Convert spherical coordinates to rectangular */\n    rect_t rect;   \n    rect.x = cos(coord.first) * sin(coord.second);\n    rect.y = cos(coord.first) * cos(coord.second);\n    rect.z = sin(coord.first);\n    \n    return rect;\n}\n\n/*\n * Given two points on the surface of the sphere (specified a two 3D vectors)\n * and given the diameter of the planet, compute the distance between the two\n * points along the surface of the sphere.\n *\n * The two vectors define a plane that passes through the origin of the sphere,\n * and the intersection of this plane with the surface of the sphere forms\n * a great circle (i.e. a circle that passes through the sphere\'s origin).\n * The shortest distance between the two points will be an arc along the\n * perimiter of this great circle.\n *\n * The dot product formula states: x * y = cos(A) |x| |y|\n * In other words, the dot product of two vectors equals the product of the\n * magnitudes multiplied by the cosine of the angle between the two vectors.\n * By re-arranging the formula we can calculate the angle A with acos().\n * Also since we know that torect() only returns unit length vectors, we can\n * simplify the magnitude multiplication out of the dot product equation.\n *\n * Once we know angle A, we can calculate the arc length by first computing\n * the perimeter of the great circle and then multiplying it by the fraction\n * A/2pi. Also note that the longest distance you can possibly have is half\n * the perimeter (i.e. opposite ends of the sphere like the North and South\n * poles).\n */\ndecimal_t distance(rect_t const &a, rect_t const &b, decimal_t diameter)\n{\n    decimal_t perimeter = M_PI * diameter;\n    decimal_t fraction = acos(a * b) / (2 * M_PI);\n    return fraction * perimeter;\n}\n\n/*\n * Add \"city\" to the \"visited\" set and add to the priority \"queue\" any edges\n * from \"city\" to all other unvisitied cities.\n */\nvoid prim_visit(int city, int city_num, distmap_t distmap, set<int> &visited,\n    queue_t &queue)\n{\n    visited.insert(city);\n\n    for(int i = 0; i < city_num; i++) {\n        if(visited.find(i) == visited.end()) {\n            edge_t edge(city, i);\n            queue.push(queuedata_t(distmap[edge], edge));\n        }\n    }\n}\n\n/*\n * Use Prim\'s algorithm to compute a minimum spanning tree that connects all of\n * the cities together. We start with a complete graph that connects every\n * pair of cities together. We then arbitrarily pick city number 0 as the\n * starting point of the algorithm.\n *\n * DEBUG ONLY: Print out the edge costs of the select minimum spanning tree\n * to stderr, and write out the complete minimum spanning tree in Graphviz\n * format to \"planetsX.neato\" files.\n */\ndecimal_t prim(distmap_t &distmap, vector<coord_t> city)\n{\n    decimal_t total = 0; /* Accumulated total length of visited edges */    \n    set<int> visited;    /* Track which cities have been visited already */\n    queue_t queue;       /* Priority queue to select next minimum cost edge */\n    \n#ifdef DEBUG\n    cerr << \"MSP: \";\n    graphout << \"graph G {\" << endl;\n#endif\n\n    /* Arbitrarily begin with the 0th city. */\n    prim_visit(0, city.size(), distmap, visited, queue);\n    \n    /* Keep running until all cities are visited */\n    while(visited.size() != city.size()) {\n        queuedata_t data;\n        \n        /* Get minimum cost edge to an unvisited city from any visited one */\n        do { \n            /* SANITY CHECK: If unvisited cities remain then so must an edge */\n            ASSERT(queue.size());\n            \n            data = queue.top();\n            queue.pop();\n            \n        /* Skip over edges pointing TO already visited cities */\n        } while(visited.find(data.second.second) != visited.end());\n\n#ifdef DEBUG        \n        coord_t from = city[data.second.first];\n        coord_t to = city[data.second.second];\n        \n        graphout << \"    \\\"\" << from.first << \"  \" << from.second << \"\\\"\";\n        graphout << \" -- \";\n        graphout << \"\\\"\" << to.first << \"  \" << to.second << \"\\\"\";\n        graphout << \" [label = \" << distmap[data.second] << \"]\" << endl;\n\n        cerr << data.first << \" \";\n#endif\n\n        /* Accumulate edge cost and add the next set of edges to queue */\n        total += data.first;\n        prim_visit(data.second.second, city.size(), distmap, visited, queue);\n    }\n\n#ifdef DEBUG\n    graphout << \"}\" << endl;\n#endif\n    \n    return total;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        decimal_t diameter, length;\n        vector<coord_t> city;\n        distmap_t distmap;\n        int city_num;\n        \n        /* Read in diameter, length, and city count */\n        cin >> diameter >> length >> city_num;\n        ASSERT(1 <= diameter && diameter <= 1000000);\n        ASSERT(1 <= length && length <= 1000000);\n        ASSERT(1 <= city_num && city_num <= 100);\n        \n        /* Read in the list of city coordinates */\n        for(int i = 0; i < city_num; i++) {\n            decimal_t latitude, longitude;\n\n            cin >> latitude >> longitude;\n            ASSERT(-90 <= latitude && latitude <= 90);\n            ASSERT(-180 <= longitude && longitude <= 180);\n            \n            city.push_back(coord_t(latitude, longitude));\n        }\n        \n        /*\n         * Precompute the C*C matrix of distances (in km) between all cities\n         * and store the results in the \"distance map\" for later use by the\n         * minimum spanning tree algorithm.\n         *\n         * DEBUG ONLY: Print a C*C table showing the computed distances to\n         * verify that the calculations are correct and to evaluate the effect\n         * due to round off errors with floats vs doubles.         \n         */\n        for(int i = 0; i < city_num; i++) {\n            for(int j = 0; j < city_num; j++) {\n                decimal_t dist = distance(torect(city[i]), torect(city[j]),\n                    diameter);\n#ifdef DEBUG\n                cerr << setw(4) << dist << \" \";\n#endif\n                distmap[edge_t(i, j)] = dist;\n            }\n#ifdef DEBUG\n            cerr << endl;\n#endif            \n        }\n\n#ifdef DEBUG\n        /* DEBUG ONLY: Open \"neato\" graph file for output */\n        ostringstream filename;\n        filename << \"planets\" << data_idx + 1 << \".neato\";\n        graphout.open(filename.str().c_str(), ios::trunc);\n#endif        \n        /* Compute the minimum cost spanning tree */\n        decimal_t mincost = prim(distmap, city);\n        \n        /* Print the answer for the dataset */        \n#ifdef DEBUG\n        cerr << \"= \" << mincost << endl;\n        cerr << (mincost <= length ? \"IS POSSIBLE\" : \"IS NOT POSSIBLE\") << endl;\n        graphout.close();\n#endif\n        cout << (mincost <= length ? \"IS POSSIBLE\" : \"IS NOT POSSIBLE\") << endl;\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n#ifdef DEBUG\n    /* DEBUG ONLY: Setup floating point format for debug output on stderr */\n    cerr.precision(0);\n    cerr.setf(ios::fixed);\n    cerr.fill(\'0\');\n#endif\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(304,'#include <math.h>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <utility>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DDEBUG, each data set will print a C*C table\n * showing the distances in kilometers between every pair of cities in the data\n * set. It also prints the distances that were selected for the minimum\n * spanning tree along with the total minimum cost of the tree. Finally, it\n * also produces a series of files named \"planetsN.dot\" (one for each data set)\n * which are Graphviz representations of the minimum spanning tree that was\n * computed. These can be fed to the \"neato\" program to produce a visual graph\n * layout for verification purposes.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/*\n * DEBUG ONLY: The \"neato\" output file currently being written out\n */\n#ifdef DEBUG\nofstream graphout;\n#endif\n\n/*\n * DEBUG ONLY: Data type for decimal numbers. This can be changed from double\n * precision to single precision float in order to evaluate the effect of\n * round off errors on the final answer.\n */\ntypedef double decimal_t;\n\n/*\n * This data structure holds the distances (in km) between every pair of cities\n * in the data set. It maps a pair of city numbers to the scalar distance\n * between them. Even though distances are commutative (i.e. distnace (N. M) is\n * the same as (M, N)), this data structure holds the full C*C matrix simply\n * because it\'s easier to look up these values when running the minimum spanning\n * tree algorithm.\n */\ntypedef pair<int, int> edge_t;\ntypedef map<edge_t, decimal_t> distmap_t;\n\n/*\n * Priority queue for selecting the next lowest cost edge in Prim\'s minimum\n * spanning tree algorithm. The priority queue is ordered in ascending order by\n * edge cost (i.e. distance) and each queue entry also contains the (from, to)\n * city numbers that define this edge. The TO city number is needed to find the\n * next set of outgoing edges from this city on the next iteration of Prim\'s\n * algorithm. The FROM city number is there purely for debug output purposes.\n */\ntypedef pair<decimal_t, edge_t> queuedata_t;\ntypedef priority_queue<queuedata_t, vector<queuedata_t>, greater<queuedata_t> >\n    queue_t;\n\n/* A (latitude, longitude) coordinate pair */\ntypedef pair<decimal_t, decimal_t> coord_t;\n\n/* A 3D vector in rectangular coordinates */\ntypedef struct { decimal_t x, y, z; } rect_t;\n\n/* Multiplying 3D vectors together computes dot product */\ninline decimal_t operator*(rect_t const &a, rect_t const &b)\n{\n    return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\n/*\n * The (latitude, longitude) coordinate pair can be treated as spherical\n * coordinates in 3D space, where latitude is theta (i.e. zenith) and longitude\n * is phi (i.e. azimuth). This allows us to convert the coordinates into a\n * rectangular form. For this conversion we assume a unit sphere (radius 1).\n *\n * Since the rectangular coordinates are only used for computing angles between\n * pairs of vectors, the sphere radius does not actually matter at this point.\n * In fact, using a unit sphere means that we don\'t have to find the magnitude\n * of each vector later on since all the vectors we return are of unit length.\n *\n * Finally, the angular measurements in the dataset are given as degrees while\n * the math.h trigonometric functions expect radians so we have to do the\n * conversion before calling sin() and cos().\n */\nrect_t torect(coord_t coord)\n{\n    /* Convert angle measurements from degrees to radians */\n    coord.first = coord.first * 2 * M_PI / 360;\n    coord.second = coord.second * 2 * M_PI / 360;\n   \n    /* Convert spherical coordinates to rectangular */\n    rect_t rect;   \n    rect.x = cos(coord.first) * sin(coord.second);\n    rect.y = cos(coord.first) * cos(coord.second);\n    rect.z = sin(coord.first);\n    \n    return rect;\n}\n\n/*\n * Given two points on the surface of the sphere (specified a two 3D vectors)\n * and given the diameter of the planet, compute the distance between the two\n * points along the surface of the sphere.\n *\n * The two vectors define a plane that passes through the origin of the sphere,\n * and the intersection of this plane with the surface of the sphere forms\n * a great circle (i.e. a circle that passes through the sphere\'s origin).\n * The shortest distance between the two points will be an arc along the\n * perimiter of this great circle.\n *\n * The dot product formula states: x * y = cos(A) |x| |y|\n * In other words, the dot product of two vectors equals the product of the\n * magnitudes multiplied by the cosine of the angle between the two vectors.\n * By re-arranging the formula we can calculate the angle A with acos().\n * Also since we know that torect() only returns unit length vectors, we can\n * simplify the magnitude multiplication out of the dot product equation.\n *\n * Once we know angle A, we can calculate the arc length by first computing\n * the perimeter of the great circle and then multiplying it by the fraction\n * A/2pi. Also note that the longest distance you can possibly have is half\n * the perimeter (i.e. opposite ends of the sphere like the North and South\n * poles).\n */\ndecimal_t distance(rect_t const &a, rect_t const &b, decimal_t diameter)\n{\n    decimal_t perimeter = M_PI * diameter;\n    decimal_t fraction = acos(a * b) / (2 * M_PI);\n    return fraction * perimeter;\n}\n\n/*\n * Add \"city\" to the \"visited\" set and add to the priority \"queue\" any edges\n * from \"city\" to all other unvisitied cities.\n */\nvoid prim_visit(int city, int city_num, distmap_t distmap, set<int> &visited,\n    queue_t &queue)\n{\n    visited.insert(city);\n\n    for(int i = 0; i < city_num; i++) {\n        if(visited.find(i) == visited.end()) {\n            edge_t edge(city, i);\n            queue.push(queuedata_t(distmap[edge], edge));\n        }\n    }\n}\n\n/*\n * Use Prim\'s algorithm to compute a minimum spanning tree that connects all of\n * the cities together. We start with a complete graph that connects every\n * pair of cities together. We then arbitrarily pick city number 0 as the\n * starting point of the algorithm.\n *\n * DEBUG ONLY: Print out the edge costs of the select minimum spanning tree\n * to stderr, and write out the complete minimum spanning tree in Graphviz\n * format to \"planetsX.neato\" files.\n */\ndecimal_t prim(distmap_t &distmap, vector<coord_t> city)\n{\n    decimal_t total = 0; /* Accumulated total length of visited edges */    \n    set<int> visited;    /* Track which cities have been visited already */\n    queue_t queue;       /* Priority queue to select next minimum cost edge */\n    \n#ifdef DEBUG\n    cerr << \"MSP: \";\n    graphout << \"graph G {\" << endl;\n#endif\n\n    /* Arbitrarily begin with the 0th city. */\n    prim_visit(0, city.size(), distmap, visited, queue);\n    \n    /* Keep running until all cities are visited */\n    while(visited.size() != city.size()) {\n        queuedata_t data;\n        \n        /* Get minimum cost edge to an unvisited city from any visited one */\n        do { \n            /* SANITY CHECK: If unvisited cities remain then so must an edge */\n            ASSERT(queue.size());\n            \n            data = queue.top();\n            queue.pop();\n            \n        /* Skip over edges pointing TO already visited cities */\n        } while(visited.find(data.second.second) != visited.end());\n\n#ifdef DEBUG        \n        coord_t from = city[data.second.first];\n        coord_t to = city[data.second.second];\n        \n        graphout << \"    \\\"\" << from.first << \"  \" << from.second << \"\\\"\";\n        graphout << \" -- \";\n        graphout << \"\\\"\" << to.first << \"  \" << to.second << \"\\\"\";\n        graphout << \" [label = \" << distmap[data.second] << \"]\" << endl;\n\n        cerr << data.first << \" \";\n#endif\n\n        /* Accumulate edge cost and add the next set of edges to queue */\n        total += data.first;\n        prim_visit(data.second.second, city.size(), distmap, visited, queue);\n    }\n\n#ifdef DEBUG\n    graphout << \"}\" << endl;\n#endif\n    \n    return total;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        decimal_t diameter, length;\n        vector<coord_t> city;\n        distmap_t distmap;\n        int city_num;\n        \n        /* Read in diameter, length, and city count */\n        cin >> diameter >> length >> city_num;\n        ASSERT(1 <= diameter && diameter <= 1000000);\n        ASSERT(1 <= length && length <= 1000000);\n        ASSERT(1 <= city_num && city_num <= 100);\n        \n        /* Read in the list of city coordinates */\n        for(int i = 0; i < city_num; i++) {\n            decimal_t latitude, longitude;\n\n            cin >> latitude >> longitude;\n            ASSERT(-90 <= latitude && latitude <= 90);\n            ASSERT(-180 <= longitude && longitude <= 180);\n            \n            city.push_back(coord_t(latitude, longitude));\n        }\n        \n        /*\n         * Precompute the C*C matrix of distances (in km) between all cities\n         * and store the results in the \"distance map\" for later use by the\n         * minimum spanning tree algorithm.\n         *\n         * DEBUG ONLY: Print a C*C table showing the computed distances to\n         * verify that the calculations are correct and to evaluate the effect\n         * due to round off errors with floats vs doubles.         \n         */\n        for(int i = 0; i < city_num; i++) {\n            for(int j = 0; j < city_num; j++) {\n                decimal_t dist = distance(torect(city[i]), torect(city[j]),\n                    diameter);\n#ifdef DEBUG\n                cerr << setw(4) << dist << \" \";\n#endif\n                distmap[edge_t(i, j)] = dist;\n            }\n#ifdef DEBUG\n            cerr << endl;\n#endif            \n        }\n\n#ifdef DEBUG\n        /* DEBUG ONLY: Open \"neato\" graph file for output */\n        ostringstream filename;\n        filename << \"planets\" << data_idx + 1 << \".neato\";\n        graphout.open(filename.str().c_str(), ios::trunc);\n#endif        \n        /* Compute the minimum cost spanning tree */\n        decimal_t mincost = prim(distmap, city);\n        \n        /* Print the answer for the dataset */        \n#ifdef DEBUG\n        cerr << \"= \" << mincost << endl;\n        cerr << (mincost <= length ? \"IS POSSIBLE\" : \"IS NOT POSSIBLE\") << endl;\n        graphout.close();\n#endif\n        cout << (mincost <= length ? \"IS POSSIBLE\" : \"IS NOT POSSIBLE\") << endl;\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n#ifdef DEBUG\n    /* DEBUG ONLY: Setup floating point format for debug output on stderr */\n    cerr.precision(0);\n    cerr.setf(ios::fixed);\n    cerr.fill(\'0\');\n#endif\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(305,'#include <iostream>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        int image_idx, image_num;\n        int total = 0;\n\n        cin >> image_num;\n        ASSERT(1 <= image_num && image_num <= 10);\n        \n        /* Compute size (in sq.in) of a complete pattern */\n        for(image_idx = 0; image_idx < image_num; image_idx++) {\n            int sqin, ratio;\n            \n            cin >> sqin >> ratio;\n            ASSERT(1 <= sqin && sqin <= 1000);\n            ASSERT(1 <= ratio && ratio <= 100);\n            \n            total += sqin * ratio;\n        }\n        \n        /*\n         * There are 36*36=1296 inches in one square yard. Print out how many\n         * complete image patterns will fit within 1, 2, and 3 square yards.\n         */\n        cout << 1296 / total << \" \";\n        cout << 1296 * 2 / total << \" \";\n        cout << 1296 * 3 / total << endl;\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(306,'#include <iostream>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        int image_idx, image_num;\n        int total = 0;\n\n        cin >> image_num;\n        ASSERT(1 <= image_num && image_num <= 10);\n        \n        /* Compute size (in sq.in) of a complete pattern */\n        for(image_idx = 0; image_idx < image_num; image_idx++) {\n            int sqin, ratio;\n            \n            cin >> sqin >> ratio;\n            ASSERT(1 <= sqin && sqin <= 1000);\n            ASSERT(1 <= ratio && ratio <= 100);\n            \n            total += sqin * ratio;\n        }\n        \n        /*\n         * There are 36*36=1296 inches in one square yard. Print out how many\n         * complete image patterns will fit within 1, 2, and 3 square yards.\n         */\n        cout << 1296 / total << \" \";\n        cout << 1296 * 2 / total << \" \";\n        cout << 1296 * 3 / total << endl;\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on failed data extraction in >> operator */\n    cin.exceptions(ios::failbit);\n    \n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(307,'#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <utility>\n#include <vector>\n#include <limits>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Maximum edge cost; used to indicate that a node is unreachable */\n#define MAXCOST (numeric_limits<int>::max())\n\n/*\n * This adjacency list data structure holds the list of all edges in the data\n * set (and associated \"aging\" costs; years \"gained back\" are negative cost\n * edges). It maps a (departure, arrival) pair to the years aged by traveling\n * through the wormhole. It also contains \"implicit\" edges that represent\n * having to wait for some number of years while a new wormhole arrives.\n * \n */\ntypedef pair<int, int> edge_t;\ntypedef map<edge_t, int> costmap_t;\n\n/*\n * Use the Bellman-Ford algorithm to find the shortest path from start year\n * to end year and return the total cost along that path. Becuase the graph\n * contains negative cost edges, the less efficient Bellman-Ford algorithm\n * must be used instead of Dijkstra\'s algorithm because Dijkstra\'s optimizes\n * too early and could produce incorrect results. We also don\'t need an\n * explicit check for negative cost cycles because the problem statement\n * simply won\'t allow them.\n */\nint findpath(costmap_t &costmap, set<int> &years, int start, int end)\n{\n    map<int, int> dist;\n    map<int, int> pred;\n\n    /* Initialize \"shortest path distance\" map to default \"unreachable\" cost */\n    for(set<int>::iterator i = years.begin(); i != years.end(); ++i) {\n        dist[*i] = MAXCOST;\n    }\n    \n    /* The node we start from is 0 years away by definition */\n    dist[start] = 0;\n    \n    /*\n     * Run the main body of the Bellman-Ford algorithm. Note that we could \n     * break out of the loop as soon as a complete iteration makes no\n     * more changes to the \"dist\" map. However, looping the full amount\n     * helps establish the maximum running time for the algorithm.\n     */\n    for(int i = 0; i < years.size() - 1; i++) {        \n        for(costmap_t::iterator j = costmap.begin(); j != costmap.end(); ++j) {\n            if(dist[j->first.first] != MAXCOST) {\n                int cost = dist[j->first.first] + j->second;\n                \n                if(cost < dist[j->first.second]) {\n                    dist[j->first.second] = cost;\n                    pred[j->first.second] = j->first.first;\n                }\n            }\n        }\n    }\n\n    /*\n     * DEBUG ONLY: Show the shortest path by highlighting the nodes on the\n     * path in the Graphiviz output file.\n     */\n#ifdef DEBUG\n    if(dist[end] != MAXCOST) {\n        int i, j;\n        cerr << end;\n\n        for(i = end; pred.find(i) != pred.end(); i = j) {\n            j = pred[i];\n            cerr << \" <<\" << costmap[edge_t(j, i)] << \"<< \";\n            cerr << j;\n        }\n        cerr << \" = \" << dist[end] << endl;\n    }\n#endif\n    \n    return dist[end];\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        set<int> years;     /* Any year seen in input; all nodes in graph */\n        vector<int> agents; /* List of destinations for each agent */\n        costmap_t costs;    /* Adjecency list of wormholes & implicit waits */\n        int start;          /* Starting year for all agents */\n\n#ifdef DEBUG\n        /* DEBUG ONLY: Write a graph representation to \"dot\" file */\n        ostringstream filename;        \n        filename << \"time-travel\" << data_idx + 1 << \".dot\";\n        \n        ofstream graph(filename.str().c_str(), ios::trunc);\n        graph << \"digraph G {\" << endl;\n#endif\n\n        /* Read in total number of wormholes W */\n        int hole_num, hole_idx;\n        cin >> hole_num;\n        ASSERT(1 <= hole_num && hole_num <= 100);\n\n        /* Read in the list of wormholes for this data set */\n        for(hole_idx = 0; hole_idx < hole_num; hole_idx++) {\n            int depart, arrive, cost;\n            cin >> depart >> arrive;\n            ASSERT(1 <= depart && depart <= 9999);\n            ASSERT(1 <= arrive && arrive <= 9999);\n            \n            /* Add to set of all nodes in graph; usef for implicit edges */\n            years.insert(depart);\n            years.insert(arrive);\n            \n            /* Compute wormhole traveling costs (negative for backwards) */\n            if(depart <= arrive) {\n                cost = (arrive - depart) / 2;\n            } else {\n                cost = (arrive - depart) / 4;\n            }\n            \n            /* Record the cost in the adjacency list */\n            costs[edge_t(depart, arrive)] = cost;\n#ifdef DEBUG\n            graph << \"    \" << depart << \" -> \" << arrive <<\n                \" [label=\" << cost << \"]\" << endl;\n#endif                       \n        }\n        \n        /* Read in the starting year */\n        cin >> start;\n        ASSERT(1 <= start && start <= 9999);\n        years.insert(start);\n        \n#ifdef DEBUG\n        graph << \"    \" << start << \" [label=\\\"\" << start << \"\\\\n(S)\\\"]\" << endl;\n#endif        \n        \n        /* Read in total number of missions/agents M */\n        int agent_num, agent_idx;\n        cin >> agent_num;\n        ASSERT(1 <= agent_num && agent_num <= 100);\n                \n        /* Read in the list of final destinations for each agent */\n        for(agent_idx = 0; agent_idx < agent_num; agent_idx++) {\n            int dest;\n            cin >> dest;\n            ASSERT(1 <= dest && dest <= 9999);\n#ifdef DEBUG\n            graph << \"    \" << dest << \" [label=\\\"\" << dest <<\n                \"\\\\n(\" << agent_idx + 1 << \")\\\"]\" << endl;\n#endif                    \n            years.insert(dest);\n            agents.push_back(dest);\n        }\n        \n        /*\n         * For every pair of years (X, Y) in the input such that X < Y, compute\n         * an \"implicit\" edge that represents having to wait from year X to\n         * year Y if there was no explicit wormhole edge (X, Y) in data set.\n         * Note that STL sets are already in ascending order therefore an\n         * explicit sort() is not required.\n         */\n        set<int>::iterator i, j;\n        for(i = j = years.begin(), ++j; j != years.end(); ++i, ++j) {\n            edge_t edge(*i, *j);\n\n            if(costs.find(edge) == costs.end()) {\n                costs[edge] = *j - *i;\n#ifdef DEBUG\n                graph << \"    \" << *i << \" -> \" << *j <<\n                    \" [label=\" << *j - *i << \", style=dashed]\" << endl;\n#endif\n            }\n        }  \n\n        /* Print the data set label */\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n#ifdef DEBUG\n        cerr << \"DATA SET #\" << data_idx + 1 << endl;\n#endif\n\n        /*\n         * Now for each mission, compute the cost of traveling from the\n         * start to destination year and back. If that cost is less than\n         * MAXCOST then the mission is possible.\n         */\n        for(agent_idx = 0; agent_idx < agent_num; agent_idx++) {\n            int end = agents[agent_idx];        \n            \n            int travelcost = findpath(costs, years, start, end);\n            int returncost = findpath(costs, years, end, start);            \n            int totalcost;\n\n            if(travelcost == MAXCOST || returncost == MAXCOST) {\n                cout << \"IMPOSSIBLE\" << endl;\n#ifdef DEBUG\n                cerr << \"IMPOSSIBLE\" << endl;\n#endif\n            } else {\n                cout << travelcost + returncost << endl;\n#ifdef DEBUG\n                cerr << travelcost + returncost << endl;\n#endif\n            }\n\n#ifdef DEBUG\n        graph << \"}\" << endl;\n        graph.close();\n#endif\n        }\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(308,'#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <utility>\n#include <vector>\n#include <limits>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Maximum edge cost; used to indicate that a node is unreachable */\n#define MAXCOST (numeric_limits<int>::max())\n\n/*\n * This adjacency list data structure holds the list of all edges in the data\n * set (and associated \"aging\" costs; years \"gained back\" are negative cost\n * edges). It maps a (departure, arrival) pair to the years aged by traveling\n * through the wormhole. It also contains \"implicit\" edges that represent\n * having to wait for some number of years while a new wormhole arrives.\n * \n */\ntypedef pair<int, int> edge_t;\ntypedef map<edge_t, int> costmap_t;\n\n/*\n * Use the Bellman-Ford algorithm to find the shortest path from start year\n * to end year and return the total cost along that path. Becuase the graph\n * contains negative cost edges, the less efficient Bellman-Ford algorithm\n * must be used instead of Dijkstra\'s algorithm because Dijkstra\'s optimizes\n * too early and could produce incorrect results. We also don\'t need an\n * explicit check for negative cost cycles because the problem statement\n * simply won\'t allow them.\n */\nint findpath(costmap_t &costmap, set<int> &years, int start, int end)\n{\n    map<int, int> dist;\n    map<int, int> pred;\n\n    /* Initialize \"shortest path distance\" map to default \"unreachable\" cost */\n    for(set<int>::iterator i = years.begin(); i != years.end(); ++i) {\n        dist[*i] = MAXCOST;\n    }\n    \n    /* The node we start from is 0 years away by definition */\n    dist[start] = 0;\n    \n    /*\n     * Run the main body of the Bellman-Ford algorithm. Note that we could \n     * break out of the loop as soon as a complete iteration makes no\n     * more changes to the \"dist\" map. However, looping the full amount\n     * helps establish the maximum running time for the algorithm.\n     */\n    for(int i = 0; i < years.size() - 1; i++) {        \n        for(costmap_t::iterator j = costmap.begin(); j != costmap.end(); ++j) {\n            if(dist[j->first.first] != MAXCOST) {\n                int cost = dist[j->first.first] + j->second;\n                \n                if(cost < dist[j->first.second]) {\n                    dist[j->first.second] = cost;\n                    pred[j->first.second] = j->first.first;\n                }\n            }\n        }\n    }\n\n    /*\n     * DEBUG ONLY: Show the shortest path by highlighting the nodes on the\n     * path in the Graphiviz output file.\n     */\n#ifdef DEBUG\n    if(dist[end] != MAXCOST) {\n        int i, j;\n        cerr << end;\n\n        for(i = end; pred.find(i) != pred.end(); i = j) {\n            j = pred[i];\n            cerr << \" <<\" << costmap[edge_t(j, i)] << \"<< \";\n            cerr << j;\n        }\n        cerr << \" = \" << dist[end] << endl;\n    }\n#endif\n    \n    return dist[end];\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        set<int> years;     /* Any year seen in input; all nodes in graph */\n        vector<int> agents; /* List of destinations for each agent */\n        costmap_t costs;    /* Adjecency list of wormholes & implicit waits */\n        int start;          /* Starting year for all agents */\n\n#ifdef DEBUG\n        /* DEBUG ONLY: Write a graph representation to \"dot\" file */\n        ostringstream filename;        \n        filename << \"time-travel\" << data_idx + 1 << \".dot\";\n        \n        ofstream graph(filename.str().c_str(), ios::trunc);\n        graph << \"digraph G {\" << endl;\n#endif\n\n        /* Read in total number of wormholes W */\n        int hole_num, hole_idx;\n        cin >> hole_num;\n        ASSERT(1 <= hole_num && hole_num <= 100);\n\n        /* Read in the list of wormholes for this data set */\n        for(hole_idx = 0; hole_idx < hole_num; hole_idx++) {\n            int depart, arrive, cost;\n            cin >> depart >> arrive;\n            ASSERT(1 <= depart && depart <= 9999);\n            ASSERT(1 <= arrive && arrive <= 9999);\n            \n            /* Add to set of all nodes in graph; usef for implicit edges */\n            years.insert(depart);\n            years.insert(arrive);\n            \n            /* Compute wormhole traveling costs (negative for backwards) */\n            if(depart <= arrive) {\n                cost = (arrive - depart) / 2;\n            } else {\n                cost = (arrive - depart) / 4;\n            }\n            \n            /* Record the cost in the adjacency list */\n            costs[edge_t(depart, arrive)] = cost;\n#ifdef DEBUG\n            graph << \"    \" << depart << \" -> \" << arrive <<\n                \" [label=\" << cost << \"]\" << endl;\n#endif                       \n        }\n        \n        /* Read in the starting year */\n        cin >> start;\n        ASSERT(1 <= start && start <= 9999);\n        years.insert(start);\n        \n#ifdef DEBUG\n        graph << \"    \" << start << \" [label=\\\"\" << start << \"\\\\n(S)\\\"]\" << endl;\n#endif        \n        \n        /* Read in total number of missions/agents M */\n        int agent_num, agent_idx;\n        cin >> agent_num;\n        ASSERT(1 <= agent_num && agent_num <= 100);\n                \n        /* Read in the list of final destinations for each agent */\n        for(agent_idx = 0; agent_idx < agent_num; agent_idx++) {\n            int dest;\n            cin >> dest;\n            ASSERT(1 <= dest && dest <= 9999);\n#ifdef DEBUG\n            graph << \"    \" << dest << \" [label=\\\"\" << dest <<\n                \"\\\\n(\" << agent_idx + 1 << \")\\\"]\" << endl;\n#endif                    \n            years.insert(dest);\n            agents.push_back(dest);\n        }\n        \n        /*\n         * For every pair of years (X, Y) in the input such that X < Y, compute\n         * an \"implicit\" edge that represents having to wait from year X to\n         * year Y if there was no explicit wormhole edge (X, Y) in data set.\n         * Note that STL sets are already in ascending order therefore an\n         * explicit sort() is not required.\n         */\n        set<int>::iterator i, j;\n        for(i = j = years.begin(), ++j; j != years.end(); ++i, ++j) {\n            edge_t edge(*i, *j);\n\n            if(costs.find(edge) == costs.end()) {\n                costs[edge] = *j - *i;\n#ifdef DEBUG\n                graph << \"    \" << *i << \" -> \" << *j <<\n                    \" [label=\" << *j - *i << \", style=dashed]\" << endl;\n#endif\n            }\n        }  \n\n        /* Print the data set label */\n        cout << \"DATA SET #\" << data_idx + 1 << endl;\n#ifdef DEBUG\n        cerr << \"DATA SET #\" << data_idx + 1 << endl;\n#endif\n\n        /*\n         * Now for each mission, compute the cost of traveling from the\n         * start to destination year and back. If that cost is less than\n         * MAXCOST then the mission is possible.\n         */\n        for(agent_idx = 0; agent_idx < agent_num; agent_idx++) {\n            int end = agents[agent_idx];        \n            \n            int travelcost = findpath(costs, years, start, end);\n            int returncost = findpath(costs, years, end, start);            \n            int totalcost;\n\n            if(travelcost == MAXCOST || returncost == MAXCOST) {\n                cout << \"IMPOSSIBLE\" << endl;\n#ifdef DEBUG\n                cerr << \"IMPOSSIBLE\" << endl;\n#endif\n            } else {\n                cout << travelcost + returncost << endl;\n#ifdef DEBUG\n                cerr << travelcost + returncost << endl;\n#endif\n            }\n\n#ifdef DEBUG\n        graph << \"}\" << endl;\n        graph.close();\n#endif\n        }\n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(309,'#include <ctype.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DSTEP, the contents of the edit buffer are displayed\n * to stderr after every single command/character in the input. Usefull for\n * tracing the behavior of individual commands.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Print the edit buffer and cursor position to specified stream */\nvoid output(ostream &out, string buffer, int cursor)\n{\n    out << buffer.substr(0, cursor) << \'^\' << buffer.substr(cursor) << endl;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Skip over the trailing newline so getline() doesn\'t see it */\n    cin >> ws;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        string buffer, input;\n        int cursor = 0;\n\n        /* Read line of input and process one character at a time */        \n        getline(cin, input);\n        for(int i = 0; i < input.size(); i++) {\n            char key = input[i];\n            int pos;\n            \n            switch(key) {\n\n                /* Backspace (delete one char to the left); one gap left */\n                case \'x\':\n                    if(cursor > 0) {\n                        buffer.erase(cursor - 1, 1);\n                        cursor--;\n                    }\n                    break;\n                    \n                /* Erase non-space to the left; gap right of the stop char */\n                case \'K\':\n                    pos = buffer.rfind(\" \", cursor);\n                    if(pos == string::npos)\n                        pos == -1;\n                    if(pos != cursor - 1) {\n                        buffer.erase(pos + 1, cursor - pos - 1);\n                        cursor -= cursor - pos - 1;\n                    }\n                    break;\n                    \n                /* Duplicate one char from left to right; one gap right */\n                case \'c\':\n                    if(cursor > 0) {\n                        buffer.insert(cursor, 1, buffer[cursor - 1]);\n                        cursor++;\n                    }\n                    break;\n                                    \n                /* Duplicate non-space to the left; gap right of duplication */\n                case \'D\':\n                    pos = buffer.rfind(\" \", cursor);\n                    if(pos == string::npos)\n                        pos == -1;\n                    if(pos != cursor - 1) {\n                        buffer.insert(cursor, buffer.substr(pos + 1,\n                            cursor - pos - 1));\n                        cursor += cursor - pos - 1;\n                    }\n                    break;\n                                    \n                /* Reverse non-space to the left; no cursor change */\n                case \'R\':\n                    pos = buffer.rfind(\" \", cursor);\n                    if(pos == string::npos)\n                        pos == -1;\n                    if(pos != cursor - 1)                \n                        reverse(&buffer[pos + 1], &buffer[cursor]);\n                    break;\n                    \n                /* Delete all chars to the left; cursor to start */\n                case \'p\':\n                    buffer.erase(0, cursor);\n                    cursor = 0;\n                    break;\n                \n                /* Delete all chars to the right; no cursor change */\n                case \'W\':\n                    buffer.erase(cursor);\n                    break;\n                    \n                /* Move cursor one gap to the left */                \n                case \'h\':\n                    if(cursor > 0)\n                        cursor--;\n                    break;\n                    \n                /* Move cursor one gap to the right */\n                case \'L\':\n                    if(cursor < buffer.size())\n                        cursor++;\n                    break;                    \n                \n                /* Move cursor to the first gap on the line */                  \n                case \'f\':\n                    cursor = 0;\n                    break;\n                            \n                /* Move cursor to the last gap one the line */\n                case \'G\':\n                    cursor = buffer.size();\n                    break;\n                    \n                /* Insert char at cursor position; one gap right */\n                default:\n                    ASSERT(isalnum(key) || key == \' \');\n                    buffer.insert(cursor, 1, key);\n                    cursor++; \n                    break;\n            }\n#ifdef STEP\n            cerr << input.substr(i) << endl;\n            output(cerr, buffer, cursor);\n#endif            \n        }        \n        output(cout, buffer, cursor);\n#ifdef STEP\n        cerr << endl; \n#endif           \n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(310,'#include <ctype.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\n/*\n * DEBUG ONLY: If compiled -DSTEP, the contents of the edit buffer are displayed\n * to stderr after every single command/character in the input. Usefull for\n * tracing the behavior of individual commands.\n */\n\n/* SANITY CHECK: assertion macro for verifying input data and internal state */\n#define ASSERT(e) { if(!(e)) { cerr << #e << endl; throw; } }\n\n/* Print the edit buffer and cursor position to specified stream */\nvoid output(ostream &out, string buffer, int cursor)\n{\n    out << buffer.substr(0, cursor) << \'^\' << buffer.substr(cursor) << endl;\n}\n\n/* Main body of program */\nvoid process(void)\n{\n    int data_num, data_idx;\n\n    /* Read how many data sets to process */\n    cin >> data_num;\n    \n    /* Skip over the trailing newline so getline() doesn\'t see it */\n    cin >> ws;\n    \n    /* Process each data set separately */\n    for(data_idx = 0; data_idx < data_num; data_idx++) {\n        string buffer, input;\n        int cursor = 0;\n\n        /* Read line of input and process one character at a time */        \n        getline(cin, input);\n        for(int i = 0; i < input.size(); i++) {\n            char key = input[i];\n            int pos;\n            \n            switch(key) {\n\n                /* Backspace (delete one char to the left); one gap left */\n                case \'x\':\n                    if(cursor > 0) {\n                        buffer.erase(cursor - 1, 1);\n                        cursor--;\n                    }\n                    break;\n                    \n                /* Erase non-space to the left; gap right of the stop char */\n                case \'K\':\n                    pos = buffer.rfind(\" \", cursor);\n                    if(pos == string::npos)\n                        pos == -1;\n                    if(pos != cursor - 1) {\n                        buffer.erase(pos + 1, cursor - pos - 1);\n                        cursor -= cursor - pos - 1;\n                    }\n                    break;\n                    \n                /* Duplicate one char from left to right; one gap right */\n                case \'c\':\n                    if(cursor > 0) {\n                        buffer.insert(cursor, 1, buffer[cursor - 1]);\n                        cursor++;\n                    }\n                    break;\n                                    \n                /* Duplicate non-space to the left; gap right of duplication */\n                case \'D\':\n                    pos = buffer.rfind(\" \", cursor);\n                    if(pos == string::npos)\n                        pos == -1;\n                    if(pos != cursor - 1) {\n                        buffer.insert(cursor, buffer.substr(pos + 1,\n                            cursor - pos - 1));\n                        cursor += cursor - pos - 1;\n                    }\n                    break;\n                                    \n                /* Reverse non-space to the left; no cursor change */\n                case \'R\':\n                    pos = buffer.rfind(\" \", cursor);\n                    if(pos == string::npos)\n                        pos == -1;\n                    if(pos != cursor - 1)                \n                        reverse(&buffer[pos + 1], &buffer[cursor]);\n                    break;\n                    \n                /* Delete all chars to the left; cursor to start */\n                case \'p\':\n                    buffer.erase(0, cursor);\n                    cursor = 0;\n                    break;\n                \n                /* Delete all chars to the right; no cursor change */\n                case \'W\':\n                    buffer.erase(cursor);\n                    break;\n                    \n                /* Move cursor one gap to the left */                \n                case \'h\':\n                    if(cursor > 0)\n                        cursor--;\n                    break;\n                    \n                /* Move cursor one gap to the right */\n                case \'L\':\n                    if(cursor < buffer.size())\n                        cursor++;\n                    break;                    \n                \n                /* Move cursor to the first gap on the line */                  \n                case \'f\':\n                    cursor = 0;\n                    break;\n                            \n                /* Move cursor to the last gap one the line */\n                case \'G\':\n                    cursor = buffer.size();\n                    break;\n                    \n                /* Insert char at cursor position; one gap right */\n                default:\n                    ASSERT(isalnum(key) || key == \' \');\n                    buffer.insert(cursor, 1, key);\n                    cursor++; \n                    break;\n            }\n#ifdef STEP\n            cerr << input.substr(i) << endl;\n            output(cerr, buffer, cursor);\n#endif            \n        }        \n        output(cout, buffer, cursor);\n#ifdef STEP\n        cerr << endl; \n#endif           \n    }\n}\n\n/* Run program and print out any exceptions that occur */\nint main(void)\n{\n    /* Throw exceptions on EOF or failed data extraction in >> operator */\n    cin.exceptions(ios::eofbit | ios::failbit);\n\n    /* Run main body of code */\n    try {\n        process();\n    }\n    \n    /* Catch unexpected EOF or bad input data */\n    catch(ios::failure const &e) {\n        cerr << \"Unexpected EOF or data type mismatch on input\" << endl;\n    }\n\n    return 0;\n}\n\n'),(311,'#include<stdio.h>\r\nfloat fact(int x)\r\n{\r\n	int i;\r\n	float y=1;\r\n	for(i=1;i<=x;i++)\r\n	y*=i;\r\n	return y;\r\n	\r\n}\r\nint main()\r\n{\r\n	int m,n;\r\n	scanf(\"%d %d\",&m,&n);\r\n	printf(\"%.0f\\n\",fact(m)/fact(n)/fact(m-n));\r\n	return 0;\r\n}\r\n'),(312,'#include<stdio.h>\r\nint f(int a)\r\n{\r\n	int i,b;\r\n	b=1;\r\n	for(i=1;i<=a;i++)\r\n	b*=i;\r\n	a=b;\r\n	return a;\r\n}\r\nint main()\r\n{\r\n	int m,n;\r\n	scanf(\"%d %d\",&m,&n);\r\n	printf(\"%d\\n\",f(m)/(f(n)*f(m-n)));\r\n}'),(313,'#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	char m,n=0;\r\n	while(scanf(\"%c\",&m)!=-1)\r\n	{\r\n		if(m==\'$\')n++;\r\n	}\r\n	printf(\"%d\",n);\r\n}'),(314,'#include<stdio.h> \r\nint main() \r\n{char a;\r\nint n=0;\r\nwhile(scanf(\"%c\",&a)!=EOF) \r\n{if(a==\'$\')n++; } \r\nprintf(\"%d\",n); }'),(315,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n    int n,i,sum=0;\r\n    scanf(\"%d\",&n);\r\n    int a[n];\r\n    for(i=0;i<n;i++)\r\n    {\r\n        scanf(\"%d\",&a[i]);\r\n    }\r\n    for(i=0;i<n;i++)\r\n    {\r\n        if(a[i]%2==0)\r\n        sum+=a[i];\r\n    }\r\n    printf(\"%d\\n\",sum);\r\n    return 0;\r\n}\r\n'),(316,'#include<stdio.h>\r\nint main()\r\n{int i,n,x,sum=0;\r\nscanf(\"%d\",&n);\r\nfor(i=1;i<=n;i++)\r\n{scanf(\"%d\",&x);\r\nif(x%2==0)sum+=x;}\r\nprintf(\"%d\\n\",sum);\r\n}'),(317,'#include<stdio.h>\r\n\r\nvoid del_char(char* m,char n)\r\n\r\n{\r\n	char a[1000];\r\n\r\n	int i=0;\r\n\r\n	while(*m!=0)\r\n	{\r\n		if(*m!=n)\r\n		{\r\n			a[i]=*m;\r\n\r\n			i++;\r\n		}\r\n\r\n		*m++;\r\n	}\r\n	a[i]=0;\r\n\r\n	i=0;\r\n\r\n	while(a[i])\r\n	{\r\n		printf(\"%c\",a[i]);\r\n\r\n		i++;\r\n	}\r\n}\r\n\r\nint main()\r\n\r\n{\r\n	char a;\r\n\r\n	char p[1000];\r\n\r\n	scanf(\"%c\",&a);\r\n\r\n	scanf(\"%s\",p);\r\n\r\n	del_char(p,a);\r\n\r\n	return 0;\r\n\r\n}'),(318,'#include<stdio.h>\r\nint main()\r\n{\r\nchar a,b[1000];\r\na=getchar();getchar();\r\ngets(b);\r\nint i=0;\r\nwhile(b[i])\r\n{\r\nif(b[i]!=a) printf(\"%c\",b[i]);\r\ni++;\r\n}\r\n}'),(319,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	int i,n;\r\n	double b;\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n;i++)\r\n	{double c;\r\n		scanf(\"%lf\",&b);\r\n		if(b<-2)\r\n			c=b*b-sin(b);\r\n		else if(b>2)\r\n			c=sqrt(b*b+b+1);\r\n		else\r\n			c=pow(2,b)+b;\r\n		printf(\"%.2lf\\n\",c);\r\n	}\r\n	\r\n\r\n	\r\n}'),(320,'#include <stdio.h>\n#include <math.h>\nint main(){\n	int i,n;float x,y;\n	scanf(\"%d\",&n);\n	for(i=1;i<=n;i++){\n		scanf(\"%f\",&x);\n		if(x<-2) {\n			y=x*x-sin(x);\n		}else if(x<=2){\n			y=pow(2,x)+x;\n		}else{\n			y=sqrt(x*x+x+1);\n		}\n		printf(\"%.2f\\n\",y);\n	}\n	return 0;\n	\n}\n'),(321,'#include\"stdio.h\"\r\nint main()\r\n{int n,i;\r\ndouble a[100];\r\ndouble max=0,min=100000;\r\nscanf(\"%d\",&n);\r\nfor(i=0;i<n;i++)\r\nscanf(\"%lf\",&a[i]);\r\nfor(i=0;i<n;i++)\r\nif(max<a[i])\r\nmax=a[i];\r\nfor(i=0;i<n;i++)\r\nif(min>a[i])\r\nmin=a[i];\r\nprintf(\"%.2lf %.2lf\\n\",max,min);\r\n\r\n\r\n\r\n\r\n}\r\n'),(322,'#include<stdio.h>\r\n \r\nint main()\r\n{\r\n   int n;\r\n   float x,max=-1111111,min=99999999;\r\n   scanf(\"%d\",&n);\r\n   while(n--)\r\n   {\r\n     scanf(\"%f\",&x);\r\n	 if(max<x)max=x;\r\n	 if(min>x)min=x;\r\n   }\r\n   printf(\"%.2f %.2f \",max,min);\r\n}'),(323,'\r\n#include<stdio.h>\r\nint main()\r\n{\r\n	int z,s,k,q;\r\n	char p[1000];\r\n	gets(p);\r\n	{\r\n		int i=0;\r\n	   z=s=k=q=0;\r\n	   while(p[i])\r\n	   {\r\n		   if(p[i]>=\'a\'&&p[i]<=\'z\'\r\n			   ||p[i]>=\'A\'&&p[i]<=\'Z\')\r\n			   z++;\r\n		   else if(p[i]>=\'0\'&&p[i]<=\'9\')\r\n			   s++;\r\n		   else if(p[i]==\' \') k++;\r\n		   else q++;\r\n		   i++;\r\n	   }\r\n       printf(\"%d %d %d %d\\n\",z,s,k,q);\r\n	}\r\n\r\n}'),(324,'\n#include\"stdio.h\"  \nmain()  \n{char c;int i=0,j=0,k=0,l=0;  \nwhile((c=getchar())!=\'\\n\')  \n{if(c>=65&&c<=90||c>=97&&c<=122) i++;  \nelse if(c>=48&&c<=57) j++;  \nelse if(c==32) k++;  \nelse l++;}  \nprintf(\"%d %d %d %d\",i,j,k,l);  \n}'),(325,'#include<stdio.h>\r\nfloat fact(int o)\r\n{\r\n	float a=1;\r\n	int m=1;\r\n	while(m<=o)\r\n	{\r\n	a*=m;\r\n	m++;\r\n	}\r\n	return a;\r\n}\r\nint main()\r\n{\r\n	int n,i;\r\n	float sum=0;\r\n	scanf(\"%d\",&n);\r\n	for(i=1;i<=n;i++)\r\n	{\r\n		sum+=(1/fact(i));\r\n		\r\n	}\r\n	printf(\"%.4f\",sum);\r\n	return 0;\r\n}\r\n'),(326,'\r\n#include<stdio.h>\r\nmain()\r\n{\r\n	int i,n;\r\n	float s=0,t=1;\r\n	scanf(\"%d\",&n);\r\n	for(i=1;i<=n;i++)\r\n	{\r\n		t=t*i;\r\n		s=s+1/t;\r\n	}\r\n	printf(\"%.4f\",s);\r\n}'),(327,'#include<stdio.h>\r\n#include<string.h>\r\nmain()\r\n{\r\n	int i,j;\r\n	int a[10];\r\n	int  sum=0,count=0;\r\n	double result=0.0;\r\n	for(i=0;i<10;i++)\r\n	{\r\n		scanf(\"%d\",&a[i]);\r\n		sum+=a[i];\r\n	}\r\n	result = sum/10;\r\n	for(j=0;j<10;j++)\r\n	{\r\n		if(a[j]>result)\r\n			count++;\r\n	}\r\n	printf(\"%d\",count);\r\n	return 0;\r\n\r\n\r\n}'),(328,'#include<stdio.h>\r\nint main()\r\n{ int i,a[10],sum=0,t,sum2=0;\r\nfor(i=0;i<10;i++)\r\n{scanf(\"%d\",&a[i]);\r\nsum+=a[i];}\r\nt=sum/10;\r\nfor(i=0;i<10;i++)\r\n{if(a[i]>t)\r\nsum2++;}\r\nprintf(\"%d\",sum2);}'),(329,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n    int m,n,sum=0;\r\n    int i,j,judge;\r\n    scanf(\"%d %d\",&m,&n);\r\n    for(i=m;i<=n;i++)\r\n    {\r\n        for(j=2;j<=sqrt(i);j++)\r\n        {\r\n            judge=i%j;\r\n            if(judge==0)\r\n            break;\r\n        }\r\n        if(judge!=0)\r\n        sum+=i;\r\n    }\r\n    if(m==0||m==1)\r\n    printf(\"%d\",sum-1);\r\n    else printf(\"%d\",sum);\r\n    return 0;\r\n}\r\n'),(330,'#include\"stdio.h\"\r\nint main()\r\n{int i,j,n,m,f,sum=0;\r\nwhile(scanf(\"%d %d\",&m,&n)!=EOF)\r\n{for(i=m;i<=n;i++)\r\n{f=1;\r\n for(j=2;j<i;j++)\r\n if(i%j==0)\r\n f=0;\r\n if(f==1&&i!=1)\r\nsum+=i;}}\r\nprintf(\"%d\\n\",sum);\r\nreturn 0;}'),(331,'#include<stdio.h>\r\nmain()\r\n{\r\n	int i,n,a[10],b[10],t;\r\n	for(i=0;i<10;i++)\r\n	scanf(\"%d\",&a[i]);\r\n	for(i=0;i<10;i++)\r\n	{\r\n		b[i]=a[i];\r\n	}\r\n	for(i=0;i<10;i++)\r\n	{\r\n		if(a[i]<0)\r\n		{\r\n			a[i]=-a[i];\r\n		}\r\n	}\r\n	n=a[0];\r\n	for(i=0;i<10;i++)\r\n	{\r\n		if(n>a[i])\r\n		{\r\n			n=a[i];\r\n		}\r\n	}\r\n	for(i=0;i<10;i++)\r\n	{\r\n		if(b[i]==n)\r\n		{\r\n			t=b[i];\r\n			b[i]=b[9];\r\n			b[9]=t;\r\n		}\r\n	}\r\n	for(i=0;i<9;i++)\r\n	{\r\n		printf(\"%d \",b[i]);\r\n\r\n	}\r\n	printf(\"%d\",b[9]);\r\n}'),(332,'int main()\r\n{\r\n	int a[10];\r\n	int i,min;\r\n	for(i=0;i<10;i++)\r\n	{\r\n		scanf(\"%d\",&a[i]);\r\n	}\r\n	min=a[0];\r\n	for(i=0;i<10;i++)\r\n	{\r\n		if(abs(a[i])<abs(min))\r\n			min=a[i],a[i]=a[9],a[9]=min;\r\n	}\r\n	for(i=0;i<10;i++)\r\n	{\r\n		printf(\"%d \",a[i]);\r\n	}\r\n	return 0;\r\n}'),(333,'#include<stdio.h>\r\n#include<math.h>\r\ndouble fact(int n)\r\n{\r\n	int i;\r\n	double s;\r\n	for(i=1,s=1;i<=n;i++)\r\n	{\r\n		s=s*i;\r\n	}\r\n	return s;\r\n}\r\ndouble mypow(double x,int n)\r\n{\r\n	int i;\r\n	double s=1;\r\n	for(i=1;i<=n;i++)\r\n	{\r\n		s=s*x;\r\n	}\r\n	return s;\r\n}\r\nint main()\r\n{\r\n	double x,sum,m,p;\r\n	int i,n;\r\n	scanf(\"%lf%d\",&x,&n);\r\n	for(i=1,sum=0;i<=n;i++)\r\n	{\r\n		m=mypow(x,i);\r\n		p=fact(i);\r\n		sum=sum+(m/p)*pow(-1,i-1);\r\n	}\r\n	printf(\"%.4lf\\n\",sum);\r\n	return 0;\r\n}'),(334,'#include <stdio.h>\r\nint n;\r\ndouble x;\r\nmain()\r\n{\r\n	int i,j;\r\n	double t,k,sum=0;\r\n	scanf (\"%lf %d\", &x,&n);\r\n	t=1;\r\n	k=-1.0;\r\n	for (i=1;i<=n;i++)\r\n	{\r\n	t=t*i;\r\n	k=k*x*(-1.0);\r\n	sum=sum+k/t;\r\n	}\r\n	printf (\"%.4lf\\n\",sum);	\r\n} '),(335,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	double x,y;\r\n	scanf(\"%lf\",&x);\r\n	if(x<0)\r\n		y=fabs(x);\r\n	else if(x<2&&x>=0)\r\n		y=sqrt(x+1);\r\n	else if(x<4&&x>=2)\r\n		y=pow(x+2,5);\r\n	else \r\n		y=2*x+5;\r\n	printf(\"%.2lf\\n\",y);\r\n	return 0;\r\n}'),(336,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	double x;\r\n	scanf(\"%lf\",&x);\r\n	printf(\"%.2lf\",x>=4?2*x+5:(x>=2?pow(x+2,5):(x>=0?sqrt(x+1):fabs(x))));\r\n}'),(337,'#include<stdio.h>\r\n\r\nint main(){\r\n    int c,f;\r\n    for(c=-100;c<=150;c=c+5){\r\n        f=32+c*9/5;\r\n        printf(\"c=%d->f=%d\\n\",c,f);\r\n    }\r\n}\r\n'),(338,'#include\"stdio.h\"\r\nint main()\r\n{int c;\r\nfor(c=-100;c<=150;c+=5)\r\nprintf(\"c=%d->f=%d\\n\",c,32+c*9/5);}'),(339,'#include <stdio.h>\r\n#include <math.h>\r\n#define N 20\r\nint main( )\r\n{\r\n	int a[N][N];\r\n	int i,j;\r\n	int id,jd;\r\n	int n;\r\n	\r\n	scanf(\"%d\", &n);\r\n\r\n	for(i=0; i<n; i++)\r\n		for(j=0; j<n; j++)\r\n			scanf(\"%d\", &a[i][j]);\r\n\r\n		id=jd= 0;\r\n	for(i=0; i<n; i++)\r\n		for(j=0; j<n; j++)\r\n		{\r\n			if( fabs(a[id][jd]) <fabs(a[i][j]) )\r\n			{\r\n				id = i;\r\n				jd = j;\r\n			}\r\n		}\r\n\r\n		printf(\"%d %d %d\\n\", a[id][jd], id+1, jd+1);\r\n	return 0;\r\n}'),(340,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{int n,i,max=0;\r\nint a[40];\r\nscanf(\"%d\",&n);\r\nfor(i=0;i<n*n;i++)\r\n{scanf(\"%d\",&a[i]);\r\nif(abs(a[i])>abs(a[max]))\r\nmax=i;}\r\nprintf(\"%d %d %d\",a[max],max/n+1,max%n+1);}\r\n'),(341,'#include\"stdio.h\"\r\nint main()\r\n{int a[100];\r\nint n=0,i,y=0,t=0,b=0;\r\n\r\nwhile(scanf(\"%d\",&a[n])!=EOF)\r\n{if(a[n]==0||a[n]<0)\r\n break;\r\n n++; }\r\n\r\nfor(i=0;i<n;i++)\r\n{if(a[i]>=85)\r\ny++;\r\nelse if(a[i]>=60&&a[i]<=84)\r\nt++;\r\nelse if(a[i]<60)\r\nb++;}\r\n\r\nprintf(\">=85:%d\\n\",y);\r\nprintf(\"60-84:%d\\n\",t);\r\nprintf(\"<60:%d\\n\",b);\r\n\r\n}'),(342,'#include<stdio.h>\n\nint main()\n{\n	int high=0,mid=0,low=0;\n	int x;\n	while(scanf(\"%d\",&x), x>0)\n	{\n		if(x >= 85)\n			high++;\n		else if(x >= 60)\n			mid++;\n		else\n			low++;\n	}\n	printf(\">=85:%d\\n60-84:%d\\n<60:%d\\n\",high,mid,low);\n\n	return 0;\n}'),(343,'#include\"stdio.h\"\r\ndouble fact(double n)\r\n{double i,s=1;\r\nfor(i=1;i<=n;i++)\r\ns*=i;\r\nreturn s;}\r\nint main()\r\n{int n,i;\r\ndouble sum=0;\r\nscanf(\"%d\",&n);\r\nfor(i=1;i<=n;i++)\r\nsum+=1/fact(i);\r\nprintf(\"sum=%.5lf\",sum);\r\n}'),(344,'#include \"stdio.h\"\r\nvoid main()\r\n{\r\n    long i,n;\r\n    float s=0,t=1;\r\n    scanf(\"%ld\",&n);\r\n    for(i=1;i<=n;i++)\r\n    {   t=t*i;\r\n        s=s+1/t;\r\n    }\r\n    printf(\"sum=%.5f\",s);\r\n}'),(345,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\nint m;\r\nwhile(scanf(\"%d\",&m)!=EOF)\r\n{\r\nprintf(\"%o\",m);\r\n}\r\n}'),(346,'main(){int a;scanf(\"%d\",&a);printf(\"%o\\n\",a);return 0;}'),(347,'#include <stdio.h>\r\nint main()\r\n{\r\n	float F,c;\r\n	scanf(\"%f\",&F);\r\n	c=5*(F-32)/9;\r\n	printf(\"%.2f\",c);\r\n	return 0;\r\n\r\n}'),(348,'#include<stdio.h>\r\nint main(){float a;scanf(\"%f\",&a);printf(\"%.2f\",5*(a-32)/9);}'),(349,'#include\"stdio.h\"\r\nint main()\r\n{\r\ndouble x;\r\n	while(scanf(\"%lf\",&x)!=EOF)\r\n	{if (x<1) printf(\"%.2lf\",x);\r\n	else if (x>=1&&x<10) printf(\"%.2lf\",2*x-1);\r\n	else if (x>=10) printf(\"%.2lf\",3*x-11); }\r\n	return 0;}'),(350,'#include<stdio.h>\r\nint main(){float a;scanf(\"%f\",&a);printf(\"%.2f\",a<1?a:a<10?2*a-1:3*a-11);}'),(351,'#include <stdio.h>\r\n\r\nint main(void)\r\n{\r\n    int n, m, i;\r\n    int sum = 0;\r\n    scanf(\"%d\", &n);\r\n\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        scanf(\"%d\", &m);\r\n        if (m % 2 == 0)\r\n            sum += m;\r\n    }\r\n    printf(\"%d\\n\", sum);\r\n    return 0;\r\n} '),(352,'#include <stdio.h>\nint main()\n{\nint i,n,x,sum=0;\nwhile(scanf(\"%d\",&n),n<=0);\nfor(i=1;i<=n;i++){\nscanf(\"%d\",&x);\nif(x%2==0) sum+=x;\n}\nprintf(\"%d\\n\",sum);\n}'),(353,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	int m;\r\n	m=2+3*(n-1);\r\n	int y;\r\n	y=(2+m)*n/2;\r\n	cout<<y;\r\n}'),(354,'#include\"stdio.h\"\r\nint main()\r\n{int n;scanf(\"%d\",&n);printf(\"%d\",2*n+n*(n-1)*3/2);}'),(355,'#include <stdio.h>\r\nint main()\r\n{int i=10;\r\nwhile(i<=1000)\r\n{\r\nif(i%42==0)\r\n{printf(\"%d\\n\",i);}\r\ni++;\r\n}\r\nreturn 0;\r\n}'),(356,'#include<stdio.h>\r\nvoid main()\r\n{for(int i=1;i<24;i++)\r\nprintf(\"%d\\n\",i*42);\r\n}\r\n'),(357,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a[21],i,j=0,k=0;\r\n	float x=0;\r\n	for(i=0;i<20;i++)\r\n	{\r\n		scanf(\"%d\",&a[i]);\r\n	}\r\n	for(i=0;i<20;i++)\r\n	{\r\n		if(a[i]<0)\r\n			k=k+1;\r\n		else\r\n		{\r\n			x=x+a[i];\r\n			j=j+1;\r\n		}\r\n	}\r\n	printf(\"%d\\n\",k);\r\n	printf(\"%.2f\",x/(float)j);\r\n	return 0;\r\n}\r\n'),(358,'#include<stdio.h>\r\nint main(){\r\nint i,a[20],b;\r\nfloat s;\r\nfor(i=0,b=0,s=0;i<20;i++){\r\nscanf(\"%d\",&a[i]);\r\nif(a[i]<0)\r\nb++;\r\nelse s+=a[i];\r\n}\r\nprintf(\"%d\\n%.2f\",b,s/(20-b));\r\nreturn 0;\r\n}'),(359,'#include\"stdio.h\"\r\nint f(int a,int b)\r\n{int t;\r\nwhile(b)\r\n{t=a;\r\na=b;\r\nb=t%b;}\r\nreturn a;}\r\n\r\nint main()\r\n{int a,b;\r\n	while(scanf(\"%d %d\",&a,&b)!=EOF)\r\n{printf(\"%d\\n\",f(a,b));\r\nprintf(\"%d\\n\",a*b/f(a,b));\r\n}\r\nreturn 0;}\r\n'),(360,'#include<stdio.h>\r\nint f(int m,int n)\r\n{\r\nreturn n?f(n,m%n):m;\r\n}\r\nint main()\r\n{\r\nint a,b;\r\nscanf(\"%d%d\",&a,&b);\r\nprintf(\"%d\\n%d\\n\",f(a,b),a*b/f(a,b));\r\n}'),(361,'#include<stdio.h>\r\nint main()  \r\n{\r\n	char k;\r\n	int figure_num=0,letter_num=0,space_num=0,other_num=0; \r\n	do  \r\n	{\r\n		k=getchar();  \r\n		if(k<=\'9\'&&k>=\'0\') \r\n			figure_num+=1; \r\n		else  if((k<=\'z\'&&k>=\'a\')||(k<=\'Z\'&&k>=\'A\')) letter_num+=1;\r\n			else if(k==\' \')  space_num+=1; \r\n				else  if(k==\'\\n\') break; \r\n					else  other_num+=1; \r\n	}  \r\n	while(k!=\'\\n\');  \r\n	printf(\"%d\\n%d\\n%d\\n%d\\n\",letter_num,space_num,figure_num,other_num); \r\n	return 0;\r\n}'),(362,'#include<stdio.h>\r\nvoid main()\r\n{\r\nchar c;int i=0,j=0,k=0,l=0;\r\nwhile((c=getchar())!=\'\\n\')\r\n{if(c>=65&&c<=90||c>=97&&c<=122)\r\n i++;\r\nelse if(c>=48&&c<=57) \r\nj++;\r\nelse \r\nif(c==32)\r\n k++;\r\nelse l++;}\r\nprintf(\"%d\\n%d\\n%d\\n%d\\n\",i,k,j,l);\r\n}'),(363,'#include<stdio.h>\r\nint main()\r\n{\r\n	double i,m=1,sum=0;\r\n	for(i=1;i<=30;i++)\r\n	{\r\n	   m*=i;\r\n	   sum+=m;\r\n	}\r\n	printf(\"%.2e\\n\",sum);\r\n}\r\n'),(364,'main(){double num;printf(\"%.2e\\n\",num=2.74e+032);}'),(365,'#include <stdio.h>\r\nint main()\r\n{\r\n	int a=1,b,c;\r\n	while(a<10)\r\n	{\r\n		b=0;\r\n		while(b<10)\r\n		{\r\n			c=0;\r\n			while(c<10)\r\n			{\r\n				if(a*a*a+b*b*b+c*c*c==100*a+10*b+c)\r\n					printf(\"%d\\n\",100*a+10*b+c);\r\n				c++;\r\n			}\r\n			b++;\r\n		}\r\n		a++;\r\n	}\r\n	return 0;\r\n}'),(366,'#include<stdio.h>\r\nint main(){printf(\"153\\n370\\n371\\n407\");}\r\n'),(367,'#include<stdio.h>\r\n#include<math.h>\r\nint f(int i)\r\n{\r\n	int k,l;\r\n	for(l=2;l<=sqrt(i);l++)\r\n	{\r\n		if(i%l==0)\r\n			return 0;\r\n		else\r\n			return 1;\r\n	}\r\n}\r\nint main()\r\n{\r\n	int n,i,j;\r\n	scanf(\"%d\",&n);\r\n	for(i=2;i<=sqrt(n);i++)\r\n	{\r\n		if(n%i==0)\r\n		{\r\n			if(f(i))\r\n			{\r\n				n/=i;\r\n				printf(\"%d \",i);\r\n				i=1;\r\n			}\r\n		}	\r\n	}\r\n	if(i>sqrt(n))\r\n		printf(\"%d \",n);\r\n}'),(368,'#include\"stdio.h\"\nint main()\n{ int m,i=2;\n  scanf(\"%d\",&m);\n  while(m!=1)\nif(m%i==0) \n {printf(\"%d \",i);\nm/=i; }  \nelse  i++;\n  printf(\"\\n\");\n}\n'),(369,'#include<stdio.h>\r\nint main()\r\n{\r\n	int n,x,y;\r\n	n=1333;\r\n	x=101;\r\n	while(x<1000)\r\n	{\r\n		x++;\r\n		y=(x%10)*100+x/100+x/10%10*10;\r\n		if(x+y==n)\r\n			printf(\"%d+%d=1333\\n\",x,y);\r\n	}\r\n	return 0;\r\n}'),(370,'#include<stdio.h>\r\nint main(){printf(\"419+914=1333\\n518+815=1333\\n617+716=1333\\n716+617=1333\\n815+518=1333\\n914+419=1333\");}'),(371,'#include\"stdio.h\"\r\nint main()\r\n{\r\n	int n,i,j,k;\r\n	int count=1;\r\n	scanf(\"%d\",&n);\r\n	for(i=n;i>0;i--)\r\n	{	for(j=0;j<i-1;j++)\r\n			printf(\" \");\r\n	 for(k=0;k<2*count-1;k++)\r\n		 printf(\"*\");\r\n	 count++;\r\n	 printf(\"\\n\");\r\n	\r\n	\r\n	}\r\n}'),(372,'#include<stdio.h>\r\nint main()\r\n{\r\n	printf(\"   *\\n  ***\\n *****\\n*******\");\r\n	return 0;\r\n}'),(373,'#include<stdio.h>\r\nint main()\r\n{\r\n	printf(\"6=1+2+3\\n28=1+2+4+7+14\\n496=1+2+4+8+16+31+62+124+248\");\r\n	return 0;\r\n}'),(374,'#include<stdio.h>\r\nvoid main()\r\n{\r\nprintf(\"6=1+2+3\\n28=1+2+4+7+14\\n496=1+2+4+8+16+31+62+124+248\");\r\n}'),(375,'#include <stdio.h>\r\n#define PI 3.1415926\r\n#define S(r) {r=PI*r*r;} \r\nint main()\r\n{\r\n	double i,r;\r\n	for(i=4.00;i<6;i++)\r\n	{\r\n		r=i;\r\n		S(r);\r\n		if(r<90 && r>40)\r\n		{	\r\n			printf(\"r=%.0lf area=%.2lf\\n\",i,r);\r\n		}\r\n	}\r\n	return 0;\r\n}'),(376,'\r\n#include <stdio.h>\r\nmain(){printf(\"r=4 area=50.27\\nr=5 area=78.54\\n\");}'),(377,'#include<stdio.h>\r\nint main()\r\n{\r\n	int i,j,a[10],ma,t;\r\n	for(i=0;i<10;i++)\r\n	{\r\n		scanf(\"%d\",&a[i]);\r\n	}\r\n	for(i=0;i<10;i++)\r\n	{\r\n		ma=i;\r\n		for(j=i+1;j<10;j++)\r\n		{\r\n			if(a[ma]>a[j])\r\n				ma=j;\r\n		}\r\n		t=a[i];\r\n		a[i]=a[ma];\r\n		a[ma]=t;\r\n		printf(\"%d\\n\",a[i]);\r\n	}\r\n	return 0;\r\n}'),(378,'#include<cstdio>\r\n#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\nint main(){\r\n	int a[10];\r\n	for(int i=0;i<10;i++)\r\n		cin>>a[i];\r\n	sort(a,a+10);\r\n	for(int i=0;i<10;i++){\r\n		cout<<a[i]<<endl;\r\n	}\r\n}'),(379,'#include <stdio.h>\r\nint main()\r\n{\r\n    int num[20];\r\n    int i;\r\n    int j;\r\n    int k;\r\n    for(i = 0;i < 20;i++)\r\n        scanf(\"%d\", &num[i]);\r\n    for(j = 0;j < 20; j++)\r\n    {\r\n         for(k = 0;k < 20; k++)\r\n         {\r\n            if(k == j)\r\n                continue;\r\n            if(num[j]%num[k] == 0)\r\n            {\r\n                printf(\"%d\\n\", num[j]);\r\n                break;\r\n            }\r\n         }\r\n    }\r\n    return 0;\r\n}'),(380,'#include\"stdio.h\"\n#define N 20\nint main()\n { int a[N], i,j;\n   for(i=0;i<N;i++) \n scanf(\"%d\",&a[i]);\n   for(i=0;i<N;i++)\n     for(j=0;j<N;j++)\nif(a[i]%a[j]==0&&i!=j)  \n{ printf(\"%d\\n\",a[i]); \nbreak;\n}\n}\n'),(381,'#include<stdio.h>\r\nint main()\r\n{\r\nint s=0;\r\nint i;\r\nwhile(1)\r\n{\r\nfor(i=0;i<9;i++)\r\n{\r\nint k;\r\nif(scanf(\"%d\",&k)==-1) break;\r\nif(i%3==i/3)  s+=k;\r\n}\r\nif(i!=9) break;\r\nprintf(\"%d\\n\",s);\r\n}\r\nreturn 0;}'),(382,'int main()\r\n{\r\n	int i,a[9];\r\n	for(i=0;i<=9;i++){scanf(\"%d\",&a[i]);}\r\n    printf(\"%d\\n\",a[0]+a[4]+a[8]);\r\n\r\n}'),(383,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int a[6],b[8];\r\n	for(int i=0;i<6;i++)\r\n	{\r\n		cin>>a[i];\r\n	}\r\n	for(int i=0;i<8;i++)\r\n	{\r\n		cin>>b[i];\r\n	}\r\n    for(int i=0;i<6;i++)\r\n	{\r\n		for(int j=0;j<8;j++)\r\n		{\r\n			if(a[i]==b[j])\r\n				cout<<a[i]<<endl;\r\n		}\r\n	}\r\n}'),(384,'#include<stdio.h>\r\nmain()\r\n{\r\nint a[6],b[8];\r\nint i,j;\r\nfor(i=0;i<6;i++)\r\n{scanf(\"%d\",&a[i]);}\r\nfor(j=0;j<8;j++)\r\n{scanf(\"%d\",&b[j]);}\r\nfor(i=0;i<6;i++)\r\nfor(j=0;j<8;j++)\r\nif(a[i]==b[j])\r\nprintf(\"%d\\n\",a[i]);\r\n}'),(385,'#include <stdio.h>\r\n#include <stdlib.h>\r\nstruct a_type{\r\nint t;\r\nint v;\r\ndouble r;\r\n}a[20];\r\nint cmp(const void *x, const void *y){\r\nstruct a_type *c = (struct a_type*)x;\r\nstruct a_type *d = (struct a_type*)y;\r\nif (c->r < d->r){\r\n   return 1;\r\n}\r\nelse if (c->r > d->r){\r\n   return -1;\r\n}\r\nelse{\r\n   return 0;\r\n}\r\n}\r\nint main(){\r\ndouble res;\r\nint n, total, i, s;\r\nwhile (scanf(\"%d %d\", &n, &total)==2 && (n!=0||total!=0)){\r\n   for (i=0; i<n; ++i){\r\n    scanf(\"%d %d\", &a[i].t, &a[i].v);\r\n    a[i].r = (double)a[i].v/a[i].t;\r\n   }\r\n   qsort(a, n, sizeof(a[0]), cmp);\r\n   s = 0; res = 0;\r\n   for (i=0; i<n; ++i){\r\n    if (s+a[i].t <= total){\r\n     s += a[i].t;\r\n     res += a[i].v;\r\n    }\r\n    else{\r\n     break;\r\n    }\r\n   }\r\n   if (i < n){\r\n    res += (total-s)*a[i].r;\r\n   }\r\n   printf(\"%.2lf\\n\", res);\r\n}\r\nreturn 0;\r\n}'),(386,'#include <stdio.h>\n\nmain()\n{\n	int i,j,x,a,b,n[20],m[20];\n	double c,e,d[20]; \n	while(scanf(\"%d%d\",&a,&b)!=EOF)\n	{\n		if(!a&&!b)break;\n		for(i=0;i<a;i++)\n			scanf(\"%d%d\",&n[i],&m[i]);\n		for(i=0;i<a;i++)\n		{\n			d[i]=(double)m[i]/(double)n[i];\n		}\n		c=0;\n		e=0;\n		for(x=0;x<a;x++)\n		{\n			for(i=j=0;i<a;i++)\n			{\n				if(d[j]<d[i])j=i;\n			}\n			if((e+n[j])>=b){i=(b-e);c+=d[j]*i;break;}\n			else if(d[j]==0)break;\n			else{e+=n[j];c+=m[j];}\n			d[j]=0;\n		}\n		printf(\"%.2f\\n\",c);\n	}\n}\n\n'),(387,'#include<stdio.h>\r\nmain()\r\n{\r\n int n=1,s1=1;\r\n    int month,day;\r\n    int i,s2;\r\n    while(s1<62)\r\n    {\r\n  n++;\r\n        s1=s1+n;\r\n    }\r\n while(scanf(\"%d/%d\",&month,&day)!=EOF && (month!=0 || day!=0))\r\n    {\r\n        i=1;\r\n        s2=1;\r\n        while(s2<(month-7)*31+day)\r\n        {\r\n   i++;               \r\n   s2=s2+i;\r\n        }\r\n        printf(\"%d\\n\",n-i);\r\n    }\r\n return 0;\r\n}'),(388,'#include <stdio.h>\r\nint main()\r\n{int i,j;\r\nchar t[63]={0};\r\nfor(j=2,i=1;i<63 &&(t[i]=1);i+=j,j++);\r\nfor (i=61;i;t[i]+= t[i+1],i--);\r\nwhile (scanf(\"%d/%d\", &i, &j)&&(i!=0,j!=0))\r\nprintf(\"%d\\n\", t[i==7?j:j+ 31]);\r\nreturn 0;\r\n}'),(389,'#include\"stdio.h\"\r\n\r\nint main()\r\n{\r\n	int n,m;\r\n	int bird,rabbit;\r\n	while(1)\r\n	{\r\n		scanf(\"%d %d\",&n,&m);\r\n		if(m==0&&n==0)\r\n			return 0;\r\n		rabbit=(m-2*n)/2;\r\n		bird=n-rabbit;\r\n		if(rabbit+bird==n&&rabbit>0&&bird>0&&rabbit*4+bird*2==m)\r\n			printf(\"%d %d\\n\",bird,rabbit);\r\n		else printf(\"Error\\n\");\r\n	}\r\n	return 0;\r\n}'),(390,'#include <stdio.h>\r\nint main(void)\r\n{\r\nint m, n;\r\nwhile (scanf(\"%d%d\", &n, &m), m + n)\r\nprintf((m%2||m>4*n||m<2*n?\"Error\\n\":\"%d %d\\n\"),2*n-m/2,m/2-n);\r\nreturn 0;\r\n}\r\n'),(391,'#include <stdio.h>\r\n#include <stdlib.h>\r\n \r\n#define MAXN 1001\r\nint horses1[MAXN];\r\nint horses2[MAXN];\r\n \r\nint compare (const void * a, const void * b)\r\n{\r\n  return ( *(int*)a - *(int*)b );\r\n}\r\n \r\nint main()\r\n{\r\n  int n, i, j, t, end;\r\n  while(scanf(\"%d\", &n), n)\r\n  {\r\n     for (i = 0; i < n; ++i)\r\n        scanf(\"%d\", &horses1[i]);\r\n     for (i = 0; i < n; ++i)\r\n        scanf(\"%d\", &horses2[i]);\r\n \r\n     qsort(horses1, n, sizeof(int), compare);\r\n     qsort(horses2, n, sizeof(int), compare);\r\n    \r\n     t = 0; \r\n     end = n - 1;\r\n     for (i = n - 1; i >= 0; --i)\r\n        for (j = end; j >= 0; --j)\r\n          if (horses1[i] > horses2[j])\r\n          {\r\n             ++t;\r\n             end = j - 1;\r\n             break;\r\n          }\r\n     if (t > n / 2) printf(\"YES\\n\");\r\n       else printf(\"NO\\n\");\r\n  }\r\n  return 0;\r\n}'),(392,'#include<stdio.h>\r\nint main()\r\n{\r\n int N,a[1001],b[1001],i,k,l,j,z,t;\r\n while(scanf(\"%d\",&N),N!=0)\r\n {\r\n  z=0;\r\n  for(i=0;i<N;i++)\r\n  {\r\n   scanf(\"%d\",&a[i]);\r\n   if(a[i]>a[0])\r\n   t=a[i];\r\n  }\r\n  for(i=0;i<N;i++)\r\n  scanf(\"%d\",&b[i]);\r\n  for(i=0;i<N;i++)\r\n  {\r\n   k=1;\r\n   for(j=0;j<N;j++)\r\n   {\r\n    if(a[i]>b[j])\r\n    {\r\n     if(k)\r\n     {\r\n      l=j;\r\n      k=0;\r\n     }\r\n     if(b[j]>b[l])\r\n     l=j;\r\n    }\r\n   }\r\n   if(k==0)\r\n   {\r\n    b[l]=t+1;\r\n    z++;\r\n   }\r\n  }\r\n  if(z>N/2)\r\n  printf(\"YES\\n\");\r\n  else\r\n  printf(\"NO\\n\");\r\n }\r\n}'),(393,'#include <iostream>\r\n#include <queue>\r\n#include <cstring>\r\nusing namespace std;\r\nstruct Node\r\n{\r\n    int x;\r\n    int y;\r\n};\r\nchar map[100][100];\r\nint flag[100][100] = {0};\r\nint dx[] = {0,-1,0,1};\r\nint dy[] = {-1,0,1,0};\r\nint n,m,T;\r\nNode s,p;\r\nvoid scan_map()\r\n{\r\n    for(int i = 0; i < m; i++)\r\n        for(int t =0; t < n; t++)\r\n    {\r\n        cin>>map[i][t];\r\n        if(map[i][t] == \'S\')\r\n            {s.x = i;s.y = t;}\r\n        if(map[i][t] == \'P\')\r\n            {p.x = i; p.y = t;}\r\n    }\r\n}\r\nvoid  fin_g()\r\n{\r\n    queue<Node> q;\r\n    q.push(s);\r\n    while(!q.empty())\r\n    {\r\n        int x,y;\r\n\r\n        Node node = q.front();  q.pop();\r\n        x = node.x;\r\n        y = node.y;\r\n\r\n        if(x == p.x && y == p.y)  break;\r\n        else\r\n        {\r\n            for(int i =0; i < 4; i++)\r\n            {\r\n                int new_x,new_y;\r\n                new_x = x + dx[i];\r\n                new_y = y + dy[i];\r\n                if(new_x >= m || new_x < 0||new_y >= n||new_y < 0)  continue;\r\n\r\n                if(map[new_x][new_y] != \'*\' && !flag[new_x][new_y])\r\n                {\r\n                    flag[new_x][new_y] = flag[x][y] +1;\r\n                    node.x = new_x;\r\n                    node.y = new_y;\r\n                    q.push(node);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\nvoid prin_map()\r\n{\r\n    for(int i = 0; i < m; i++)\r\n        {for(int t =0; t < n; t++)\r\n\r\n          cout<<map[i][t]<<\" \";\r\n          cout<<endl;\r\n        }\r\n}\r\nint main()\r\n{\r\n\r\n    while(cin>>n>>m>>T && n !=0 || m != 0||T != 0)\r\n    {\r\n    memset(flag,0,sizeof(flag));\r\n    scan_map();\r\n    fin_g();\r\n    if(flag[p.x][p.y] == 0)  cout<<\"NO\\n\";\r\n    else if(flag[p.x][p.y] > T) cout<<\"NO\\n\";\r\n    else cout<<\"YES\\n\";\r\n    \r\n    }\r\n    return 0;\r\n}'),(394,'#include<stdio.h>\n#include<string.h>\nstruct node\n{\n	int x,y;\n}que[401];\nchar visited[21][21];\nint xs,ys,xe,ye,head,tail,pt,n,m;\nint go[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nint bfs(int x1,int y1,int x2,int y2)\n{\n	int i,x,y,step=0,k;\n	head=pt=0;\n	tail=1;\n	que[0].x=x1;\n	que[0].y=y1;\n	while(head<tail)\n	{\n		pt=tail;\n		step++;\n		for(k=head;k<tail;k++)\n		{\n			for(i=0;i<4;i++)\n				{\n					x=que[k].x+go[i][0];\n					y=que[k].y+go[i][1];\n					if(x>=0&&x<m&&y>=0&&y<n&&visited[x][y]!=\'*\')\n					{\n						que[pt].x=x;\n						que[pt++].y=y;\n						visited[x][y]=\'*\';\n					}\n					if(x==x2&&y==y2) return step;\n				}\n		}\n		head=tail;\n		tail=pt;\n	}\n	return -1;\n}\nint main()\n{\n	int t,res;\n	int i,j;\n	while(scanf(\"%d%d%d\",&n,&m,&t),n||m||t)\n	{\n		getchar();\n		for(i=0;i<m;i++)\n		   gets(visited[i]);\n		for(i=0;i<m;i++)\n		{		\n			for(j=0;j<n;j++)\n			{\n				if(visited[i][j]==\'S\')\n				{\n					xs=i,ys=j;\n					visited[i][j]=\'*\';\n				}	\n				if(visited[i][j]==\'P\')\n					xe=i,ye=j;\n			}\n			\n		}\n			res=bfs(xs,ys,xe,ye);\n			if(res>-1&&res<=t)printf(\"YES\\n\");\n			else printf(\"NO\\n\");\n	}\n	return 0;\n}'),(395,'#include <math.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define size 3200\r\nint pm[446] = {2,3,5};\r\nint total = 3;\r\nint abc;\r\nint num;\r\nint Len;\r\nvoid R(int n, int b, int sum)\r\n{\r\nif (n < Len)\r\n{\r\nint i, tmp;\r\nfor (i = b; i < total - Len + 1 + n; i++)\r\n{\r\ntmp = num;\r\nR(n + 1, i + 1, sum * pm[i]);\r\nif (tmp == num) return;\r\n}\r\n}\r\nelse\r\n{\r\nnum += abc / sum;\r\n}\r\n}\r\n \r\nint B(int len)\r\n{\r\nint left = 0;\r\nint right = 445;\r\nint middle;\r\n \r\nwhile (left < right)\r\n{\r\nmiddle = (left + right) / 2;\r\nif (pm[middle] > len)\r\nright = middle - 1;\r\nelse if (pm[middle] < len)\r\nleft = middle + 1;\r\nelse\r\nreturn middle + 1;\r\n}\r\nreturn pm[left] <= len ? left + 1 : left;\r\n}\r\nint creat_prime(int prime[],int n,int total)\r\n{\r\nint i, j;\r\nint gab=2;\r\nint count;\r\nfor(i=7;i<=n;i+=gab)\r\n{\r\ncount=1;\r\ngab=6-gab;\r\nfor(j=0;prime[j]*prime[j]<=i;j++)\r\n{\r\nif(i%prime[j]==0)\r\n{\r\ncount=0;\r\nbreak;\r\n}\r\n}\r\nif(count)\r\n{\r\nprime[total]=i;\r\ntotal++;\r\n}\r\n}\r\n \r\nreturn total;\r\n}\r\n \r\nint main(void)\r\n{\r\nint len;\r\nint count = 2;\r\n \r\ntotal=creat_prime(pm,3162,total);\r\nwhile (scanf(\"%d\", &abc), abc)\r\n{\r\ntotal = B((int)(sqrt(abc) + 0.5));\r\nfor (len = 0, Len = 1; Len <= total; Len++)\r\n{\r\nnum = 0;\r\nR(0, 0, 1);\r\nif (!num) break;\r\nLen % 2 ? (len -= num) : (len += num);\r\n}\r\nprintf(\"%d\\n\", total - 1 + abc + len);\r\n}\r\n \r\nreturn 0;\r\n}'),(396,'#include <stdio.h>\r\n#include <math.h>\r\nint main()\r\n{\r\nint m,n,i,j;\r\nwhile(scanf(\"%d\",&n)==1&&(n>0))\r\n{\r\nm=0;	 \r\nfor (i=2;i<=n;i++)\r\n{\r\nfor (j=2;j<=sqrt(i);j++)\r\n{\r\nif (i%j==0)\r\n{\r\nm--;	 \r\nbreak;\r\n}\r\n}\r\nm++;	\r\n}\r\nprintf(\"%d\\n\",m);\r\n}\r\nreturn 0;\r\n}'),(397,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a[41]={1,1};\r\n	int i,n,f=0;\r\n	for (i=2;i<=40;i++)\r\n	{\r\n		a[i]=a[i-1]+a[i-2];\r\n	}\r\n	while(1)\r\n	{\r\n		scanf(\"%d\",&n);\r\n		if (n==0)\r\n			break;\r\n		if (f)\r\n			printf(\"\\n\");\r\n		f=1;\r\n		printf(\"%d\",a[n]);\r\n	}\r\n}'),(398,'#include <stdio.h>\r\nint main(void)\r\n{int i, f[50]={1,1,2};\r\nfor (i=3;i<50;f[i]=f[i-1]+f[i-2],i++);\r\nwhile(scanf(\"%d\",&i),i)\r\n{printf(\"%d\\n\",f[i]);}\r\nreturn 0;\r\n}'),(399,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n char u[]=\"ECFAJKLBDGHIVWZYMNOPQRSTUX\";\r\n char l[]=\"erwqtyghbnuiopsjkdlfazxcvm\";\r\n char s[1024],c;\r\n int len,i;\r\n while (gets(s) != NULL)\r\n {\r\n  if (s[0] == \'#\') break;\r\n  len=strlen(s);\r\n  for(i=0;i<len;i++)\r\n  {\r\n   c=s[i];\r\n   if(c>=\'A\' && c<=\'Z\') {printf(\"%c\",u[c-\'A\']);}\r\n   else if(c>=\'a\' && c<=\'z\') {printf(\"%c\",l[c-\'a\']);}\r\n   else {printf(\"%c\", c);}\r\n  }\r\n  printf(\"\\n\");\r\n }\r\n return 0;\r\n}\r\n'),(400,'#include <stdio.h> \r\nint main() \r\n{ \r\nchar List[2][27]={\"ECFAJKLBDGHIVWZYMNOPQRSTUX\",\"erwqtyghbnuiopsjkdlfazxcvm\"}; \r\nchar ch; \r\nwhile((ch=getchar())-\'#\') \r\n{ \r\nif(ch>=\'A\' && ch<=\'Z\') \r\n{putchar(List[0][ch-\'A\']);} \r\nelse if(ch>=\'a\' && ch<=\'z\') \r\n{putchar(List[1][ch-\'a\']);} \r\nelse\r\n{putchar(ch);}} \r\nreturn 0;}'),(401,'#include<stdio.h> \r\n#include<string.h> \r\n\r\nint main(){ \r\n    char a[10001]; \r\n    int i,n,data,start,p; \r\n  \r\n    while(gets(a)){ \r\n        n=strlen(a); \r\n        for(i=n/2;i>0;i--){ \r\n            if(i%2==0){ \r\n                start=n-n%i-1; \r\n                  \r\n                data=a[start]; \r\n                while(start!=i-1){ \r\n                    a[start]=a[start-i]; \r\n                    start=start-i; \r\n                } \r\n                a[i-1]=data; \r\n            } \r\n              \r\n            if(i%2==1){ \r\n                start=i-1; \r\n                  \r\n                data=a[start]; \r\n                p=n-n%i-1; \r\n                while(start!=n-n%i-1){ \r\n                    a[start]=a[start+i]; \r\n                    start=start+i; \r\n                } \r\n                a[n-n%i-1]=data; \r\n            } \r\n        } \r\n        printf(\"%s\\n\",a); \r\n    } \r\n}'),(402,'#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n	int i, j, len;\n	char code[1024] = \" \", tmp;\n\n	while (gets(code + 1))\n	{\n		len = strlen(code) - 1;\n		for (i = len / 2; i; i--)\n		{\n			if (i % 2)\n			{\n				tmp = code[i];\n				for (j = i; j + i <= len; j += i)\n					code[j] = code[j + i];\n				code[j] = tmp;\n				\n			}\n			else\n			{\n				tmp = code[len/i*i];\n				for (j = len/i*i; j; j -= i)\n					code[j] = code[j - i];\n				code[i] = tmp;\n			}\n		}\n		puts(code + 1);\n	}\n\n	return 0;\n}'),(403,'#include<stdio.h>\r\n\r\nint main()\r\n{\r\n    int a[1005],b[1005],i,j,k,n;\r\n    while(scanf(\"%d\",&n),n)\r\n    {\r\n        while(scanf(\"%d\",&b[0]),b[0])\r\n        {\r\n            for(j=1; j<n; j++)\r\n                scanf(\"%d\",&b[j]);\r\n            for(i=1,j=0,k=0; i<=n&&j<n; i++,k++)\r\n            {\r\n                a[k]=i;\r\n                while(a[k]==b[j])\r\n                {\r\n                    if(k>0)k--;\r\n                    else\r\n                    {\r\n                        a[k]=0,k--;\r\n                    }\r\n                    j++;\r\n                    if(k==-1)break;\r\n                }\r\n            }\r\n            if(j==n)printf(\"Yes\\n\");\r\n            else printf(\"No\\n\");\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n'),(404,'#include<stdio.h>\nint main()\n{\n    int n,x,s,a,i,j,t,p[1000];\n    while(scanf(\"%d\",&n)&&n)\n    {\n        while(scanf(\"%d\",&x)&&x)\n        {\n            s=x-1;\n            for(j=0;j<x;j++)\n                p[j]=j;\n            a=x+1;\n            t=1;\n            for(i=1;i<n;i++)\n            {\n            scanf(\"%d\",&x);\n            if(t)\n            if(x>=a||x==p[s])\n            {\n                if(x==p[s])\n                s--;\n                else if(x>=a)\n                {\n                for(j=a;j<x;j++)\n                p[j-a+s+1]=j;\n                s+=x-a;\n                a=x+1;\n                }\n            }\n            else t=0;\n            }\n    if(t) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}  '),(405,'#include <stdio.h> \r\n#include <string.h> \r\n#include <stdlib.h> \r\n  \r\nint compare(const void *m,const void *n) \r\n{ \r\n    return strcmp((char *)m,(char *)n); \r\n} \r\n  \r\nint main(void) \r\n{ \r\n    char    bi[20][80]; \r\n    char    temp[80]; \r\n    int count; \r\n    int i; \r\n    int cs=0; \r\n    int not; \r\n  \r\n    while(scanf(\"%s\",bi[0])!=EOF) \r\n    { \r\n        cs++; \r\n        not=1; \r\n        for(count=1;scanf(\"%s\",bi[count]),strcmp(bi[count],\"9\");count++); \r\n        qsort(bi,count,sizeof(bi[0]),compare); \r\n        for(i=0;i<count-1;i++) \r\n        { \r\n            strncpy(temp,bi[i+1],strlen(bi[i])); \r\n            temp[strlen(bi[i])]=\'\\0\'; \r\n            if(!strcmp(temp,bi[i])) \r\n            { \r\n                printf(\"Set %d is not immediately decodable\\n\",cs); \r\n                not=0; \r\n                break; \r\n            } \r\n        } \r\n        if(not) \r\n        { \r\n            printf(\"Set %d is immediately decodable\\n\",cs); \r\n        } \r\n    } \r\n    return 0; \r\n}'),(406,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint compare(const void *m,const void *n)\n{\n	return strcmp((char *)m,(char *)n);\n}\n\nint main(void)\n{\n	char	bi[20][80];\n	char	temp[80];\n	int	count;\n	int	i;\n	int	cs=0;\n	int	not;\n\n	while(scanf(\"%s\",bi[0])!=EOF)\n	{\n		cs++;\n		not=1;\n		for(count=1;scanf(\"%s\",bi[count]),strcmp(bi[count],\"9\");count++);\n		qsort(bi,count,sizeof(bi[0]),compare);\n		for(i=0;i<count-1;i++)\n		{\n			strncpy(temp,bi[i+1],strlen(bi[i]));\n			temp[strlen(bi[i])]=\'\\0\';\n			if(!strcmp(temp,bi[i]))\n			{\n				printf(\"Set %d is not immediately decodable\\n\",cs);\n				not=0;\n				break;\n			}\n		}\n		if(not)\n		{\n			printf(\"Set %d is immediately decodable\\n\",cs);\n		}\n	}\n	return 0;\n}'),(407,'#include<iostream>\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    int N,X,Y;\r\n    char F,Array[32][32];\r\n    cin>>N;\r\n    for(int i=1;i<=N;++i)\r\n    {\r\n         for(int j=0;j<32;++j)\r\n              for(int k=0;k<32;++k)\r\n                   Array[j][k]=\'.\';\r\n         cin>>X>>Y;\r\n         while(cin>>F&&F!=\'.\')\r\n         {\r\n              if(F==\'E\'){\r\n                         Array[32-Y][X]=\'X\';\r\n                         ++X;\r\n              }      \r\n              else if(F==\'W\'){\r\n                         Array[31-Y][X-1]=\'X\';\r\n                         --X;\r\n              }              \r\n              else if(F==\'S\'){\r\n                         Array[32-Y][X-1]=\'X\';\r\n                         --Y;\r\n              }\r\n              else if(F==\'N\'){\r\n                         Array[31-Y][X]=\'X\';\r\n                         ++Y;\r\n              }\r\n         }\r\n         cout<<\"Bitmap #\"<<i<<endl;\r\n         for(int j=0;j<32;++j)\r\n         {\r\n              for(int k=0;k<32;++k)\r\n                   cout<<Array[j][k];\r\n              cout<<endl;\r\n         }\r\n         cout<<endl;\r\n    }\r\n    return 0;\r\n}'),(408,'#include<iostream>\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    int N,X,Y;\r\n    char F,Array[32][32];\r\n    cin>>N;\r\n    for(int i=1;i<=N;++i)\r\n    {\r\n         for(int j=0;j<32;++j)\r\n              for(int k=0;k<32;++k)\r\n                   Array[j][k]=\'.\';\r\n         cin>>X>>Y;\r\n         while(cin>>F&&F!=\'.\')\r\n         {\r\n              if(F==\'E\'){\r\n                         Array[32-Y][X]=\'X\';\r\n                         ++X;\r\n              }      \r\n              else if(F==\'W\'){\r\n                         Array[31-Y][X-1]=\'X\';\r\n                         --X;\r\n              }              \r\n              else if(F==\'S\'){\r\n                         Array[32-Y][X-1]=\'X\';\r\n                         --Y;\r\n              }\r\n              else if(F==\'N\'){\r\n                         Array[31-Y][X]=\'X\';\r\n                         ++Y;\r\n              }\r\n         }\r\n         cout<<\"Bitmap #\"<<i<<endl;\r\n         for(int j=0;j<32;++j)\r\n         {\r\n              for(int k=0;k<32;++k)\r\n                   cout<<Array[j][k];\r\n              cout<<endl;\r\n         }\r\n         cout<<endl;\r\n    }\r\n    return 0;\r\n}'),(409,'#include <stdio.h>\n#include <string.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n\nvoid space(int n)\n{\n	int i;\n	for (i = 0 ; i < n ; putchar(\' \'), i++);\n}\n\nvoid change(char *s, int *n)\n{\n	int i;\n	int len = strlen(s);\n	for (i = 0 ; i < len ; i++)\n		n[i] = s[len - 1 - i] - \'0\';\n}\n\nvoid addnum(int *a, int *b, int *c, int len)\n{\n	int i;\n	for (i = 0 ; i <= len ; i++)\n	{\n		c[i] += a[i] + b[i];\n		c[i + 1] += c[i] / 10;\n		c[i] %= 10;\n	}\n}\n\nvoid popnum(int *a, int *b, int len)\n{\n	int i;\n	for (i = 0 ; i < len ; i++)\n	{\n		a[i] -= b[i];\n		if (a[i] < 0)\n		{\n			a[i + 1]--;\n			a[i] += 10;\n		}\n	}\n}\n\nvoid mulnum(int *a, int *b, int *res, int lena, int lenb)\n{\n	int i;\n	int j;\n\n	for (i = 0 ; i < 1024 ; i++)\n		res[i] = 0;\n	for (i = 0 ; i < lenb ; i++)\n	{\n		for (j = 0 ; j < lena ; j++)\n		{\n			res[j + i] += b[i] * a[j];\n			res[i + j + 1] += res[j + i] / 10;\n			res[j + i] %= 10;\n		}\n	}\n}\n\nint numlen(int *p)\n{\n	int i;\n	for (i = 1023 ; i && !p[i] ; i--);\n	return i + 1;\n}\n\nint main(void)\n{\n	int n;\n	char *p;\n	char c;\n	int i;\n	int j;\n	int nub1[512];\n	int nub2[512];\n	int res[1024];\n	int tmp[1024];\n	int len[4];\n	int max;\n	int max2;\n	char symbol[4] = {\"-+*\"};\n	char num1[512];\n	char num2[512];\n	char temp[1024];\n\n	scanf(\"%d\", &n);\n	while (n--)\n	{\n		scanf(\"%s\", temp);\n		p = strpbrk(temp, symbol);\n		c = *p;\n		*p = \'\\0\';\n		strcpy(num1, temp);\n		strcpy(num2, p + 1);\n		len[0] = strlen(num1);\n		len[1] = strlen(num2) + 1;\n		max2 = max = MAX(len[0], len[1]);\n		for (i = 0 ; i < 512 ; i++)\n			nub1[i] = nub2[i] = 0;\n		for (i = 0 ; i < 1024 ; i++)\n			res[i] = 0;\n		change(num1, nub1);\n		change(num2, nub2);\n		switch (c)\n		{\n			case \'+\':\n				addnum(nub1, nub2, res, max);\n				len[2] = numlen(res);\n				max = MAX(max, len[2]);\n				space(max - len[0]);\n				puts(num1);\n				space(max - len[1]);\n				printf(\"%c\", c);\n				puts(num2);\n				max2 = MAX(len[1], len[2]);\n				space(max - max2);\n				for (i = 0 ; i < max2 ; i++)\n					putchar(\'-\');\n				printf(\"\\n\");\n				space(max - len[2]);\n				for (i = len[2] - 1 ; i>= 0 ; i--)\n					printf(\"%d\", res[i]);\n				printf(\"\\n\");\n				break;\n			case \'-\':\n				for (i = 0 ; i < len[0] ; i++)\n					res[i] = nub1[i];\n				popnum(res, nub2, max);\n				len[2] = numlen(res);\n				max = MAX(max, len[2]);\n				space(max - len[0]);\n				puts(num1);\n				space(max - len[1]);\n				printf(\"%c\", c);\n				puts(num2);\n				max2 = MAX(len[1], len[2]);\n				space(max - max2);\n				for (i = 0 ; i < max2 ; i++)\n					putchar(\'-\');\n				printf(\"\\n\");\n				space(max - len[2]);\n				for (i = len[2] - 1 ; i>= 0 ; i--)\n					printf(\"%d\", res[i]);\n				printf(\"\\n\");\n				break;\n			case \'*\':\n				mulnum(nub1, nub2, res, len[0], len[1]);\n				len[2] = numlen(res);\n				max = MAX(max, len[2]);\n				space(max - len[0]);\n				puts(num1);\n				space(max - len[1]);\n				printf(\"%c\", c);\n				puts(num2);\n				if (len[1] > 2)\n				{\n					mulnum(nub1, nub2 , tmp, len[0], 1);\n					len[3] = numlen(tmp);\n					max2 = MAX(len[1], len[3]);\n					space(max - max2);\n					for (i = 0 ; i < max2 ; i++)\n						putchar(\'-\');\n					printf(\"\\n\");\n					space(max - len[3]);\n					for (j = 1023 ; j && !tmp[j] ; j--);\n					for (; j >= 0 ; j--)\n						printf(\"%d\", tmp[j]);\n					putchar(\'\\n\');\n					for (i = 1 ; i < len[1] - 1 ; i++)\n					{\n						mulnum(nub1, nub2 + i, tmp, len[0], 1);\n						len[3] = numlen(tmp);\n						space(max - len[3] - i);\n						for (j = 1023 ; j && !tmp[j] ; j--);\n						for (; j >= 0 ; j--)\n							printf(\"%d\", tmp[j]);\n						putchar(\'\\n\');\n					}\n				}\n				max2 = len[1] > 2 ? MAX(len[3], len[2]) : MAX(len[1], len[2]);\n				space(max - max2);\n				for (i = 0 ; i < max2 ; i++)\n					printf(\"-\");\n				putchar(\'\\n\');\n				space(max - len[2]);\n				for (i = len[2] - 1 ; i >= 0 ; i--)\n					printf(\"%d\", res[i]);\n				putchar(\'\\n\');\n				break;\n			default :\n				break;\n		}\n		putchar(\'\\n\');\n	}\n	return 0;\n}\n'),(410,'#include <stdio.h>\n#include <string.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n\nvoid space(int n)\n{\n	int i;\n	for (i = 0 ; i < n ; putchar(\' \'), i++);\n}\n\nvoid change(char *s, int *n)\n{\n	int i;\n	int len = strlen(s);\n	for (i = 0 ; i < len ; i++)\n		n[i] = s[len - 1 - i] - \'0\';\n}\n\nvoid addnum(int *a, int *b, int *c, int len)\n{\n	int i;\n	for (i = 0 ; i <= len ; i++)\n	{\n		c[i] += a[i] + b[i];\n		c[i + 1] += c[i] / 10;\n		c[i] %= 10;\n	}\n}\n\nvoid popnum(int *a, int *b, int len)\n{\n	int i;\n	for (i = 0 ; i < len ; i++)\n	{\n		a[i] -= b[i];\n		if (a[i] < 0)\n		{\n			a[i + 1]--;\n			a[i] += 10;\n		}\n	}\n}\n\nvoid mulnum(int *a, int *b, int *res, int lena, int lenb)\n{\n	int i;\n	int j;\n\n	for (i = 0 ; i < 1024 ; i++)\n		res[i] = 0;\n	for (i = 0 ; i < lenb ; i++)\n	{\n		for (j = 0 ; j < lena ; j++)\n		{\n			res[j + i] += b[i] * a[j];\n			res[i + j + 1] += res[j + i] / 10;\n			res[j + i] %= 10;\n		}\n	}\n}\n\nint numlen(int *p)\n{\n	int i;\n	for (i = 1023 ; i && !p[i] ; i--);\n	return i + 1;\n}\n\nint main(void)\n{\n	int n;\n	char *p;\n	char c;\n	int i;\n	int j;\n	int nub1[512];\n	int nub2[512];\n	int res[1024];\n	int tmp[1024];\n	int len[4];\n	int max;\n	int max2;\n	char symbol[4] = {\"-+*\"};\n	char num1[512];\n	char num2[512];\n	char temp[1024];\n\n	scanf(\"%d\", &n);\n	while (n--)\n	{\n		scanf(\"%s\", temp);\n		p = strpbrk(temp, symbol);\n		c = *p;\n		*p = \'\\0\';\n		strcpy(num1, temp);\n		strcpy(num2, p + 1);\n		len[0] = strlen(num1);\n		len[1] = strlen(num2) + 1;\n		max2 = max = MAX(len[0], len[1]);\n		for (i = 0 ; i < 512 ; i++)\n			nub1[i] = nub2[i] = 0;\n		for (i = 0 ; i < 1024 ; i++)\n			res[i] = 0;\n		change(num1, nub1);\n		change(num2, nub2);\n		switch (c)\n		{\n			case \'+\':\n				addnum(nub1, nub2, res, max);\n				len[2] = numlen(res);\n				max = MAX(max, len[2]);\n				space(max - len[0]);\n				puts(num1);\n				space(max - len[1]);\n				printf(\"%c\", c);\n				puts(num2);\n				max2 = MAX(len[1], len[2]);\n				space(max - max2);\n				for (i = 0 ; i < max2 ; i++)\n					putchar(\'-\');\n				printf(\"\\n\");\n				space(max - len[2]);\n				for (i = len[2] - 1 ; i>= 0 ; i--)\n					printf(\"%d\", res[i]);\n				printf(\"\\n\");\n				break;\n			case \'-\':\n				for (i = 0 ; i < len[0] ; i++)\n					res[i] = nub1[i];\n				popnum(res, nub2, max);\n				len[2] = numlen(res);\n				max = MAX(max, len[2]);\n				space(max - len[0]);\n				puts(num1);\n				space(max - len[1]);\n				printf(\"%c\", c);\n				puts(num2);\n				max2 = MAX(len[1], len[2]);\n				space(max - max2);\n				for (i = 0 ; i < max2 ; i++)\n					putchar(\'-\');\n				printf(\"\\n\");\n				space(max - len[2]);\n				for (i = len[2] - 1 ; i>= 0 ; i--)\n					printf(\"%d\", res[i]);\n				printf(\"\\n\");\n				break;\n			case \'*\':\n				mulnum(nub1, nub2, res, len[0], len[1]);\n				len[2] = numlen(res);\n				max = MAX(max, len[2]);\n				space(max - len[0]);\n				puts(num1);\n				space(max - len[1]);\n				printf(\"%c\", c);\n				puts(num2);\n				if (len[1] > 2)\n				{\n					mulnum(nub1, nub2 , tmp, len[0], 1);\n					len[3] = numlen(tmp);\n					max2 = MAX(len[1], len[3]);\n					space(max - max2);\n					for (i = 0 ; i < max2 ; i++)\n						putchar(\'-\');\n					printf(\"\\n\");\n					space(max - len[3]);\n					for (j = 1023 ; j && !tmp[j] ; j--);\n					for (; j >= 0 ; j--)\n						printf(\"%d\", tmp[j]);\n					putchar(\'\\n\');\n					for (i = 1 ; i < len[1] - 1 ; i++)\n					{\n						mulnum(nub1, nub2 + i, tmp, len[0], 1);\n						len[3] = numlen(tmp);\n						space(max - len[3] - i);\n						for (j = 1023 ; j && !tmp[j] ; j--);\n						for (; j >= 0 ; j--)\n							printf(\"%d\", tmp[j]);\n						putchar(\'\\n\');\n					}\n				}\n				max2 = len[1] > 2 ? MAX(len[3], len[2]) : MAX(len[1], len[2]);\n				space(max - max2);\n				for (i = 0 ; i < max2 ; i++)\n					printf(\"-\");\n				putchar(\'\\n\');\n				space(max - len[2]);\n				for (i = len[2] - 1 ; i >= 0 ; i--)\n					printf(\"%d\", res[i]);\n				putchar(\'\\n\');\n				break;\n			default :\n				break;\n		}\n		putchar(\'\\n\');\n	}\n	return 0;\n}\n'),(411,'#include<iostream>\r\nusing namespace std;\r\nchar a[1500][1500];\r\nint num;\r\nvoid f(int x,int y)\r\n{\r\n   \r\nif(a[x][y]==\'*\')\r\n{\r\n     a[x][y]=\'.\';\r\n     num++;\r\n   f(x,y+1);\r\n   f(x,y-1);\r\n   f(x+1,y);\r\n   f(x-1,y);\r\n}\r\n}\r\nint main()\r\n{\r\n   int m,n,i,j,max=0;\r\n   cin>>m>>n;\r\n   for(i=1;i<=n;i++)\r\n       for(j=1;j<=m;j++)\r\n           cin>>a[i][j];\r\n     for(i=1;i<=n;i++) \r\n         { \r\n             for(j=1;j<=m;j++) \r\n           { \r\n                 num=0; \r\n                 f(i,j); \r\n                  if(num>max) \r\n                      max=num; \r\n             } \r\n        } \r\n    cout<<max<<endl;\r\n}'),(412,'#include<iostream>\r\nusing namespace std;\r\nchar a[1500][1500];\r\nint num;\r\nvoid f(int x,int y)\r\n{\r\n   \r\nif(a[x][y]==\'*\')\r\n{\r\n     a[x][y]=\'.\';\r\n     num++;\r\n   f(x,y+1);\r\n   f(x,y-1);\r\n   f(x+1,y);\r\n   f(x-1,y);\r\n}\r\n}\r\nint main()\r\n{\r\n   int m,n,i,j,max=0;\r\n   cin>>m>>n;\r\n   for(i=1;i<=n;i++)\r\n       for(j=1;j<=m;j++)\r\n           cin>>a[i][j];\r\n     for(i=1;i<=n;i++) \r\n         { \r\n             for(j=1;j<=m;j++) \r\n           { \r\n                 num=0; \r\n                 f(i,j); \r\n                  if(num>max) \r\n                      max=num; \r\n             } \r\n        } \r\n    cout<<max<<endl;\r\n}'),(413,'//Memory Time \r\n//212K   16MS \r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\ntypedef class\r\n{\r\n    public:\r\n        int prime;\r\n        int step;\r\n}number;\r\n\r\nbool JudgePrime(int digit)\r\n{\r\n    if(digit==2 || digit==3)\r\n        return true;\r\n    else if(digit<=1 || digit%2==0)\r\n        return false;\r\n    else if(digit>3)\r\n    {\r\n        for(int i=3;i*i<=digit;i+=2)\r\n            if(digit%i==0)\r\n                return false;\r\n        return true;\r\n    }\r\n}\r\n\r\nint a,b;\r\nbool vist[15000];\r\nnumber queue[15000];\r\n\r\nvoid BFS(void)\r\n{\r\n    int i;  //temporary\r\n    int head,tail;\r\n    queue[head=tail=0].prime=a;\r\n    queue[tail++].step=0;\r\n    vist[a]=true;\r\n\r\n    while(head<tail)\r\n    {\r\n        number x=queue[head++];\r\n        if(x.prime==b)\r\n        {\r\n            cout<<x.step<<endl;\r\n            return;\r\n        }\r\n\r\n        int unit=x.prime%10;       //获取x的个位\r\n        int deca=(x.prime/10)%10;  //获取x的十位\r\n\r\n        for(i=1;i<=9;i+=2)     //枚举x的个位，保证四位数为奇数（偶数必不是素数）\r\n        {\r\n            int y=(x.prime/10)*10+i;\r\n            if(y!=x.prime && !vist[y] && JudgePrime(y))\r\n            {\r\n                vist[y]=true;\r\n                queue[tail].prime=y;\r\n                queue[tail++].step=x.step+1;\r\n            }\r\n        }\r\n        for(i=0;i<=9;i++)     //枚举x的十位\r\n        {\r\n            int y=(x.prime/100)*100+i*10+unit;\r\n            if(y!=x.prime && !vist[y] && JudgePrime(y))\r\n            {\r\n                vist[y]=true;\r\n                queue[tail].prime=y;\r\n                queue[tail++].step=x.step+1;\r\n            }\r\n        }\r\n        for(i=0;i<=9;i++)     //枚举x的百位\r\n        {\r\n            int y=(x.prime/1000)*1000+i*100+deca*10+unit;\r\n            if(y!=x.prime && !vist[y] && JudgePrime(y))\r\n            {\r\n                vist[y]=true;\r\n                queue[tail].prime=y;\r\n                queue[tail++].step=x.step+1;\r\n            }\r\n        }\r\n        for(i=1;i<=9;i++)     //枚举x的千位,保证四位数，千位最少为1\r\n        {\r\n            int y=x.prime%1000+i*1000;\r\n            if(y!=x.prime && !vist[y] && JudgePrime(y))\r\n            {\r\n                vist[y]=true;\r\n                queue[tail].prime=y;\r\n                queue[tail++].step=x.step+1;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    cout<<\"Impossible\"<<endl;\r\n    return;\r\n}\r\n\r\nint main(void)\r\n{\r\n    int test;\r\n    cin>>test;\r\n    while(test--)\r\n    {\r\n        cin>>a>>b;\r\n        memset(vist,false,sizeof(vist));\r\n        BFS();\r\n    }\r\n    return 0;\r\n}'),(414,'#include<iostream>\n#include<cstdio>\n#include<queue>\n\n#define INTMAX 2147483647\n\nusing namespace std;\n\nvoid play(int num, int goal, int visited[], bool isPrime[]) {\n	int x, y;\n	char strNum[5];\n	queue <int> que;\n	que.push(num);\n	visited[num] = 0;\n	while(!que.empty()) {\n		x = que.front();\n		que.pop();\n		if(x == goal) return;\n		for(int i=0; i<4; i++) {\n			for(int j=0; j<=9; j++) {\n				sprintf(strNum, \"%d\", x);\n				strNum[i] = j + \'0\';\n				sscanf(strNum, \"%d\", &y);\n				if(y < 1000) continue;\n				if(isPrime[y] == false) continue;\n				if(visited[x]+1 < visited[y]) { visited[y] = visited[x] + 1; que.push(y); }\n			}\n		}\n	}\n}\n\nint main(void) {\n	bool isPrime[10000];\n	isPrime[0] = isPrime[1] = false;\n	for(int i=2; i<10000; i++) isPrime[i] = true;\n	for(int i=2; i<5000; i++) {\n		if(isPrime[i] == false) continue;\n		for(int j=2; i*j<10000; j++) isPrime[i*j] = false;\n	}\n	\n	int tcase, num, goal, answer;\n	int visited[10000];\n\n	cin >> tcase;\n	while(tcase--) {\n		cin >> num >> goal;\n		for(int i=0; i<10000; i++) visited[i] = INTMAX;\n		play(num, goal, visited, isPrime);\n		cout << visited[goal] << endl;\n	}\n	return 0;\n}\n\n'),(415,'#include <iostream>\r\n#include <string.h>\r\n#include <cstdio>\r\nusing namespace std;\r\nconst int N=12010;\r\nint p[N],relation[N];\r\nint find(int x){\r\n	int px=p[x];\r\n	if(x==p[x])return x;\r\n	p[x]=find(p[x]);\r\n	relation[x]=(relation[x]+relation[px])%2;\r\n	return p[x];\r\n}\r\nint main(){\r\n	//freopen(\"in.txt\",\"r\",stdin);\r\n	int numcase,k=0;\r\n	scanf(\"%d\",&numcase);\r\n	while(numcase--){\r\n	  int n,m;\r\n	  scanf(\"%d%d\",&n,&m);\r\n	  int a,b,flag=0;\r\n	  for(int i=1;i<=n;++i){\r\n	    p[i]=i;\r\n		relation[i]=0;\r\n	  }\r\n	  while(m--){\r\n	    scanf(\"%d%d\",&a,&b);\r\n		if(flag==1)\r\n			continue;\r\n		int roota=find(a);\r\n		int rootb=find(b);\r\n		if(roota==rootb){\r\n			if(relation[a]==relation[b]){\r\n			  flag=1;\r\n			}\r\n		}\r\n		else{\r\n		  p[rootb]=roota;\r\n		  relation[rootb]=((relation[a]+1)%2+relation[b])%2;\r\n		}\r\n	  }\r\n	  printf(\"Scenario #%d:\\n\",++k);\r\n	  if(flag)puts(\"Suspicious bugs found!\");\r\n	  else puts(\"No suspicious bugs found!\");\r\n	  puts(\"\");\r\n	}\r\n	return 0;\r\n}'),(416,'#include<stdio.h>\nvoid main()\n{\n	int n,m;\n	scanf(\"%d\",&m);\n	while(m--)\n	{scanf(\"%d\",&n);\nif(n==1)printf(\"1\\n\");\nif(n==2)printf(\"2 1\\n\");\nif(n==3)printf(\"3 1 2\\n\");\nif(n==4)printf(\"2 1 4 3\\n\");\nif(n==5)printf(\"3 1 4 5 2\\n\");\nif(n==6)printf(\"4 1 6 3 2 5\\n\");\nif(n==7)printf(\"5 1 3 4 2 6 7\\n\");\nif(n==8)printf(\"3 1 7 5 2 6 8 4\\n\");\nif(n==9)printf(\"7 1 8 6 2 9 4 5 3\\n\");\nif(n==10)printf(\"9 1 8 5 2 4 7 6 3 10\\n\");\nif(n==11)printf(\"5 1 6 4 2 10 11 7 3 8 9\\n\");\nif(n==12)printf(\"7 1 4 9 2 11 10 8 3 6 5 12\\n\");\nif(n==13)printf(\"4 1 13 11 2 10 6 7 3 5 12 9 8\\n\");\n}\n}\n\n'),(417,'#include <stdio.h>\r\n#include <stdlib.h>\r\nint n,i,j,end_i,end_j,start_i,start_j;\r\nint l,h,k=0;\r\nchar s[500][500];\r\nstruct point\r\n{\r\n int row,col;\r\n int pre;\r\n}queue[512],p;\r\nfront=0;rear=0;\r\nvoid enqueue(struct point e)\r\n{\r\nqueue[rear++]=e;\r\n}\r\nstruct point dequeue()\r\n{\r\nreturn queue[front++];\r\n}\r\nint empty()\r\n{\r\n return front==rear;\r\n}\r\nvoid visit(int row,int col)\r\n{\r\n struct point visit_point={row,col,front-1};\r\n s[row][col]=\'2\';\r\n enqueue(visit_point);\r\n}\r\nint main()\r\n{\r\n scanf(\"%d\",&n);\r\n while(n--)\r\n {\r\n  k=0;\r\n  p.row=start_i;p.col=start_j;p.pre=-1;\r\nscanf(\"%d %d\",&l,&h);\r\nfor(i=0;i<l;i++)\r\nscanf(\"%s\",s[i]);\r\nfor(i=0;i<l;i++)\r\nfor(j=0;j<h;j++)\r\n{\r\n if(s[i][j]==\'S\')\r\n{\r\nstart_i=i;\r\nstart_j=j;\r\n}\r\n if(s[i][j]==\'E\')\r\n {\r\nend_i=i;\r\nend_j=j;\r\n }\r\n}\r\nenqueue(p);\r\nwhile(!empty())\r\n{\r\n p=dequeue();\r\nif(p.row==end_i&&p.col==end_j)\r\nbreak;\r\nif(p.row<l-1&&(s[p.row+1][p.col]==\'-\'||s[p.row+1][p.col]==\'E\'))\r\nvisit(p.row+1,p.col);\r\nif(p.row>0&&(s[p.row-1][p.col]==\'-\'||s[p.row-1][p.col]==\'E\'))\r\nvisit(p.row-1,p.col);\r\nif(p.col>0&&(s[p.row][p.col-1]==\'-\'||s[p.row][p.col-1]==\'E\'))\r\nvisit(p.row,p.col-1);\r\nif(p.col<h-1&&(s[p.row][p.col+1]==\'-\'||s[p.row][p.col+1]==\'E\'))\r\nvisit(p.row,p.col+1);\r\n}\r\nif(p.row==end_i&&p.col==end_j)\r\n{\r\ndo\r\n{\r\n k++;\r\n p=queue[p.pre];\r\n}while(p.pre!=-1);\r\nprintf(\"%d\\n\",k);\r\n}\r\nelse\r\n{\r\nprintf(\"-1\\n\");\r\n}\r\n }\r\n}'),(418,'#include <stdio.h>\n#include <string.h>\n\nint eva(char *num, int len)\n{\n	int i;\n	char sum[512];\n\n	for (i = 1 ; i < len ; i++)\n	{\n		memset(sum, 0, sizeof(sum));\n		strncpy(sum, num + i, len - i);\n		strncpy(sum + len - i, num, i);\n		if (strncmp(num, sum, len) > 0)\n			return 0;\n	}\n\n	return 1;\n}\n\nint main(void)\n{\n	int n, i, j;\n	int len;\n	char *p;\n	char num[512];\n\n	scanf(\"%d%*c\", &n);\n	while (n--)\n	{\n		gets(num);\n		p = num;\n		while (len = strlen(p))\n		{\n			for (j = len ; !eva(p, j) ; j--)\n				;\n			putchar(\'(\');\n			for (i = 0 ; i < j ; i++)\n				putchar(*(p + i));\n			putchar(\')\');\n			p += j;\n		}\n		putchar(\'\\n\');\n	}\n\n	return 0;\n}'),(419,'#include <stdio.h> \r\n#include <stdlib.h> \r\nmain() \r\n{ \r\n int s, d, sum, max; \r\n while(scanf(\"%d%d\", &s, &d) == 2)  \r\n{ max = -12 * d; if (4 * s < d) { sum = 10 * s - 2 * d; if (sum > max) max = sum; } else if (3 * s < 2 * d) { sum = 8 * s - 4 * d; if (sum > max) max = sum; }  \r\nelse if (2 * s < 3 * d) { sum = 6 * s - 6 * d; if (sum > max) max = sum; } \r\nelse if (s < 4 * d) { sum = 3 * s - 9 * d; if (sum > max) max = sum; }  \r\nif (max > 0) { printf(\"%d\\n\", max); }  \r\nelse { printf(\"Deficit\\n\"); \r\n } \r\n }  \r\n return 0; \r\n}'),(420,'#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int s,d;\r\n	int res;\r\n	while(cin>>s && cin>>d)\r\n	{\r\n		if(d>4*s)res=10*s-2*d;\r\n		else if(2*d>3*s)res=8*s-4*d;\r\n		else if(3*d>2*s)res=6*(s-d);\r\n		else if(4*d>s)res=3*(s-3*d);\r\n		else res=-1;\r\n		if(res<0)cout<<\"Deficit\"<<endl;\r\n		else cout<<res<<endl;\r\n	}\r\n	return 0;\r\n}'),(421,'#include <stdio.h>\n#include <math.h>\n\ndouble lat[1000], lng[1000], x[1000], y[1000], z[1000];\ndouble d, bestcos = -1, mincos;\nint n, besti;\n\nmain(){\n   int i,j,k;\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) {\n      scanf(\"%lf%lf\",&lat[i],&lng[i]);\n      z[i] = sin(lat[i]*M_PI/180);\n      x[i] = cos(lng[i]*M_PI/180) * cos(lat[i]*M_PI/180);\n      y[i] = sin(lng[i]*M_PI/180) * cos(lat[i]*M_PI/180);\n   }\n   for (i=0;i<n;i++){\n      mincos = 1;\n      for (j=0;j<n;j++){\n         d = x[i]*x[j] + y[i]*y[j] + z[i]*z[j];\n         if (d < mincos) mincos = d;\n      }\n      if (mincos > bestcos) {\n         bestcos = mincos;\n         besti = i;\n      }\n   }\n   printf(\"%0.2lf %0.2lf\\n\",lat[besti],lng[besti]);\n} \n      \n'),(422,'#include <stdio.h>\n#include <math.h>\n\ndouble lat[1000], lng[1000], x[1000], y[1000], z[1000];\ndouble d, bestcos = -1, mincos;\nint n, besti;\n\nmain(){\n   int i,j,k;\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) {\n      scanf(\"%lf%lf\",&lat[i],&lng[i]);\n      z[i] = sin(lat[i]*M_PI/180);\n      x[i] = cos(lng[i]*M_PI/180) * cos(lat[i]*M_PI/180);\n      y[i] = sin(lng[i]*M_PI/180) * cos(lat[i]*M_PI/180);\n   }\n   for (i=0;i<n;i++){\n      mincos = 1;\n      for (j=0;j<n;j++){\n         d = x[i]*x[j] + y[i]*y[j] + z[i]*z[j];\n         if (d < mincos) mincos = d;\n      }\n      if (mincos > bestcos) {\n         bestcos = mincos;\n         besti = i;\n      }\n   }\n   printf(\"%0.2lf %0.2lf\\n\",lat[besti],lng[besti]);\n} \n      \n'),(423,'#include <stdio.h>\n#include <math.h>\n\nint n;\ndouble x[1000], y[1000], r[1000];\nint top[1000];\n\nint possible = 1;\ndouble ne = 1000, nw = 1000;\n\nmain(){\n   int i,j,k;\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) scanf(\"%lf%lf%lf\",&x[i],&y[i],&r[i]);\n   for (i=0;i<n;i++) if (y[i]+r[i] > 1000) visit(i);\n   if (possible) printf(\n     \"Bill enters at (0.00, %0.2lf) and leaves at (1000.00, %0.2lf).\\n\",nw,ne);\n   else printf(\"Bill will be bitten.\\n\");\n}\n\nvisit(int i){\n   int j,k;\n   double yy;\n   if (top[i]++) return;\n\n   for (j=0;j<n;j++) {\n      if (hypot(x[j]-x[i],y[j]-y[i]) < r[i]+r[j]) visit(j);\n   }\n   if (y[i]-r[i] < 0) possible = 0;\n   if (x[i]-r[i] < 0) {\n      yy = y[i] - sqrt(r[i]*r[i] - x[i]*x[i]);\n      if (yy < nw) nw = yy;\n   }\n   if (x[i]+r[i] > 1000) {\n      yy = y[i] - sqrt(r[i]*r[i] - (1000-x[i])*(1000-x[i]));\n      if (yy < ne) ne = yy;\n   }\n}\n'),(424,'#include <stdio.h>\n#include <math.h>\n\nint n;\ndouble x[1000], y[1000], r[1000];\nint top[1000];\n\nint possible = 1;\ndouble ne = 1000, nw = 1000;\n\nmain(){\n   int i,j,k;\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) scanf(\"%lf%lf%lf\",&x[i],&y[i],&r[i]);\n   for (i=0;i<n;i++) if (y[i]+r[i] > 1000) visit(i);\n   if (possible) printf(\n     \"Bill enters at (0.00, %0.2lf) and leaves at (1000.00, %0.2lf).\\n\",nw,ne);\n   else printf(\"Bill will be bitten.\\n\");\n}\n\nvisit(int i){\n   int j,k;\n   double yy;\n   if (top[i]++) return;\n\n   for (j=0;j<n;j++) {\n      if (hypot(x[j]-x[i],y[j]-y[i]) < r[i]+r[j]) visit(j);\n   }\n   if (y[i]-r[i] < 0) possible = 0;\n   if (x[i]-r[i] < 0) {\n      yy = y[i] - sqrt(r[i]*r[i] - x[i]*x[i]);\n      if (yy < nw) nw = yy;\n   }\n   if (x[i]+r[i] > 1000) {\n      yy = y[i] - sqrt(r[i]*r[i] - (1000-x[i])*(1000-x[i]));\n      if (yy < ne) ne = yy;\n   }\n}\n'),(425,'/* use of random() portable among:\n\n   Solaris, SunOS, DECUnix, Linux\n\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar jane[200], john[200];\nint janei, johni;\n\nmain(){\n   int i,j;\n   gets(jane);\n   gets(john);\n   for (j=janei=johni=0;j<1000 && strlen(jane)&&strlen(john);j++){\n      if (jane[janei] == john[johni]) {\n         if (random()/141%2 == 0) { /* jane wins */\n            printf(\"Snap! for Jane: \");\n            for (i=strlen(jane);i>janei;i--) jane[i+johni+1] = jane[i];\n            strncpy(jane+janei+1,john,johni+1);\n            strcpy(john,john+johni+1);\n            janei = janei + johni + 2;\n            johni = 0;\n            for (i=janei-1;i>=0;i--) printf(\"%c\",jane[i]);\n            printf(\"\\n\");\n         }else{  /* john wins */ \n            printf(\"Snap! for John: \");\n            for (i=strlen(john);i>johni;i--) john[i+janei+1] = john[i];\n            strncpy(john+johni+1,jane,janei+1);\n            strcpy(jane,jane+janei+1);\n            johni = johni + janei + 2;\n            janei = 0;\n            for (i=johni-1;i>=0;i--) printf(\"%c\",john[i]);\n            printf(\"\\n\");\n         }\n      }else{\n         janei++; johni++;\n      }\n      if (!jane[janei]) janei = 0;\n      if (!john[johni]) johni = 0;\n   }\n   if (!strlen(jane)) printf(\"John wins.\\n\");\n   else if (!strlen(john)) printf(\"Jane wins.\\n\");\n   else printf(\"No winner after %d turns\\n\",j);\n}\n'),(426,'/* use of random() portable among:\n\n   Solaris, SunOS, DECUnix, Linux\n\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar jane[200], john[200];\nint janei, johni;\n\nmain(){\n   int i,j;\n   gets(jane);\n   gets(john);\n   for (j=janei=johni=0;j<1000 && strlen(jane)&&strlen(john);j++){\n      if (jane[janei] == john[johni]) {\n         if (random()/141%2 == 0) { /* jane wins */\n            printf(\"Snap! for Jane: \");\n            for (i=strlen(jane);i>janei;i--) jane[i+johni+1] = jane[i];\n            strncpy(jane+janei+1,john,johni+1);\n            strcpy(john,john+johni+1);\n            janei = janei + johni + 2;\n            johni = 0;\n            for (i=janei-1;i>=0;i--) printf(\"%c\",jane[i]);\n            printf(\"\\n\");\n         }else{  /* john wins */ \n            printf(\"Snap! for John: \");\n            for (i=strlen(john);i>johni;i--) john[i+janei+1] = john[i];\n            strncpy(john+johni+1,jane,janei+1);\n            strcpy(jane,jane+janei+1);\n            johni = johni + janei + 2;\n            janei = 0;\n            for (i=johni-1;i>=0;i--) printf(\"%c\",john[i]);\n            printf(\"\\n\");\n         }\n      }else{\n         janei++; johni++;\n      }\n      if (!jane[janei]) janei = 0;\n      if (!john[johni]) johni = 0;\n   }\n   if (!strlen(jane)) printf(\"John wins.\\n\");\n   else if (!strlen(john)) printf(\"Jane wins.\\n\");\n   else printf(\"No winner after %d turns\\n\",j);\n}\n'),(427,'#include <stdio.h>   \r\n#include <string.h>   \r\n#include <math.h>   \r\n    \r\nint t;   \r\ndouble star, end;   \r\nint out;   \r\nint s;   \r\nint main()   \r\n{   \r\n    scanf(\"%d\", &t);   \r\n    while (t --)   \r\n    {   \r\n    scanf(\"%lf%lf\", &star, &end);   \r\n    if (star == end)   \r\n    {   \r\n        printf(\"0\\n\");   \r\n        continue;   \r\n    }   \r\n    long long bu = (long long)sqrt(end - star);   \r\n    s = (long long)(end - star) - (bu * bu);   \r\n    out = s / bu + bu * 2 - 1;   \r\n    s = s % bu;   \r\n    if (s != 0)   \r\n        out ++;   \r\n    printf(\"%d\\n\", out);   \r\n    }   \r\n    return 0;   \r\n} '),(428,'#include <iostream>  \r\n#include <cmath>  \r\nusing namespace std;  \r\n  \r\nint main()  \r\n{  \r\n    int x,y,n;  \r\n    cin >> n;  \r\n    while(n--)  \r\n    {  \r\n        cin >> x >> y;  \r\n        cout << (int)(sqrt(y-x)*2-1e-9) << endl;  \r\n    }  \r\n  \r\n    return 0;  \r\n}  '),(429,'#include<stdio.h>\r\n#define MAX 101\r\ntypedef struct _node\r\n{\r\n	float x,y;\r\n};\r\nstruct _node point[MAX];\r\n\r\ntypedef struct _edge\r\n{\r\n	int x,y;\r\n	float weight;\r\n};\r\nstruct _edge edge[MAX*MAX];\r\n\r\nint father[MAX];\r\nint rank[MAX];\r\n\r\nfloat ans;\r\n\r\nvoid initial()\r\n{\r\n    int _i;\r\n    memset(rank,0,sizeof(rank));\r\n    for(_i=0;_i<MAX;_i++)\r\n        father[_i]=_i;\r\n}\r\nint Find_Set(int x)\r\n{\r\n    if(x!=father[x])\r\n    {\r\n        father[x]=Find_Set(father[x]);\r\n    }\r\n    return father[x];\r\n}\r\nint Union(int x,int y,float w)\r\n{\r\n    x=Find_Set(x);\r\n    y=Find_Set(y);\r\n    if(x==y) return 0;\r\n    else if(rank[x]<=rank[y])\r\n    {\r\n        father[x]=y;\r\n        rank[y]+=rank[x];\r\n    }\r\n    else\r\n    {\r\n        father[y]=x;\r\n        rank[x]+=rank[y];\r\n    }\r\n    ans+=w;\r\n    return 1;\r\n}\r\nint cmp( const void *a ,const void *b )\r\n{\r\n    return (*(struct _edge *)a).weight > (*(struct _edge *)b).weight ? 1 : -1;\r\n}\r\nfloat dis(struct _node a,struct _node b)\r\n{\r\n	float tmp=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\r\n	return sqrt(tmp);\r\n}\r\n\r\nvoid print(int cnt)\r\n{\r\n	int i;\r\n	for(i=0;i<cnt;i++)\r\n	printf(\"%d %d %g/n\",edge[i].x,edge[i].y,edge[i].weight);\r\n}\r\nint main()\r\n{\r\n	//freopen(\"input\",\"r\",stdin);\r\n	int n;\r\n	int i,j;\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf(\"%f %f\",&point[i].x,&point[i].y);\r\n	}\r\n\r\n	int edge_cnt=0;\r\n	for(i=0;i<n;i++)\r\n	{\r\n		for(j=0;j<n;j++)\r\n		{\r\n			edge[edge_cnt].x=i,edge[edge_cnt].y=j;\r\n			edge[edge_cnt].weight=dis(point[i],point[j]);\r\n			edge_cnt++;\r\n		}\r\n	}\r\n\r\n	//print(edge_cnt);\r\n	qsort(edge,edge_cnt,sizeof(edge[0]),cmp);\r\n	//print(edge_cnt);\r\n	initial();\r\n	for(i=0;i<edge_cnt;i++)\r\n	{\r\n		Union(edge[i].x,edge[i].y,edge[i].weight);\r\n	}\r\n	printf(\"%.2f\",ans);\r\n\r\n	return 0;\r\n}\r\n'),(430,'#include <stdio.h>\n#include <math.h>\n\n#define hypot(a,b) sqrt((a)*(a)+(b)*(b))\n\ndouble x[100], y[100], bestd, totd;\nchar in[100];\nint n,nin,best;\n\nmain(){\n   int i,j,k;\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) scanf(\"%lf%lf\",&x[i],&y[i]);\n   in[0] = 1;\n   for (nin=1;nin<n;nin++){\n      bestd = 1e100;\n      for (i=0;i<n;i++) {\n         if (!in[i]) continue;\n         for (j=0;j<n;j++) {\n            if (i==j || in[j]) continue;\n            if (bestd == 1e100 || hypot(x[i]-x[j],y[i]-y[j]) < bestd){\n               best = j;\n               bestd = hypot(x[i]-x[j],y[i]-y[j]);\n            }\n         }\n      }\n      in[best]=1;\n      totd += bestd;\n   }\n   printf(\"%0.2lf\\n\",totd);\n}\n'),(431,'\n\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#define LINESIZE 32\nusing namespace std;\n\nstruct Rule {\n    string str1;\n    string str2;\n};\n\nint calcCount(string& initialStr, vector<Rule>& rules);\n\nint main()\n{\n    int caseNum = 0;\n    char buffer[LINESIZE];\n    vector<Rule> ruleList;\n    string initialStr;\n    char* p1;\n    char* p2;\n\n    // get case num\n    //cin.getline(buffer, LINESIZE);\n    caseNum =1;// atoi(buffer);\n\n    // skip blank line\n    //cin.getline(buffer, 32);\n\n    for (; caseNum != 0; caseNum--) {\n        // get initial string\n        cin.getline(buffer, LINESIZE);\n        buffer[strlen(buffer)-1] = \'\\0\';\n        initialStr = buffer+1;\n\n        // get replace list\n        cin.getline(buffer, LINESIZE);\n        while (buffer[0] != \'\\0\') {\n            p1 = strchr(buffer, \'\\\"\');\n            p1++;\n            p2 = strchr(p1, \'\\\"\');\n            *p2++ = \'\\0\';\n            Rule rule;\n            rule.str1 = p1;\n\n            p1 = strchr(p2, \'\\\"\');\n            p1++;\n            p2 = strchr(p1, \'\\\"\');\n            *p2 = \'\\0\';\n            rule.str2 = p1;\n\n            ruleList.push_back(rule);\n            cin.getline(buffer, LINESIZE);\n        }\n\n        int count = calcCount(initialStr, ruleList);\n        if (0 == count) {\n            cout << \"Too many.\" << endl;\n        } else {\n            cout << count << endl;\n        }\n        if (caseNum != 1) {\n            cout << endl;\n        }\n        ruleList.clear();\n    }\n}\n\nint calcCount(string& initialStr, vector<Rule>& rules)\n{\n    vector<string> strList;\n    strList.push_back(initialStr);\n    int i = 0;\n    int count = 0;\n    int maxSize = initialStr.size();\n    for (i = 0; i < strList.size(); i++) {\n        for (int k = 0; k < rules.size(); k++) {\n            if (rules[k].str1 == \"\" && rules[k].str2 != \"\") {\n                // must over 1000\n                return 0;\n            }\n            if (rules[k].str1 != rules[k].str2 && rules[k].str2.find(rules[k].str1, 0) != string::npos) {\n                // must over 1000\n                return 0;\n            }\n            int firstPos = -1;\n            while ((firstPos = strList[i].find(rules[k].str1, firstPos+1)) != string::npos) {\n                string tmpStr = strList[i];\n                tmpStr.replace(firstPos, rules[k].str1.size(), rules[k].str2);\n                int m = 0;\n                if (tmpStr.size() > maxSize) {\n                    if (count == 1000) {\n                        return 0;\n                    }\n                    maxSize = tmpStr.size();\n                    strList.push_back(tmpStr);\n                    count++;\n                    continue;\n                }\n                for (m = 0; m < strList.size(); m++) {\n                    if (strList[m] == tmpStr) {\n                        break;\n                    }\n                }\n                if (m == strList.size()) {\n                    if (count == 1000) {\n                        return 0;\n                    }\n                    strList.push_back(tmpStr);\n                    count++;\n                }\n            }\n        }\n    }\n\n    return i;\n}'),(432,'\n\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#define LINESIZE 32\nusing namespace std;\n\nstruct Rule {\n    string str1;\n    string str2;\n};\n\nint calcCount(string& initialStr, vector<Rule>& rules);\n\nint main()\n{\n    int caseNum = 0;\n    char buffer[LINESIZE];\n    vector<Rule> ruleList;\n    string initialStr;\n    char* p1;\n    char* p2;\n\n    // get case num\n    //cin.getline(buffer, LINESIZE);\n    caseNum =1;// atoi(buffer);\n\n    // skip blank line\n    //cin.getline(buffer, 32);\n\n    for (; caseNum != 0; caseNum--) {\n        // get initial string\n        cin.getline(buffer, LINESIZE);\n        buffer[strlen(buffer)-1] = \'\\0\';\n        initialStr = buffer+1;\n\n        // get replace list\n        cin.getline(buffer, LINESIZE);\n        while (buffer[0] != \'\\0\') {\n            p1 = strchr(buffer, \'\\\"\');\n            p1++;\n            p2 = strchr(p1, \'\\\"\');\n            *p2++ = \'\\0\';\n            Rule rule;\n            rule.str1 = p1;\n\n            p1 = strchr(p2, \'\\\"\');\n            p1++;\n            p2 = strchr(p1, \'\\\"\');\n            *p2 = \'\\0\';\n            rule.str2 = p1;\n\n            ruleList.push_back(rule);\n            cin.getline(buffer, LINESIZE);\n        }\n\n        int count = calcCount(initialStr, ruleList);\n        if (0 == count) {\n            cout << \"Too many.\" << endl;\n        } else {\n            cout << count << endl;\n        }\n        if (caseNum != 1) {\n            cout << endl;\n        }\n        ruleList.clear();\n    }\n}\n\nint calcCount(string& initialStr, vector<Rule>& rules)\n{\n    vector<string> strList;\n    strList.push_back(initialStr);\n    int i = 0;\n    int count = 0;\n    int maxSize = initialStr.size();\n    for (i = 0; i < strList.size(); i++) {\n        for (int k = 0; k < rules.size(); k++) {\n            if (rules[k].str1 == \"\" && rules[k].str2 != \"\") {\n                // must over 1000\n                return 0;\n            }\n            if (rules[k].str1 != rules[k].str2 && rules[k].str2.find(rules[k].str1, 0) != string::npos) {\n                // must over 1000\n                return 0;\n            }\n            int firstPos = -1;\n            while ((firstPos = strList[i].find(rules[k].str1, firstPos+1)) != string::npos) {\n                string tmpStr = strList[i];\n                tmpStr.replace(firstPos, rules[k].str1.size(), rules[k].str2);\n                int m = 0;\n                if (tmpStr.size() > maxSize) {\n                    if (count == 1000) {\n                        return 0;\n                    }\n                    maxSize = tmpStr.size();\n                    strList.push_back(tmpStr);\n                    count++;\n                    continue;\n                }\n                for (m = 0; m < strList.size(); m++) {\n                    if (strList[m] == tmpStr) {\n                        break;\n                    }\n                }\n                if (m == strList.size()) {\n                    if (count == 1000) {\n                        return 0;\n                    }\n                    strList.push_back(tmpStr);\n                    count++;\n                }\n            }\n        }\n    }\n\n    return i;\n}'),(433,'#include <stdio.h>  \r\n#include <string.h>  \r\n  \r\nint main()  \r\n{  \r\n    /*input*/  \r\n    char add1[11];  \r\n    char add2[11];  \r\n    while( scanf(\"%s%s\",add1,add2)==2 )  \r\n    {  \r\n        /*end of the input*/  \r\n        if(!strcmp(add1,\"0\") && !strcmp(add2,\"0\"))  \r\n        {   break;  }  \r\n  \r\n        /*calculate*/  \r\n        int carryCount = 0;  \r\n        int carry = 0;  \r\n        int i = strlen(add1)-1;  \r\n        int j = strlen(add2)-1;  \r\n        while(i!=-1 && j!=-1)  \r\n        {  \r\n            int temp = add1[i--]-\'0\'+  \r\n                       add2[j--]-\'0\'+   \r\n                       carry;  \r\n            if( temp>9 )  \r\n            {     \r\n                carry = 1;  \r\n                carryCount++;  \r\n            }  \r\n            else  \r\n            {   carry =0;   }  \r\n        }  \r\n        /*add1仍有元素没处理*/  \r\n        while(i!=-1 && carry!=0)  \r\n        {  \r\n            int temp = add1[i--]-\'0\'+ carry;  \r\n            if( temp > 9)  \r\n            {  \r\n                carry = 1;  \r\n                carryCount++;  \r\n            }  \r\n            else  \r\n            {   carry =0;  \r\n                break;  \r\n            }  \r\n        }  \r\n        /*add2仍有元素没处理*/  \r\n        while(j!=-1 && carry!=0)  \r\n        {     \r\n            int temp = add2[j--]-\'0\'+carry;  \r\n            if( temp > 9)  \r\n            {  \r\n                carry =1;  \r\n                carryCount++;  \r\n            }  \r\n            else  \r\n            {  \r\n                carry =0;  \r\n                break;  \r\n            }         \r\n        }  \r\n  \r\n                /*output*/  \r\n        if(carryCount ==0)  \r\n            printf(\"No carry operation.\\n\");  \r\n        else if(carryCount ==1)  \r\n            printf(\"%d carry operation.\\n\",carryCount);  \r\n        else  \r\n            printf(\"%d carry operations.\\n\",carryCount);  \r\n    }  \r\n  \r\n    return 0;  \r\n}  \r\n'),(434,'#include <stdio.h>\n\nint a,b;\n\nint i,j,k,carry,carries;\n\nmain(){\n   while (2 == scanf(\"%d%d\",&a,&b)){\n      if (a == 0 && b == 0) return;\n      carries = carry = 0;\n      for (i=9;i>=0;i--) {\n        carry = a%10+b%10+carry > 9;\n        carries += carry;\n        a /= 10; \n        b /= 10;\n      }\n      if (carries == 0) printf(\"No carry operation.\\n\");\n      else if (carries == 1) printf(\"1 carry operation.\\n\");\n      else printf(\"%d carry operations.\\n\",carries);\n   }\n}\n'),(435,'#include <stdio.h>\n\nint merits,demerits,points,lastoff,nextoff;\n\nmain(){\n   scanf(\"%d\",&lastoff);\n   dump();\n   for(;;){\n      nextoff = 99999999;\n      scanf(\"%d%d\",&nextoff,&points);\n      while ((demerits && lastoff+10000 <= nextoff) ||\n             (!demerits && merits < 5  && lastoff+20000 <= nextoff)){\n         if (demerits) {\n            if (demerits > 2) demerits /=2; else demerits = 0;\n            lastoff += 10000;\n         } else {\n            merits++;\n            lastoff += 20000;\n         }\n         dump();\n      }\n      if (nextoff == 99999999) break;\n      lastoff = nextoff;\n      if (merits*2 <= points) {\n         demerits += (points - merits*2);\n         merits = 0;\n      } else {\n         merits -= ((points+1)/2);\n      }\n      dump();\n   }\n}\n\ndump(){\n   printf(\"%04d-%02d-%02d \",lastoff/10000,lastoff/100%100,lastoff%100);\n   if (merits) printf(\"%d merit point(s).\\n\",merits);\n   else if (demerits) printf(\"%d demerit point(s).\\n\",demerits);\n   else printf(\"No merit or demerit points.\\n\");\n}\n'),(436,'#include <stdio.h>\n\nint merits,demerits,points,lastoff,nextoff;\n\nmain(){\n   scanf(\"%d\",&lastoff);\n   dump();\n   for(;;){\n      nextoff = 99999999;\n      scanf(\"%d%d\",&nextoff,&points);\n      while ((demerits && lastoff+10000 <= nextoff) ||\n             (!demerits && merits < 5  && lastoff+20000 <= nextoff)){\n         if (demerits) {\n            if (demerits > 2) demerits /=2; else demerits = 0;\n            lastoff += 10000;\n         } else {\n            merits++;\n            lastoff += 20000;\n         }\n         dump();\n      }\n      if (nextoff == 99999999) break;\n      lastoff = nextoff;\n      if (merits*2 <= points) {\n         demerits += (points - merits*2);\n         merits = 0;\n      } else {\n         merits -= ((points+1)/2);\n      }\n      dump();\n   }\n}\n\ndump(){\n   printf(\"%04d-%02d-%02d \",lastoff/10000,lastoff/100%100,lastoff%100);\n   if (merits) printf(\"%d merit point(s).\\n\",merits);\n   else if (demerits) printf(\"%d demerit point(s).\\n\",demerits);\n   else printf(\"No merit or demerit points.\\n\");\n}\n'),(437,'#include <stdio.h> \r\n#include <stdlib.h> \r\n  \r\n#define dup xdup \r\n  \r\nstruct s { \r\n   int i; \r\n   char *s; \r\n}; \r\n  \r\nstruct s wd[50000], subs[400000], ins[400000]; \r\nint nw, ns, ni; \r\n  \r\nint d[50000], prev[50000]; \r\n  \r\nchar buf[20]; \r\n  \r\ncmp(struct s *a, struct s *b){ \r\n   if (strcmp(a->s,b->s) > 0) return 1; \r\n   if (strcmp(a->s,b->s) < 0) return -1; \r\n   return a->i - b->i; \r\n} \r\n  \r\nstruct s dup(int i, char *s){ \r\n   struct s t; \r\n   t.s = (char *) malloc(strlen(s)+1); \r\n   strcpy(t.s,s); \r\n   t.i = i; \r\n   return t; \r\n} \r\n  \r\nstruct s sub(int i, char *s, int j){ \r\n   struct s t; \r\n   t.s = (char *) malloc(strlen(s)+1); \r\n   strcpy(t.s,s); \r\n   t.s[j] = \'*\'; \r\n   t.i = i; \r\n   return t; \r\n} \r\n  \r\nstruct s in(int i, char *s, int j){ \r\n   struct s t; \r\n   t.s = (char *) malloc(strlen(s)+2); \r\n   strncpy(t.s,s,j); \r\n   t.s[j] = \'*\'; \r\n   strcpy(t.s+j+1,s+j); \r\n   t.i = i; \r\n   return t; \r\n} \r\n  \r\nlook(int from, char *s, struct s *t){ \r\n   int i,j,k,hi,lo,mid; \r\n   hi = (t==subs?ns:ni)-1; \r\n   lo = 0; \r\n   while (hi >= lo) { \r\n      mid = (hi+lo)/2; \r\n      i = strcmp(s,t[mid].s); \r\n      if (i > 0) lo = mid+1; \r\n      else if (i < 0) hi = mid-1; \r\n      else if (from >= t[mid].i) lo = mid+1; \r\n      else hi = mid-1; \r\n   }  \r\n   for (i=lo;!strcmp(s,t[i].s);i++) { \r\n      0&&printf (\"found %s (%s) from %s\\n\", t[i].s, wd[t[i].i].s, wd[from].s); \r\n      if (d[from]+1 > d[t[i].i]){ \r\n         d[t[i].i] = d[from]+1; \r\n         prev[t[i].i] = from; \r\n      } \r\n   } \r\n} \r\n  \r\nmain(){ \r\n   int i,j,k; \r\n   for (nw=0;gets(buf);nw++){ \r\n      wd[nw] = dup(nw,buf); \r\n      for (i=0;i<strlen(buf);i++) subs[ns++] = sub(nw,buf,i); \r\n      for (i=0;i<=strlen(buf);i++) ins[ni++] = in(nw,buf,i); \r\n      subs[ns].s = ins[ni].s = \"\"; \r\n   } \r\n   qsort(subs,ns,sizeof(struct s),cmp); \r\n   qsort(ins,ni,sizeof(struct s),cmp); \r\n  \r\n   for (i=0;i<nw;i++){ \r\n      for (j=0;j<strlen(wd[i].s);j++) look(i,sub(i,wd[i].s,j).s,subs); \r\n      for (j=0;j<strlen(wd[i].s);j++) look(i,sub(i,wd[i].s,j).s,ins); \r\n      for (j=0;j<=strlen(wd[i].s);j++) look(i,in(i,wd[i].s,j).s,subs); \r\n   } \r\n  \r\n   for (i=j=0;i<nw;i++) { \r\n      if (d[i] > d[j]) j=i; \r\n   } \r\n  \r\n   printf(\"%d\\n\",d[j]+1); \r\n   0&&dump(j); \r\n} \r\n  \r\ndump(int i){ \r\n   if (d[i] > 0) dump(prev[i]); \r\n   printf(\"%s\\n\",wd[i].s); \r\n}'),(438,'#include <iostream>\r\n#include <string>\r\n#include <map>\r\nusing namespace std;\r\n#define maxn 25000\r\n#define maxlength 16\r\n#define init_length 1\r\nmap < string, int > dict[maxlength + 1];\r\nint steps[maxn];\r\nint exist(int index, string &temp, int step)\r\n{\r\n	map < string, int >::iterator it;\r\n	it = dict[index].find(temp);\r\n	if (it != dict[index].end())\r\n		if ((steps[(*it).second] + 1) > step)\r\n			step = steps[(*it).second] + 1;\r\n	return step;\r\n}\r\nint main(int ac, char *av[])\r\n{\r\n	string line, temp;\r\n	int current = 0;\r\n	int maximum = 0;\r\n	\r\n	for (int c = 0; c < maxn; c++)\r\n		steps[c] = init_length;\r\n	while (cin >> line)\r\n	{\r\n		int index = line.length() - 1;\r\n		int step = 1;\r\n	\r\n		if (index > 0)\r\n		{\r\n			for (int i = 0; i <= index; i++)\r\n			{\r\n				temp = line;\r\n				if (i == index || temp[i] >= temp[i + 1])\r\n				{\r\n					temp.erase(temp.begin() + i);\r\n					step = exist(index - 1, temp, step);\r\n				}\r\n				temp = line;\r\n				while (temp[i] > \'a\')\r\n				{\r\n					temp[i]--;\r\n					step = exist(index, temp, step);\r\n				}\r\n				temp = line;\r\n				temp.insert(temp.begin() + i, line[i]);\r\n				while (temp[i] > \'a\')\r\n				{\r\n					temp[i]--;\r\n					step = exist(index + 1, temp, step);\r\n				}\r\n			}\r\n		}\r\n		else\r\n		{\r\n			temp = line;\r\n			while (temp[0] > \'a\')\r\n			{\r\n				temp[0]--;\r\n				step = exist(index, temp, step);\r\n			}\r\n		}\r\n	\r\n		if (step > maximum)\r\n			maximum = step;\r\n		\r\n		steps[current] = step;\r\n		dict[index].insert(make_pair < string, int >(line, current));\r\n		current++;\r\n	}\r\n	cout << maximum << endl;\r\n	return 0;\r\n}'),(439,'/*  Solution for \"bridge\" problem, a generalization of a problem\n    generally believed to be a Microsoft intelligence test.\n*/\n\n/*  Algorithm\n\n    Observation 1:  somebody has to get the flashlight back after every\n                    forward trip.  This should obviously be the fastest\n                    person on the far shore.\n\n    Observation 2:  in the general case, we have 4 or more people, the\n                    flashlight is on the starting side. \n                   \n                    Consider the two slowest people.\n                    there are 2 sensible strategies; we pick the fastest:\n\n                    1. we can send each with the fastest person, who returns\n                    with the flashlight.  this takes 2a+x+y time where a is\n                    the fastest and x and y are the two slowest\n\n                    2. we can send the fastest & 2nd fastest person, have\n                    the fastest return with the flashlight, send the \n                    slowpokes together, have the 2nd fastest return with\n                    the flashlight.  This takes a+2b+y where a is fastest,\n                    b second fastest, and y slowest\n\n                    BUT WAIT, you say.  What if strategy 1 is better than\n                    2 for x and y but perhaps x or y could have been paired\n                    with somebody else.  We already know that\n\n                        2a+x+y <= a+2b+y\n                             x <= 2b - a\n\n                    Now if we had a different x\' and y\', it would be\n                    the case that x\' <= x and y\' <= y so\n\n                             x\' <= 2b - a\n\n                    so for any other pair 1 will be the best strategy.\n\n                    BUT WAIT, you say again.  What if strategy 2 is better\n                    than strategy 1, but prevents strategy 2 from being used\n                    later, which would have been even better.\n\n                    Let a,b be the 2 fastest and w,x,y be the slowest.\n                    If we do x,y together we (may) force w to be done alone.\n\n                      x,y together:  a+2b+y\n                      w alone:       a+w\n                      total:         2a+2b+w+y\n\n                    If we do y alone, then w,x together.\n\n                      y alone:       a+y\n                      w,x together:  a+2b+x\n                      total:         2a+2b+x+y\n\n                    Since x >= w, this is worse so there\'s no point in\n                    deferring the pairing.  \n\n\n    Observation 3:  The end game.  If there are 3 people left, the fastest\n                    shuttles them across.  If there are 2 people left,\n                    they go together.\n\n    Observation 4:  One person alone is a special case.  Happens only if\n                    this person started alone.\n\n*/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint i,j,k,n;\n\nint t[1000];\n\nchar cross[2000][16];\nint nc,tot;\n\ncompar(int **a, int **b){\n   return *a - *b;\n}\n\nmain(){\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) scanf(\"%d\",&t[i]);\n\n   qsort(t,n,sizeof(int),compar);\n\n   for (i=n-1;i>=3 && 2*t[1] < t[0]+t[i-1];i-=2){\n      sprintf(cross[nc++],\"%d %d\\n\",t[0],t[1]);\n      sprintf(cross[nc++],\"%d\\n\",t[0]);\n      sprintf(cross[nc++],\"%d %d\\n\",t[i-1],t[i]);\n      sprintf(cross[nc++],\"%d\\n\",t[1]);\n      tot = tot + t[0]+2*t[1]+t[i];\n   }\n   for (;i>=2;i--){\n      sprintf(cross[nc++],\"%d %d\\n\",t[0],t[i]);\n      sprintf(cross[nc++],\"%d\\n\",t[0]);\n      tot = tot + t[0] + t[i];\n   }\n   if (i==1) {\n      sprintf(cross[nc++],\"%d %d\\n\",t[0],t[1]);\n      tot = tot + t[1];\n   }else{\n      sprintf(cross[nc++],\"%d\\n\",t[0]);\n      tot = tot + t[0];\n   }\n   printf(\"%d\\n\",tot);\n   for (i=0;i<nc;i++) printf(\"%s\",cross[i]);\n}\n'),(440,'/*  Solution for \"bridge\" problem, a generalization of a problem\n    generally believed to be a Microsoft intelligence test.\n*/\n\n/*  Algorithm\n\n    Observation 1:  somebody has to get the flashlight back after every\n                    forward trip.  This should obviously be the fastest\n                    person on the far shore.\n\n    Observation 2:  in the general case, we have 4 or more people, the\n                    flashlight is on the starting side. \n                   \n                    Consider the two slowest people.\n                    there are 2 sensible strategies; we pick the fastest:\n\n                    1. we can send each with the fastest person, who returns\n                    with the flashlight.  this takes 2a+x+y time where a is\n                    the fastest and x and y are the two slowest\n\n                    2. we can send the fastest & 2nd fastest person, have\n                    the fastest return with the flashlight, send the \n                    slowpokes together, have the 2nd fastest return with\n                    the flashlight.  This takes a+2b+y where a is fastest,\n                    b second fastest, and y slowest\n\n                    BUT WAIT, you say.  What if strategy 1 is better than\n                    2 for x and y but perhaps x or y could have been paired\n                    with somebody else.  We already know that\n\n                        2a+x+y <= a+2b+y\n                             x <= 2b - a\n\n                    Now if we had a different x\' and y\', it would be\n                    the case that x\' <= x and y\' <= y so\n\n                             x\' <= 2b - a\n\n                    so for any other pair 1 will be the best strategy.\n\n                    BUT WAIT, you say again.  What if strategy 2 is better\n                    than strategy 1, but prevents strategy 2 from being used\n                    later, which would have been even better.\n\n                    Let a,b be the 2 fastest and w,x,y be the slowest.\n                    If we do x,y together we (may) force w to be done alone.\n\n                      x,y together:  a+2b+y\n                      w alone:       a+w\n                      total:         2a+2b+w+y\n\n                    If we do y alone, then w,x together.\n\n                      y alone:       a+y\n                      w,x together:  a+2b+x\n                      total:         2a+2b+x+y\n\n                    Since x >= w, this is worse so there\'s no point in\n                    deferring the pairing.  \n\n\n    Observation 3:  The end game.  If there are 3 people left, the fastest\n                    shuttles them across.  If there are 2 people left,\n                    they go together.\n\n    Observation 4:  One person alone is a special case.  Happens only if\n                    this person started alone.\n\n*/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint i,j,k,n;\n\nint t[1000];\n\nchar cross[2000][16];\nint nc,tot;\n\ncompar(int **a, int **b){\n   return *a - *b;\n}\n\nmain(){\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) scanf(\"%d\",&t[i]);\n\n   qsort(t,n,sizeof(int),compar);\n\n   for (i=n-1;i>=3 && 2*t[1] < t[0]+t[i-1];i-=2){\n      sprintf(cross[nc++],\"%d %d\\n\",t[0],t[1]);\n      sprintf(cross[nc++],\"%d\\n\",t[0]);\n      sprintf(cross[nc++],\"%d %d\\n\",t[i-1],t[i]);\n      sprintf(cross[nc++],\"%d\\n\",t[1]);\n      tot = tot + t[0]+2*t[1]+t[i];\n   }\n   for (;i>=2;i--){\n      sprintf(cross[nc++],\"%d %d\\n\",t[0],t[i]);\n      sprintf(cross[nc++],\"%d\\n\",t[0]);\n      tot = tot + t[0] + t[i];\n   }\n   if (i==1) {\n      sprintf(cross[nc++],\"%d %d\\n\",t[0],t[1]);\n      tot = tot + t[1];\n   }else{\n      sprintf(cross[nc++],\"%d\\n\",t[0]);\n      tot = tot + t[0];\n   }\n   printf(\"%d\\n\",tot);\n   for (i=0;i<nc;i++) printf(\"%s\",cross[i]);\n}\n'),(441,'#include <stdio.h>\n\nstruct e {\n   long x,y,x1,y1;\n};\n\nlong x[101], y[101];\n\nstruct e up[101], dn[101];\nint n, nup, ndn;\nlong top,top1,top2,bot,bot1,bot2;\nlong long area;\n\ncmp (struct e *a, struct e *b){\n   if (b->y > a->y) return 1;\n   if (b->y < a->y) return -1;\n   return b->y1 - a->y1;\n}\n\nmain(){\n   int i,j,k;\n   for (n=0;2 == scanf(\"%d%d\",&x[n],&y[n]);n++);\n   x[n] = x[0]; y[n] = y[0];\n   for (i=0;i<n;i++) {\n      if (x[i] < x[i+1]) {\n         if (y[i] < y[i+1]) {\n            up[nup].x = x[i];\n            up[nup].y = y[i];\n            up[nup].x1 = x[i+1];\n            up[nup++].y1 = y[i+1];\n         }else {\n            dn[ndn].x = x[i];\n            dn[ndn].y = y[i];\n            dn[ndn].x1 = x[i+1];\n            dn[ndn++].y1 = y[i+1];\n         }\n      }else if (x[i+1] < x[i]) {\n         if (y[i+1] < y[i]) {\n            up[nup].x = x[i+1];\n            up[nup].y = y[i+1];\n            up[nup].x1 = x[i];\n            up[nup++].y1 = y[i];\n         }else {\n            dn[ndn].x = x[i+1];\n            dn[ndn].y = y[i+1];\n            dn[ndn].x1 = x[i];\n            dn[ndn++].y1 = y[i];\n         }\n      }\n   }\n   qsort(up,nup,sizeof(struct e),cmp);\n   qsort(dn,ndn,sizeof(struct e),cmp);\n\n   up[nup].x = 0;\n   up[nup].y = -1;\n   up[nup].x1 = 1000000;\n   up[nup++].y1 = -1;\n\n   dn[ndn].x = 0;\n   dn[ndn].y = -1;\n   dn[ndn].x1 = 1000000;\n   dn[ndn++].y1 = -1;\n\n   for (i=0;i<1000000;i++) {\n      for (j=0;up[j].x > i || up[j].x1 <= i;j++);\n      for (k=0;dn[k].x > i || dn[k].x1 <= i;k++);\n      while(1){\n         bot1 = up[j].y+((long long)i-up[j].x)*(up[j].y1-up[j].y)/(up[j].x1-up[j].x);\n         bot2 = dn[k].y+((long long)(i+1-dn[k].x)*(dn[k].y1-dn[k].y)-(dn[k].x1-dn[k].x)+1)/(dn[k].x1-dn[k].x);\n         if (bot1 > bot2) {\n            bot = bot1;\n            for (j++;up[j].x > i || up[j].x1 <= i;j++);\n         }else if (bot2 > bot1){\n            bot = bot2;\n            for (k++;dn[k].x > i || dn[k].x1 <= i;k++);\n         }else break;\n            \n         top1 = up[j].y+((long long)(i+1-up[j].x)*(up[j].y1-up[j].y)+(up[j].x1-up[j].x)-1)/(up[j].x1-up[j].x);\n         top2 = dn[k].y+((long long)i-dn[k].x)*(dn[k].y1-dn[k].y)/(dn[k].x1-dn[k].x);\n         if (top1 > top2) {\n            top = top1;\n            for (j++;up[j].x > i || up[j].x1 <= i;j++);\n         }else if (k < ndn && top2 > top1){\n            top = top2;\n            for (k++;dn[k].x > i || dn[k].x1 <= i;k++);\n         }else {\n             fprintf(stderr,\"oops!\\n;\"); *(char *)0 = 1;\n         }\n         if (bot > top) area = area + bot - top;\n      }\n   }\n   printf(\"%lld\\n\",area);\n}\n'),(442,'#include <stdio.h>\n\nstruct e {\n   long x,y,x1,y1;\n};\n\nlong x[101], y[101];\n\nstruct e up[101], dn[101];\nint n, nup, ndn;\nlong top,top1,top2,bot,bot1,bot2;\nlong long area;\n\ncmp (struct e *a, struct e *b){\n   if (b->y > a->y) return 1;\n   if (b->y < a->y) return -1;\n   return b->y1 - a->y1;\n}\n\nmain(){\n   int i,j,k;\n   for (n=0;2 == scanf(\"%d%d\",&x[n],&y[n]);n++);\n   x[n] = x[0]; y[n] = y[0];\n   for (i=0;i<n;i++) {\n      if (x[i] < x[i+1]) {\n         if (y[i] < y[i+1]) {\n            up[nup].x = x[i];\n            up[nup].y = y[i];\n            up[nup].x1 = x[i+1];\n            up[nup++].y1 = y[i+1];\n         }else {\n            dn[ndn].x = x[i];\n            dn[ndn].y = y[i];\n            dn[ndn].x1 = x[i+1];\n            dn[ndn++].y1 = y[i+1];\n         }\n      }else if (x[i+1] < x[i]) {\n         if (y[i+1] < y[i]) {\n            up[nup].x = x[i+1];\n            up[nup].y = y[i+1];\n            up[nup].x1 = x[i];\n            up[nup++].y1 = y[i];\n         }else {\n            dn[ndn].x = x[i+1];\n            dn[ndn].y = y[i+1];\n            dn[ndn].x1 = x[i];\n            dn[ndn++].y1 = y[i];\n         }\n      }\n   }\n   qsort(up,nup,sizeof(struct e),cmp);\n   qsort(dn,ndn,sizeof(struct e),cmp);\n\n   up[nup].x = 0;\n   up[nup].y = -1;\n   up[nup].x1 = 1000000;\n   up[nup++].y1 = -1;\n\n   dn[ndn].x = 0;\n   dn[ndn].y = -1;\n   dn[ndn].x1 = 1000000;\n   dn[ndn++].y1 = -1;\n\n   for (i=0;i<1000000;i++) {\n      for (j=0;up[j].x > i || up[j].x1 <= i;j++);\n      for (k=0;dn[k].x > i || dn[k].x1 <= i;k++);\n      while(1){\n         bot1 = up[j].y+((long long)i-up[j].x)*(up[j].y1-up[j].y)/(up[j].x1-up[j].x);\n         bot2 = dn[k].y+((long long)(i+1-dn[k].x)*(dn[k].y1-dn[k].y)-(dn[k].x1-dn[k].x)+1)/(dn[k].x1-dn[k].x);\n         if (bot1 > bot2) {\n            bot = bot1;\n            for (j++;up[j].x > i || up[j].x1 <= i;j++);\n         }else if (bot2 > bot1){\n            bot = bot2;\n            for (k++;dn[k].x > i || dn[k].x1 <= i;k++);\n         }else break;\n            \n         top1 = up[j].y+((long long)(i+1-up[j].x)*(up[j].y1-up[j].y)+(up[j].x1-up[j].x)-1)/(up[j].x1-up[j].x);\n         top2 = dn[k].y+((long long)i-dn[k].x)*(dn[k].y1-dn[k].y)/(dn[k].x1-dn[k].x);\n         if (top1 > top2) {\n            top = top1;\n            for (j++;up[j].x > i || up[j].x1 <= i;j++);\n         }else if (k < ndn && top2 > top1){\n            top = top2;\n            for (k++;dn[k].x > i || dn[k].x1 <= i;k++);\n         }else {\n             fprintf(stderr,\"oops!\\n;\"); *(char *)0 = 1;\n         }\n         if (bot > top) area = area + bot - top;\n      }\n   }\n   printf(\"%lld\\n\",area);\n}\n'),(443,'#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n#include <strings.h> \r\n    \r\n#define MAX 3000 \r\nint table[MAX]; \r\nint jolly(int seq[], int n) \r\n{ \r\n  int i; \r\n  bzero(table, MAX*sizeof(int)); \r\n  for (i = 0; i < n - 1; ++i) { \r\n    int d = abs(seq[i] - seq[i+1]); \r\n    if (d > n - 1 || table[d]) \r\n      return 0; \r\n    else\r\n      table[d] = 1; \r\n  } \r\n  return 1; \r\n} \r\n               \r\nint main()\r\n{ \r\n#ifndef ONLINE_JUDGE \r\n  char in[256]; \r\n  char out[256]; \r\n  strcpy(in, argv[0]); \r\n  strcat(in, \".in\"); \r\n  freopen(in, \"r\", stdin); \r\n  strcpy(out, argv[0]); \r\n  strcat(out, \".out\"); \r\n  freopen(out, \"w\", stdout); \r\n#endif \r\n  char *answer[] = { \r\n    \"Not jolly\", \r\n    \"Jolly\", \r\n  }; \r\n  int i, n; \r\n  int seq[MAX]; \r\n  while (scanf(\"%d\", &n) != EOF) { \r\n    for (i = 0; i < n; ++i) \r\n      scanf(\"%d\", &seq[i]); \r\n    puts(answer[jolly(seq, i)]); \r\n  }   \r\n  return 0; \r\n}'),(444,'#include <stdio.h>\n#include <stdlib.h>\n\nchar in[5000];\nint i,j,k,n,next,prev,jolly;\n\nmain(){\n   while (1 == scanf(\"%d\",&n)){\n      jolly = 1;\n      for (i=1;i<n;i++) in[i] = 0;\n      scanf(\"%d\",&prev);\n      for (i=1;i<n;i++) {\n         scanf(\"%d\",&next);\n         j = abs(next-prev);\n         if (j < 1 || j >= n || in[j]++) jolly = 0;\n         prev = next;\n      }\n      if (jolly) printf(\"Jolly\\n\");else printf(\"Not jolly\\n\");\n   }\n}\n'),(445,'#include <iostream> \r\n#include <cstdio> \r\n#include <cstdlib> \r\n#include <algorithm> \r\nusing namespace std; \r\ninline int ABS(int a) \r\n{ \r\n    if(a > 0) \r\n        return a; \r\n    return -1*a; \r\n} \r\nconst int Tsize=2500; \r\nconst int maxsize=55; \r\nint a[maxsize],b[maxsize]; \r\nvoid change(int i,int j) \r\n{ \r\n    int tmp=a[i]; \r\n    a[i]=b[j]; \r\n    b[j]=tmp; \r\n} \r\nint main() \r\n{ \r\n    int sa,sb,an,bn,n; \r\n    while(scanf(\"%d\",&n)!=EOF) \r\n    { \r\n        an=n/2; \r\n        bn=n-an; \r\n        sa=sb=0; \r\n        for(int i=0;i<an;i++) \r\n        { \r\n            scanf(\"%d\",&a[i]); \r\n            sa+=a[i]; \r\n        } \r\n        a[an]=0,an++; \r\n        for(int i=0;i<bn;i++) \r\n        { \r\n            scanf(\"%d\",&b[i]); \r\n            sb+=b[i]; \r\n        } \r\n        b[bn]=0,bn++; \r\n        int t=Tsize,i1,j1,i2,j2,d1,d2; \r\n        while(t--) \r\n        { \r\n            i1=i2=rand()%an; \r\n            j1=j2=rand()%bn; \r\n            while(j1==j2) j2=rand()%bn; \r\n            while(i1==i2) i2=rand()%an; \r\n            if(((a[i1]==0)+(a[i2]==0)+(b[j1]==0)+(b[j2]==0))%2!=0) continue; \r\n            d1=ABS(sa-sb); \r\n            d2=ABS(sa-sb-(a[i1]+a[i2]-b[j1]-b[j2])*2); \r\n            if(d1 > d2) \r\n            { \r\n                sa-=(a[i1]+a[i2]-b[j1]-b[j2]); \r\n                sb-=-(a[i1]+a[i2]-b[j1]-b[j2]); \r\n                change(i1,j1); \r\n                change(i2,j2); \r\n            } \r\n        } \r\n        if(sb <= sa) \r\n            printf(\"%d %d\\n\",sb,sa); \r\n        else\r\n            printf(\"%d %d\\n\",sa,sb); \r\n    } \r\n    return 0; \r\n}'),(446,'#include <stdio.h>\n#include <stdlib.h>\n\nint people[1000];\nint i,j,k,n,tot,best;\nchar cando[101][50000];\n\nmain(){\n   scanf(\"%d\",&n);\n   for (i=0;i<n;i++) {\n      scanf(\"%d\",&people[i]);\n      tot += people[i];\n   }\n\n   cando[0][0] = 1;\n   for (i=0;i<n;i++) {  /* try every person */\n      for (j=n/2;j>=0;j--) {\n         for (k=45000;k>=0;k--) {\n            if (cando[j][k]) cando[j+1][k+people[i]]=1;\n         }\n      }\n   }\n   for (i=0;i<=45000;i++) {\n      if (!cando[n/2][i]) continue;\n      if (abs(tot-2*i) < abs(tot-2*best)) best = i;\n   }\n   if (best > tot-best) best = tot-best;\n   printf(\"%d %d\\n\",best,tot-best);\n}\n'),(447,'#include <stdio.h> \r\n  \r\nint ram[1000]; \r\nint r[10]; \r\nint i,ip,a,b,c; \r\n  \r\nmain(){ \r\n   while (1 == scanf(\"%d\",&ram[i++])){}  \r\n   for (i=1;;i++){ \r\n      a = ram[ip]/100; \r\n      b = ram[ip]/10%10; \r\n      c = ram[ip]%10; \r\n      ip++; \r\n      if (a == 1) break; \r\n      if (a == 2) r[b] = c; \r\n      else if (a == 3) r[b] = (r[b]+c)%1000; \r\n      else if (a == 4) r[b] = (r[b]*c)%1000; \r\n      else if (a == 5) r[b] = r[c]; \r\n      else if (a == 6) r[b] = (r[b]+r[c])%1000; \r\n      else if (a == 7) r[b] = (r[b]*r[c])%1000; \r\n      else if (a == 8) r[b] = ram[r[c]]; \r\n      else if (a == 9) ram[r[c]] = r[b]; \r\n      else if (a == 0 && r[c] !=0) ip = r[b]; \r\n   } \r\n   printf(\"%d\\n\",i); \r\n} '),(448,'#include <stdio.h>\n\nint ram[1000];\nint r[10];\nint i,ip,a,b,c;\n\nmain(){\n   while (1 == scanf(\"%d\",&ram[i++])){} \n   for (i=1;;i++){\n      a = ram[ip]/100;\n      b = ram[ip]/10%10;\n      c = ram[ip]%10;\n      ip++;\n      if (a == 1) break;\n      if (a == 2) r[b] = c;\n      else if (a == 3) r[b] = (r[b]+c)%1000;\n      else if (a == 4) r[b] = (r[b]*c)%1000;\n      else if (a == 5) r[b] = r[c];\n      else if (a == 6) r[b] = (r[b]+r[c])%1000;\n      else if (a == 7) r[b] = (r[b]*r[c])%1000;\n      else if (a == 8) r[b] = ram[r[c]];\n      else if (a == 9) ram[r[c]] = r[b];\n      else if (a == 0 && r[c] !=0) ip = r[b];\n   }\n   printf(\"%d\\n\",i);\n}\n'),(449,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    int i,ok;\r\n    char a[1000];\r\n    while(gets(a))\r\n    {   ok=0;\r\n        for(i=0;i<strlen(a);i++)\r\n        {if((a[i]==\'s\'||a[i]==\'S\')&&(a[i+1]==\'a\'||a[i+1]==\'A\')&&(a[i+2]==\'L\'||a[i+2]==\'l\')&&(a[i+3]==\'T\'||a[i+3]==\'t\'))\r\n        {ok++;\r\n        break;}\r\n        else\r\n        ok=0;}\r\n       if(ok!=0)\r\n   puts(a);\r\n    }\r\n    return 0;\r\n}'),(450,'#include<stdio.h>\r\n#include<string.h>\r\n#define max 1024\r\nint main()\r\n{\r\n	char str[max];\r\n	int i;\r\n	while(gets(str))\r\n	{\r\n		for(i=0;i<(int)strlen(str);i++)\r\n		{\r\n			if((str[i]==\'s\'||str[i]==\'S\')&&(str[i+1]==\'a\'||str[i+1]==\'A\')&&(str[i+2]==\'l\'||str[i+2]==\'L\')&&(str[i+3]==\'t\'||str[i+3]==\'T\'))\r\n				puts(str);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n'),(451,'#include<stdio.h> \r\n#include<string.h> \r\n#define max 1024 \r\nint main() \r\n{ \r\n    char str[max],result[max]; \r\n    int i,j; \r\n    while(gets(str)) \r\n    { \r\n        for(j=i=0;i<(int)strlen(str);j++,i++) \r\n        { \r\n              \r\n            if((str[i]==\'s\'||str[i]==\'S\')&&(str[i+1]==\'a\'||str[i+1]==\'A\')&&(str[i+2]==\'l\'||str[i+2]==\'L\')&&(str[i+3]==\'t\'||str[i+3]==\'T\')) \r\n            { \r\n                result[j]=\'s\'; \r\n                result[++j]=\'o\'; \r\n                result[++j]=\'y\'; \r\n                result[++j]=\' \'; \r\n                result[++j]=\'s\'; \r\n                result[++j]=\'a\'; \r\n                result[++j]=\'u\'; \r\n                result[++j]=\'c\'; \r\n                result[++j]=\'e\'; \r\n                i=i+3; \r\n            } \r\n            else\r\n                result[j]=str[i]; \r\n        } \r\n        for(i=0;i<j;i++) \r\n            printf(\"%c\",result[i]); \r\n        printf(\"\\n\"); \r\n    } \r\n    return 0; \r\n}'),(452,'#include<stdio.h>\r\nint main()\r\n{\r\n	char a[1000];\r\n	int i;\r\n	while(gets(a)!=NULL)\r\n	{\r\n		for(i=0;a[i]!=0;i++)\r\n		{\r\n			if((a[i]==\'s\'||a[i]==\'S\')&&(a[i+1]==\'a\'||a[i+1]==\'A\')&&(a[i+2]==\'l\'||a[i+2]==\'L\')&&(a[i+3]==\'t\'||a[i+3]==\'T\'))\r\n			{\r\n				printf(\"soy sauce\");\r\n				i+=3;\r\n			}\r\n			else\r\n			{\r\n				printf(\"%c\",a[i]);\r\n			}\r\n		}\r\n			\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}\r\n		'),(453,'#include<stdio.h>\r\nstruct T\r\n{\r\n	char name[16];\r\n	int w;\r\n	char s;\r\n};\r\ntypedef struct T teacher;\r\n\r\nint max(teacher* a,int len)\r\n{\r\n	int m=0;\r\n	int i;\r\n	for(i=1;i<len;i++)\r\n		if(a[i].w>a[m].w)\r\n			m=i;\r\n	return m;\r\n\r\n}\r\n\r\nvoid mysort(teacher* a,int len)\r\n{\r\n	int i;\r\n	for(i=0;i<5;i++)\r\n	{\r\n		int m=max(a+i,len-i)+i;\r\n		teacher t=a[i];\r\n		a[i]=a[m];\r\n		a[m]=t;\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	teacher  man[100],woman[100];\r\n	int len_man=0,len_woman=0;\r\n	int n,i;\r\n	teacher t;\r\n	scanf(\"%d\",&n);\r\n\r\n	while(n--)\r\n	{\r\n         scanf(\"%s %d %c\",t.name,&t.w,&t.s);\r\n		 if(t.s==\'M\')\r\n		    man[len_man++]=t;\r\n		 else\r\n			 woman[len_woman++]=t;\r\n	}\r\n	mysort(man,len_man);\r\n		mysort(woman,len_woman);\r\n	for(i=0;i<5;i++)\r\n		printf(\"%s\\n\",man[i].name);\r\n	for(i=0;i<5;i++)\r\n		printf(\"%s\\n\",woman[i].name);\r\n	\r\n\r\n}\r\n\r\n            '),(454,'#include<stdio.h>\r\n\r\nstruct n\r\n{\r\n	char name[20];\r\n	int x;\r\n	char y;\r\n};\r\nstruct n a[1000];\r\nvoid  main()\r\n{\r\n	int c,i,j;\r\n	scanf(\"%d\",&c);\r\n	for(i=0;i<c;i++)\r\n	{\r\n		scanf(\"%s %d %c\",a[i].name,&a[i].x,&a[i].y);\r\n	}\r\n	\r\n	for(i=0;i<c;i++)\r\n	{\r\n		for(j=0;j<c-i-1;j++)\r\n			if(a[j+1].x>a[j].x)\r\n			{struct n b;\r\n				b=a[j+1];\r\n				a[j+1]=a[j];\r\n				a[j]=b;\r\n			}\r\n	}\r\n	j=0;\r\n	for(i=0;j<5;i++)\r\n	{\r\n		if(a[i].y==\'M\')\r\n		{printf(\"%s\\n\",a[i].name);\r\n		j++;}\r\n	}\r\n	for(i=0;j<10;i++)\r\n	{\r\n		if(a[i].y==\'F\')\r\n		{printf(\"%s\\n\",a[i].name);\r\n		j++;}\r\n	}\r\n\r\n\r\n\r\n}'),(455,'#include<stdio.h> \r\nint digui(int s) \r\n{ \r\n    if(s==1||s==2) \r\n        return s; \r\n    else\r\n        return digui(s-1)+digui(s-2); \r\n} \r\nint main() \r\n{ \r\n    int n; \r\n    while(scanf(\"%d\",&n)!=EOF) \r\n    { \r\n        if(n<1||n>50) \r\n        break; \r\n        printf(\"%d\\n\",digui(n)); \r\n    } \r\n    return 0; \r\n}'),(456,'#include<stdio.h>\r\n\r\nint main(){\r\n	int n,i,a[40];\r\n\r\n	while(scanf(\"%d\",&n)!=EOF && n!=0){\r\n		a[1]=1;\r\n		a[2]=2;\r\n		for(i=3;i<=n;i++){\r\n			a[i]=a[i-1]+a[i-2];\r\n		}\r\n		printf(\"%d\\n\",a[n]);\r\n	}\r\n}'),(457,'#include<stdio.h> \r\n#include<math.h> \r\nint is_prime(int n) \r\n{ \r\n\r\nint m=sqrt(n); \r\nint i; \r\nfor(i=2;i<=m;++i) \r\n\r\n\r\nif(n%i==0) return 0; \r\n\r\nreturn 1; \r\n} \r\nvoid main() \r\n{ \r\n\r\nint n; \r\nwhile(scanf(\"%d\",&n)!=EOF) \r\n{ \r\n\r\n\r\nint m=n/2; \r\nif(m%2==0) --m; \r\nwhile(1) \r\n{ \r\n\r\n\r\nif(is_prime(m)&&is_prime(n-m)) \r\n\r\n{ \r\nprintf(\"%d %d\\n\",m,n-m); \r\nbreak; \r\n\r\n} \r\nelse m-=2; \r\n} \r\n} \r\n} \r\n'),(458,'#include<stdio.h>\r\nint f(int cai)\r\n{int k=1;\r\n    for(int i=2;i<cai/2;i++)\r\n    {if(cai%i==0)\r\n    k=0;}\r\n\r\n    return k;\r\n}\r\nint main()\r\n{\r\n    int num;\r\n\r\n\r\n    while(scanf(\"%d\",&num)!=EOF)\r\n    {int cai=num/2;\r\n  \r\n\r\n   for(cai;(!f(cai))||(!f(num-cai));cai--);\r\n   printf(\"%d %d\\n\",cai,num-cai);}\r\n\r\n}\r\n'),(459,'typedef struct JY \r\n{ \r\n    double jyl; \r\n    int no; \r\n    int mc; \r\n}J; \r\n#include<stdio.h> \r\nint main() \r\n{ \r\n    double jj; \r\n    J arr[4]; \r\n    int i,j; \r\n    int Mc=1,sum=0; \r\n    while(-1!=scanf(\"%lf\",&jj)) \r\n    { \r\n      for(i=0;i<4;i++) \r\n      { \r\n          int z,j; \r\n        scanf(\"%d%d\",&z,&j); \r\n        arr[i].jyl=j*1.0/z; \r\n        arr[i].no=i; \r\n      } \r\n      for(i=0;i<3;i++) \r\n          for(j=0;j<3-i;j++) \r\n              if(arr[j+1].jyl<arr[j].jyl) \r\n              { \r\n                  J t=arr[j+1]; \r\n                  arr[j+1]=arr[j]; \r\n                  arr[j]=t; \r\n              } \r\n     for(i=0;i<4;i++) \r\n     { \r\n         if(i==0|| \r\n             arr[i].jyl-arr[i-1].jyl>0.0001) \r\n             arr[i].mc=Mc; \r\n         else\r\n             arr[i].mc=arr[i-1].mc; \r\n         sum+=arr[i].mc; \r\n         Mc++; \r\n     } \r\n     for(i=0;i<4;i++) \r\n     { \r\n         for(j=0;j<4;j++) \r\n             if(arr[j].no==i) break; \r\n         printf(\"%.2lf\\n\",arr[j].mc*jj/sum); \r\n  \r\n     } \r\n         \r\n    } \r\n} \r\n'),(460,'#include<stdio.h>\r\nint main()\r\n{\r\n	double money;\r\n	double n[4],num[4],sum=0;\r\n	int i,j,k;\r\n	scanf(\"%lf\",&money);\r\n	for(i=0;i<4;i++)\r\n		scanf(\"%lf%lf\",&n[i],&num[i]);\r\n	for(i=0;i<4;i++)\r\n		num[i]=num[i]/n[i];\r\n	for(i=0;i<4;i++)\r\n	{\r\n		k=1;\r\n		for(j=0;j<4;j++)\r\n		{\r\n			if(num[i]>num[j]&&i!=j)\r\n				k++;\r\n		}\r\n		n[i]=k;\r\n		sum+=n[i];\r\n	}\r\n	for(i=0;i<4;i++)\r\n		printf(\"%.2lf\\n\",money*(n[i]/sum));\r\n	return 0;\r\n}\r\n\r\n\r\n'),(461,'#include<stdio.h>\r\n#include<math.h>\r\n\r\nint main()\r\n{\r\n  double x1,x2,x3,y1,y2,y3;\r\n  double a,b,c,p;\r\n  scanf(\"%lf%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&x3,&y3);\r\n  a=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n  b=sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));\r\n  c=sqrt((x3-x2)*(x3-x2)+(y3-y2)*(y3-y2));\r\n  p=(a+b+c)/2;\r\n  printf(\"%.4lf\",sqrt(p*(p-a)*(p-b)*(p-c)));\r\nreturn 0;\r\n\r\n}'),(462,'#include <stdio.h>\r\n#include <math.h>\r\n\r\nint main()\r\n{\r\n	double a,b,c,d,e,f;\r\n	while(scanf(\"%lf%lf%lf%lf%lf%lf\",&a,&b,&c,&d,&e,&f)!=EOF)\r\n	{\r\n		printf(\"%.4lf\\n\",fabs((a*d+b*e+c*f-d*e-a*f-b*c)/2));\r\n	}\r\n	return 0;\r\n}'),(463,'#include<stdio.h> \r\n#include<math.h> \r\nint main() \r\n{ \r\n    double num,a,b; \r\n    while(scanf(\"%lf\",&num)!=-1) \r\n    { \r\n        a=b=1; \r\n        while(fabs(num-a/b)>0.00001) \r\n        { \r\n            if(num>a/b) \r\n                a++; \r\n            else if(num<a/b) \r\n                b++; \r\n            else\r\n                break; \r\n        } \r\n        printf(\"%.lf %.lf\\n\",a,b); \r\n    } \r\n    return 0; \r\n}'),(464,'#include<stdio.h>\r\n#include<math.h>\r\nint main(){double num,a,b;while(scanf(\"%lf\",&num)!=-1){a=b=1;while(fabs(num-a/b)>0.00001){if(num>a/b)a++;else if(num<a/b)b++;}printf(\"%.lf %.lf\\n\",a,b);}return 0;}\r\n'),(465,'#include<stdio.h>\r\nint main()\r\n{\r\n	int i,j,n,a[100][100],k=0,b[100],c[100],m,t=0;\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		b[i]=0;\r\n		scanf(\"%d\",&m);\r\n		for(j=0;j<m;j++)\r\n		{\r\n			scanf(\"%d\",&a[i][j]);\r\n			b[i]=b[i]+1;\r\n		}\r\n	}\r\n	for(i=0;i<n;i++)\r\n	{\r\n		c[i]=0;\r\n		for(j=0;j<b[i];j++)\r\n		{\r\n			if(a[i][j]<0||a[i][j]>100)\r\n			{\r\n				c[i]=-1;break;\r\n			}\r\n			else \r\n			{\r\n				if(a[i][j]<60)\r\n				{\r\n					c[i]=c[i]+1;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf(\"%d\\n\",c[i]);\r\n	}\r\n	return 0;\r\n}'),(466,'#include<stdio.h>\r\n#include<math.h>\r\n\r\nvoid f()\r\n{\r\n	int n;int c=0;\r\n	scanf(\"%d\",&n);\r\n	while(n--)\r\n	{\r\n		int i;\r\n		scanf(\"%d\",&i);\r\n		if(i<0||i>100) c=-1;\r\n		if(c!=-1&&i<60)c++;\r\n		}\r\n	printf(\"%d\\n\",c);\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	scanf(\"%d\",&n);\r\n\r\n	while(n--)\r\n	{	f();}\r\n\r\n   return 0;\r\n\r\n}'),(467,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	int m;\r\n	while(scanf(\"%d\",&n)!=EOF)\r\n	{\r\n		while(n--)\r\n		{\r\n			int l=0;\r\n			scanf(\"%d\",&m);\r\n			if( (m%50!=0) || (m<=0) || (m>20000) ){\r\n				printf(\"NO\\n\");\r\n			}\r\n			else{\r\n				l=0;\r\n				while(m>2000){\r\n					if(l==1)printf(\" \");\r\n					if(l==0)l=1;\r\n					printf(\"2000\");\r\n					m=m-2000;\r\n				}\r\n				if(l==0) printf(\"%d\\n\",m);\r\n				else printf(\" %d\\n\",m);\r\n			}\r\n		}\r\n	}\r\n}\r\n'),(468,'#include\"stdio.h\"\r\nint main()\r\n{int n,x;\r\nscanf(\"%d\",&n);\r\nwhile(n)\r\n{scanf(\"%d\",&x);\r\nif(x<0||x%50!=0||x>20000)\r\nprintf(\"NO\\n\"); \r\nelse for(;x>0;x-=2000)\r\n{if(x>2000)\r\nprintf(\"2000 \");\r\nelse printf(\"%d\\n\",x); }\r\nn--;  }\r\n}'),(469,'#include <stdio.h> \r\n\r\nint main() \r\n\r\n{ \r\nint i,j,min1=1000000,min2=100000; \r\nint a[6][6]; \r\nfor(i=0;i<6;i++) \r\n\r\na[i][i]=0; \r\nfor(i=0;i<5;i++) \r\nfor(j=i+1;j<6;j++) \r\nscanf(\"%d\",&a[i][j]); \r\n\r\nfor(i=0;i<5;i++) \r\nfor(j=i+1;j<6;j++) \r\n{ \r\n\r\n\r\nif(a[i][j]<min1) \r\n\r\n{ \r\nmin1=a[i][j]; \r\nmin2=a[0][i]+a[0][j]+a[i][j]; \r\n\r\n} \r\nif(a[i][j]==min1&&a[0][i]+a[0][j]+a[i][j]<min2) \r\nmin2=a[0][i]+a[0][j]+a[i][j]; \r\n\r\n} \r\nprintf(\"%ld\",min2); \r\n\r\n\r\nreturn 0; \r\n} '),(470,'#include<stdio.h>\r\n#include<math.h>\r\n\r\n\r\nint main()\r\n{\r\n	int a[6][6]={0};\r\n	int i,j;\r\n	int min=100000;\r\n	int re=1000;\r\n	for(i=0;i<6;i++)\r\n		for(j=i+1;j<6;j++)\r\n		{\r\n			scanf(\"%d\",&a[i][j]);\r\n			a[j][i]=a[i][j];\r\n			if(a[i][j]<min) min=a[i][j];\r\n		}\r\n	for(i=0;i<6;i++)\r\n		for(j=0;j<6;j++)\r\n	{\r\n			if(a[i][j]==min)\r\n			{\r\n				if(a[0][i]+a[i][j]+a[j][0]<re) re=a[0][i]+a[i][j]+a[j][0];\r\n			}\r\n	}\r\n		printf(\"%d\",re);\r\n\r\n\r\n   return 0;\r\n\r\n}'),(471,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a1,b1,c1;\r\n	int a2,b2,c2;\r\n	double x=0;\r\n	double y=0;\r\n	while(scanf(\"%d%d%d%d%d%d\",&a1,&b1,&c1,&a2,&b2,&c2)!=EOF)\r\n	{\r\n		if(a1*b2-a2*b1==0&&a1*c2-a2*c1==0)\r\n		{\r\n			printf(\"HAHA\\n\");\r\n		}\r\n		else if( a1*b2-a2*b1==0 && a1*c2-a2*c1!=0 )\r\n		{\r\n			printf(\"NO\\n\");\r\n		}\r\n		else{\r\n			x=double(c1*b2-c2*b1)/double(a1*b2-a2*b1);\r\n			if(b1==0){\r\n				y=double(c2-a2*x)/double(b2);\r\n			}\r\n			else{\r\n				y=double(c1-a1*x)/double(b1);\r\n			}\r\n			printf(\"%.4lf %.4lf\\n\",x,y);\r\n		}\r\n	}\r\n}\r\n'),(472,'#include<stdio.h> \r\nint main() \r\n{double a,b,c,d,e,f,x,y,l,m,n; \r\nwhile(scanf(\"%lf %lf %lf %lf %lf %lf\",&a,&b,&c,&d,&e,&f)!=EOF) \r\n{x=(c*e-b*f)/(a*e-b*d); \r\ny=(c*d-a*f)/(b*d-a*e); \r\nl=d/a;m=e/b;n=f/c; \r\nif(l==m) \r\n{ if(m==n) \r\nprintf(\"HAHA\\n\"); \r\nelse printf(\"NO\\n\");} else\r\nprintf(\"%.4lf %.4lf\\n\",x,y);} \r\nreturn 0; \r\n}'),(473,'#include<stdio.h>\r\nint main()\r\n{\r\n	int i,a,b,c,r1,r2,r3;\r\n	while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&r1,&r2,&r3)!=EOF)\r\n	{\r\n		for(i=1;i<1000;i++)\r\n		{\r\n			if((i%a==r1)&&(i%b==r2)&&(i%c)==r3)\r\n			{\r\n				printf(\"%d\\n\",i);\r\n				break;\r\n			}\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}\r\n'),(474,'#include<stdio.h>\r\nint main() \r\n{int a,b,c;\r\nint r1,r2,r3;\r\nwhile(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&r1,&r2,&r3)!=EOF)\r\n{int i = r3;\r\nwhile( 1 )\r\n{if(i%a==r1 && i%b==r2) break;\r\ni += c;}\r\nprintf(\"%d\\n\", i);}\r\n}'),(475,'#include<stdio.h> \r\nint f(int a,int b) \r\n{ \r\n    while(b) \r\n    { \r\n        int t=a; \r\n        a=b; \r\n        b=t%b; \r\n    } \r\n    return a; \r\n} \r\nint g(int a,int b) \r\n{ \r\n    int t=f(a,b); \r\n    return a*b/t; \r\n} \r\nint h(int a,int b,int c) \r\n{ \r\n    return g(g(a,b),c); \r\n} \r\n   \r\nint main() \r\n{ \r\n  int a,b,c; \r\n  int d,e,f; \r\n  while(~scanf(\"%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f)) \r\n  { \r\n  int bc=g(b,c),ac=g(a,c),ab=g(a,b); \r\n  int bc1=bc,ac1=ac,ab1=ab; \r\n  while(bc%a!=d) \r\n      bc+=bc1; \r\n  while(ac%b!=e) \r\n      ac+=ac1; \r\n  while(ab%c!=f) \r\n      ab+=ab1; \r\n  printf(\"%d\\n\",(ab+bc+ac)%h(a,b,c)); \r\n  } \r\n   \r\n   \r\n}'),(476,'#include<stdio.h>\r\nint main()\r\n{\r\n	int x;\r\n	int a,b,c,r1,r2,r3;\r\n	while(scanf(\"%d%d%d%d%d%d\",&a,&b,&c,&r1,&r2,&r3)!=EOF)\r\n	{\r\n		for(x=a+r1;;x+=a)\r\n			if(x%b==r2 && x%c==r3)\r\n			{\r\n				printf(\"%d\\n\",x);\r\n				break;\r\n			}\r\n	}\r\n\r\n	return 0;\r\n}'),(477,'#include<stdio.h>\r\nint main()\r\n{\r\n	int len,i,j=0;\r\n	char a[10000];\r\n	gets(a);\r\n	len=strlen(a);\r\n	for(i=0;i<len;i++)\r\n	{\r\n		if((a[i]>=65&&a[i]<=90)||(a[i]>=97&&a[i]<=122))\r\n		{\r\n			if(a[i+1]<65||(a[i+1]>=91&&a[i+1]<=96)||a[i+1]>122)\r\n			{\r\n				j=j++;\r\n			}\r\n		}\r\n	}\r\n	printf(\"%d\",j);\r\n	return 0;\r\n}'),(478,'#include<stdio.h>\r\nint main()\r\n{\r\nchar a[1000];\r\nint i,mun=0,word=0;\r\nchar c;\r\ngets(a);\r\nfor(i=0;(c=a[i])!=\'\\0\';i++)\r\nif(c<\'A\'||c>\'z\'||c>\'Z\'&&c<\'a\')\r\nword=0;\r\nelse\r\nif(word==0)\r\n{word=1;\r\nmun++;}\r\nprintf(\"%d\\n\",mun);\r\nreturn 0;\r\n}'),(479,'#include<stdio.h>\r\nmain()\r\n{\r\n    int a,b,t,c;\r\n   while(scanf(\"%d%d\",&a,&b)!=EOF)\r\n   {\r\n       if(b>a)\r\n       {t=a;\r\n       a=b;\r\n       b=t;}\r\n       if(a==0&&b==0)\r\n        break;\r\n       while(b!=0)\r\n       {\r\n           t=a%b;\r\n           a=b;\r\n           b=t;\r\n       }\r\n       printf(\"%d\\n\",a);\r\n}\r\n}'),(480,'#include\"stdio.h\"\r\nint f(int a,int b)\r\n{return b?f(b,a%b):a;}\r\n\r\nint main()\r\n{int x,y;\r\nwhile(scanf(\"%d %d\",&x,&y)!=EOF)\r\nprintf(\"%d\\n\",f(x,y));}'),(481,'#include<stdio.h>\r\n \r\nint fn[30][2]=\r\n{220,284,\r\n1184,1210,\r\n2620,2924,\r\n5020,5564,\r\n6232,6368,\r\n10744,10856,\r\n12285,14595,\r\n17296,18416,\r\n63020,76084,\r\n66928,66992,\r\n67095,71145,\r\n69615,87633,\r\n79750,88730,\r\n100485,124155,\r\n122265,139815,\r\n122368,123152,\r\n141664,153176,\r\n142310,168730,\r\n171856,176336,\r\n176272,180848,\r\n185368,203432,\r\n196724,202444,\r\n280540,365084,\r\n308620,389924,\r\n319550,430402,\r\n356408,399592,\r\n437456,455344,\r\n469028,486178};\r\n \r\nint main()\r\n{int n, i, count;\r\n \r\nwhile(scanf(\"%d\",&n)!= EOF)\r\n{\r\nfor(count=0,i=0;i<28;i++)\r\nif(0<=fn[i][0]&&fn[i][1]<=n)\r\n \r\nprintf(\"%d %d\\n\",fn[i][0],fn[i][1]);\r\n} \r\nreturn 0;\r\n} '),(482,'#include<stdio.h>\r\nint main()\r\n{\r\nint z,a,b,c=0,d=0;\r\nscanf(\"%d\",&z);\r\nfor(a=220;a<=z;a++)\r\n{\r\nc=0;\r\nd=0;\r\nfor(b=1;b<a;b++)\r\n{\r\nif(a%b==0)\r\n{\r\nc+=b;\r\n}\r\n}\r\nfor(b=1;b<c;b++)\r\n{\r\nif(c%b==0)\r\n{d+=b;}\r\n}\r\nif(a==d&&c<d)\r\n{printf(\"%d %d\\n\",c,d);}\r\n}\r\nreturn 0;\r\n}\r\n'),(483,'#include<stdio.h>\r\n#include<string.h>\r\n\r\nvoid f(char *s);\r\nmain()\r\n{\r\n	char a[50];\r\n	int i;\r\n\r\n	while(scanf(\"%s\", &a)!=EOF)\r\n	{\r\n		for(i = 0; a[i]!=\'\\0\'; i++)\r\n		{continue;}\r\n		if(i >= 40)\r\n		{\r\n			printf(\"DZ\");\r\n			f(a);\r\n		}\r\n		else\r\n		{\r\n			printf(\"NM\");\r\n			f(a);\r\n		}\r\n	}\r\n}\r\n\r\nvoid f(char *s)\r\n{\r\n	char a[40];\r\n	int i,na=0,n2=0,n3=0,n4=0,n5=0,n6=0,n7=0,n8=0,n9=0,ns=0,nj=0,nq=0,nk=0,nw=0;\r\n	strcpy(a,s);\r\n	for(i=0; a[i]!=0; i=i+2)\r\n	{\r\n		if(a[i+1]==\'W\')\r\n		{\r\n			nw++;\r\n		}\r\n		if(a[i]==\'2\')\r\n		{\r\n			n2++;\r\n		}\r\n		if(a[i]==\'A\')\r\n		{\r\n			na++;\r\n		}\r\n		if(a[i]==\'K\')\r\n		{\r\n			nk++;\r\n		}\r\n		if(a[i]==\'Q\')\r\n		{\r\n			nq++;\r\n		}\r\n		if(a[i]==\'J\')\r\n		{\r\n			nj++;\r\n		}\r\n		if(a[i]==\'S\')\r\n		{\r\n			ns++;\r\n		}\r\n		if(a[i]==\'9\')\r\n		{\r\n			n9++;\r\n		}\r\n		if(a[i]==\'8\')\r\n		{\r\n			n8++;\r\n		}\r\n		if(a[i]==\'7\')\r\n		{\r\n			n7++;\r\n		}\r\n		if(a[i]==\'6\')\r\n		{\r\n			n6++;\r\n		}\r\n		if(a[i]==\'5\')\r\n		{\r\n			n5++;\r\n		}\r\n		if(a[i]==\'4\')\r\n		{\r\n			n4++;\r\n		}\r\n		if(a[i]==\'3\')\r\n		{\r\n			n3++;\r\n		}\r\n		\r\n	}\r\n	if(nw==2)\r\n	{\r\n		printf(\"W\");\r\n	}\r\n	if(n2==4)\r\n	{\r\n		printf(\"2\");\r\n	}\r\n	if(na==4)\r\n	{\r\n		printf(\"A\");\r\n	}\r\n	if(nk==4)\r\n	{\r\n		printf(\"K\");\r\n	}\r\n	if(nq==4)\r\n	{\r\n		printf(\"Q\");\r\n	}\r\n	if(nj==4)\r\n	{\r\n		printf(\"J\");\r\n	}\r\n	if(ns==4)\r\n	{\r\n		printf(\"S\");\r\n	}\r\n	if(n9==4)\r\n	{\r\n		printf(\"9\");\r\n	}\r\n	if(n8==4)\r\n	{\r\n		printf(\"8\");\r\n	}\r\n	if(n7==4)\r\n	{\r\n		printf(\"7\");\r\n	}\r\n	if(n6==4)\r\n	{\r\n		printf(\"6\");\r\n	}\r\n	if(n5==4)\r\n	{\r\n		printf(\"5\");\r\n	}\r\n	if(n4==4)\r\n	{\r\n		printf(\"4\");\r\n	}\r\n	if(n3==4)\r\n	{\r\n		printf(\"3\");\r\n	}\r\n	printf(\"\\n\");\r\n}'),(484,'#include<stdio.h>\r\n#include<string.h>\r\nchar arr[14]={\'W\',\'2\',\'A\',\'K\',\'Q\',\'J\',\'S\',\'9\',\'8\',\'7\',\'6\',\'5\',\'4\',\'3\'};\r\nint f(char c)\r\n{\r\n	int i;\r\n	for(i=0;i<14;i++)\r\n		if(c==arr[i])\r\n			return i;\r\n}\r\n\r\nint main()\r\n{\r\n	\r\n	char a[100];\r\n	while(scanf(\"%s\",a)!=EOF)\r\n	{\r\n		int i;\r\n		int count[14]={0};\r\n        if(strlen(a)==40)\r\n			printf(\"DZ\");\r\n		else\r\n			printf(\"NM\");\r\n        for(i=0;i<strlen(a);i+=2)\r\n		{\r\n			if(a[i]==\'D\'||a[i]==\'X\')\r\n				count[f(\'W\')]++;\r\n			else count[f(a[i])]++;\r\n		}\r\n		if(count[0]==2)printf(\"W\");\r\n		for(i=1;i<14;i++)\r\n			if(count[i]==4) printf(\"%c\",arr[i]);\r\n		printf(\"\\n\");\r\n	}\r\n}'),(485,'#include<cstdio>\r\n#include<iostream>\r\n#include<cstdlib>\r\nclass matrix\r\n{\r\npublic:\r\n	int **array;\r\n	int m;\r\n	int n;\r\n	matrix(int m,int n)\r\n	{\r\n		this->m=m+1;\r\n		this->n=n+1;\r\n		array=new int*[m+1];\r\n		int i;\r\n		for(i=0;i<m+1;i++)\r\n		{\r\n			array[i]=new int[n+1];\r\n		}\r\n		for(i=0;i<m+1;i++)\r\n		{\r\n			int j;\r\n			for(j=0;j<n+1;j++)\r\n			{\r\n				array[i][j]=0;\r\n			}\r\n		}\r\n	}\r\n	~matrix()\r\n	{\r\n		for(int i=0;i<m;i++)\r\n		{\r\n			delete array[i];\r\n		}\r\n		delete array;\r\n	}\r\n	void show();\r\n};\r\nvoid matrix::show()\r\n{\r\n	for(int i=0;i<m;i++)\r\n	{\r\n		for(int j=0;j<n;j++)\r\n		{\r\n			printf(\"%d  \",array[i][j]);\r\n		}\r\n		printf(\"\\n\");\r\n	}\r\n}\r\nint f(int five,int one,matrix* array)\r\n{\r\n	if(one>five)\r\n	{\r\n		return 0;\r\n	}\r\n	if(one==0)\r\n	{\r\n		array->array[five][one]=1;\r\n		return 1;\r\n	}\r\n	int result=0;\r\n	if(array->array[five][one-1]!=0)\r\n		result+=array->array[five][one-1];\r\n	else\r\n		result+=f(five,one-1,array);\r\n	if(array->array[five-1][one]!=0)\r\n		result+=array->array[five-1][one];\r\n	else\r\n		result+=f(five-1,one,array);\r\n	array->array[five][one]=result;\r\n	return result;\r\n}\r\nint main()\r\n{\r\n	int five,one;\r\n	while(~scanf(\"%d%d\",&one,&five))\r\n	{\r\n		matrix array(five,one);\r\n		printf(\"%d\\n\",f(five,one,&array));\r\n	}\r\n	return 0;\r\n}'),(486,'#include<stdio.h>\r\nint main(){\r\n	int m ,n;\r\n	while(scanf(\"%d%d\",&m,&n)!=EOF)\r\n		printf(\"%d\\n\",meth(m,n));\r\n	return 0;\r\n}\r\n\r\nint meth(int m,int n){\r\n	if(m==0)return 1;\r\n	if(n==0||m>n)return 0;\r\n	return meth(m-1,n)+meth(m,n-1);\r\n}'),(487,'#include <iostream>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\n\r\nconst\r\n    int x[8] = { -1,-2,-1,-2, 1, 2, 1, 2 };\r\n    int y[8] = { -2,-1, 2, 1, 2, 1,-2,-1 };\r\n\r\nint m,n,x1,y1,x2,y2;\r\nint dist[21][21];\r\n\r\nvoid search(int xx, int yy)\r\n{\r\n    int dx,dy,tx,ty,flag = 0;\r\n    int head = 1, tail = 1;\r\n    int f[1000][2];\r\n    f[1][0] = x1;\r\n    f[1][1] = y1;\r\n    dist[x1][y1] = 1;\r\n\r\n    while ( head <= tail )\r\n    {\r\n        tx = f[head][0];\r\n        ty = f[head][1];\r\n        for ( int i = 0; i < 8; i++ )\r\n        {\r\n            dx = tx + x[i];\r\n            dy = ty + y[i];\r\n            if ( ( dx >= 0) && ( dx < m ) && ( dy >= 0 ) && ( dy < n ) && ( dist[dx][dy] == 0 ) )\r\n            {\r\n                tail++;\r\n                f[tail][0] = dx;\r\n                f[tail][1] = dy;\r\n                dist[dx][dy] = dist[tx][ty] + 1;\r\n                if ( ( dx == x2 ) && ( dy == y2 ) )\r\n                {\r\n                    cout << dist[dx][dy]-1 << endl;\r\n                    flag = 1;\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if ( flag == 1 ) return;\r\n        head++;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    while ( scanf(\"%d%d%d%d%d%d\",&m,&n,&x1,&y1,&x2,&y2) != EOF )\r\n    {\r\n        //scanf(\"%d%d%d%d%d%d\",&m,&n,&x1,&y1,&x2,&y2);\r\n        for ( int i = 0; i < 21; i++ )\r\n           for ( int j = 0; j < 21; j++ )\r\n               dist[i][j] = 0;\r\n        if ( ( x1 == x2 ) && ( y1 == y2 ) ) cout << 0 << endl;\r\n        else search(x1,y1);\r\n    }\r\n}\r\n'),(488,'#include <stdio.h>\r\nint ans,a,p,q,m,n,x[21][21],z[8][2]={{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}},M,N,x1,y1,x2,y2;\r\n#define inf 0x7fffffff\r\nvoid search()\r\n{\r\n	int i;\r\n	for(i=0;i<8;i++)\r\n	{\r\n	\r\n		m=p+z[i][0];n=q+z[i][1];\r\n		if((m>=0 && m<=M-1)&&(n>=0 && n<=N-1))\r\n		{\r\n			if(m==x2 && n==y2)\r\n			{\r\n			\r\n			//	printf (\"%d\\n\",x[p][q]+1);\r\n				if (ans>x[p][q]+1) ans=x[p][q]+1; \r\n				return ;\r\n			}\r\n			else if(x[m][n]==-1||x[m][n]>(x[p][q]+1))\r\n			{\r\n				x[m][n]=x[p][q]+1;\r\n				p=m;\r\n				q=n;\r\n				search();\r\n				p-=z[i][0];\r\n				q-=z[i][1];\r\n			}\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n	\r\n	while(scanf(\"%d%d%d%d%d%d\",&M,&N,&x1,&y1,&x2,&y2)!=EOF)\r\n	{\r\n		memset(x,-1,sizeof(x));\r\n		p=x1,q=y1,a=0;\r\n		x[x1][y1]=0; \r\n		ans=inf;\r\n		if(x1==x2&&y1==y2)\r\n			printf(\"%d\\n\",0);\r\n		else\r\n		{\r\n			search();\r\n			printf (\"%d\\n\",ans);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n'),(489,'\r\n#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int a[10000]= {19880101,\r\n                   19880111,\r\n                   19880117,\r\n                   19880129,\r\n                   19880221,\r\n                   19880317,\r\n19880321,\r\n19880323,\r\n19880417,\r\n19880501,\r\n19880519,\r\n19880521,\r\n19880603,\r\n19880629,\r\n19880711,\r\n19880719,\r\n19880723,\r\n19880807,\r\n19880911,\r\n19881019,\r\n19881101,\r\n19881227,\r\n19881229,\r\n19890103,\r\n19890107,\r\n19890307,\r\n19890413,\r\n19890503,\r\n19890509,\r\n19890517,\r\n19890523,\r\n19890707,\r\n19890713,\r\n19890817,\r\n19890911,\r\n19890919,\r\n19891007,\r\n19891019,\r\n19891031,\r\n19891103,\r\n19891117,\r\n19891127,\r\n19891213,\r\n19891229};\r\nfor(int i =0; i < 44; i++)\r\n{\r\n    cout<<a[i]<<endl;\r\n}\r\nreturn 0;\r\n}\r\n'),(490,'#include <iostream>\r\nusing namespace std;\r\nlong res[]={\r\n19880101,19880111,19880117,19880129,19880221,19880317,19880321,19880323,19880417,\r\n19880501,19880519,19880521,19880603,19880629,19880711,19880719,19880723,\r\n19880807,19880911,19881019,19881101,19881227,19881229,19890103,19890107,19890307,\r\n19890413,19890503,19890509,19890517,19890523,19890707,19890713,19890817,19890911,\r\n19890919,19891007,19891019,19891031,19891103,19891117,19891127,19891213,19891229,-1};\r\n\r\nint main()\r\n{\r\n	for(int i=0;res[i]!=-1;i++)\r\n	{\r\n		printf(\"%ld\\n\",res[i]);\r\n	}\r\n	return 0;\r\n}'),(491,'#include<stdio.h>\n\nint main()\n{\n	char c,d,s[1000];\n	int ok,note=0,k=0,lnum=0,rnum=0,nsp=0;\n	while((c=getchar())!=EOF)\n	{\n		if(!note&&c!=\'/\'&&c!=\' \')\n		{\n			for(int i=0;i<nsp;i++)\n				printf(\" \");\n			nsp=0;\n			printf(\"%c\",c);\n		}\n		else if(!note&&c==\' \')\n			nsp++;\n		else if(!note&&c==\'/\')\n		{\n			d=getchar();\n			if(d==\'*\')\n			{\n				nsp=0;\n				lnum++;\n				ok=1;\n				note=1;\n				s[k++]=c;\n				s[k++]=d;\n			}\n			else\n			{\n				for(int i=0;i<nsp;i++)\n					printf(\" \");\n				nsp=0;\n				printf(\"%c%c\",c,d);\n			}\n		}\n		else if(note&&c==\'/\')\n		{\n			d=getchar();\n			if(d==\'*\')\n			{\n				lnum++;\n				ok=0;\n			}\n			s[k++]=c;\n			s[k++]=d;\n		}\n		else if(note&&c!=\'*\')\n			s[k++]=c;\n		else if(note&&c==\'*\')\n		{\n			d=getchar();\n			s[k++]=c;\n			s[k++]=d;\n			if(d==\'/\')\n			{\n				rnum++;\n				if(lnum==rnum)\n				{\n					note=0;\n					s[k]=\'\\0\';\n					if(ok)\n						printf(\"%s\",s);\n					else\n					{\n						s[0]=\'\\0\';\n						getchar();\n					}\n					k=0;\n				}\n			}\n		}\n	}\n	return 0;\n}'),(492,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	char str[1024];\r\n	int len,i,temp;\r\n	while(gets(str))\r\n	{\r\n		temp=0;\r\n		len=strlen(str);\r\n		for(i=1;i<len-1;i++)\r\n		{\r\n			if(str[i]==\'*\'&&(str[i-1]==\'/\'||str[i+1]==\'/\'))\r\n				temp++;\r\n		}\r\n		if(temp==2||temp==0)\r\n			puts(str);\r\n	}\r\n	return 0;\r\n}\r\n'),(493,'#include <stdio.h>\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	double a,b,x[100],y[100],sum=0;\r\n	scanf(\"%d\",&m);\r\n	for(i=0;i<m*2;i++)\r\n		scanf(\"%lf\",&x[i]);\r\n	getchar();\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n*2;i++)\r\n		scanf(\"%lf\",&y[i]);\r\n	for(i=0;i<2*m;i+=2)\r\n	{\r\n		for(j=0;j<2*n;j+=2)\r\n		{\r\n			if(y[j]>x[i+1])\r\n				break;\r\n			else if(y[j+1]>x[i])\r\n			{\r\n				if(x[i]>y[j])\r\n					a=x[i];\r\n				else\r\n					a=y[j];\r\n				if(x[i+1]>y[j+1])\r\n					b=y[j+1];\r\n				else\r\n					b=x[i+1];\r\n				sum+=(b-a);\r\n			}\r\n		}\r\n	}\r\n	printf(\"%.3lf\\n\",sum);\r\n\r\n}\r\n	\r\n'),(494,'#include <stdio.h>\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	double a,b,x[100],y[100],sum=0;\r\n	scanf(\"%d\",&m);\r\n	for(i=0;i<m*2;i++)\r\n		scanf(\"%lf\",&x[i]);\r\n	getchar();\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n*2;i++)\r\n		scanf(\"%lf\",&y[i]);\r\n	for(i=0;i<2*m;i+=2)\r\n	{\r\n		for(j=0;j<2*n;j+=2)\r\n		{\r\n			if(y[j]>x[i+1])\r\n				break;\r\n			else if(y[j+1]>x[i])\r\n			{\r\n				if(x[i]>y[j])\r\n					a=x[i];\r\n				else\r\n					a=y[j];\r\n				if(x[i+1]>y[j+1])\r\n					b=y[j+1];\r\n				else\r\n					b=x[i+1];\r\n				sum+=(b-a);\r\n			}\r\n		}\r\n	}\r\n	printf(\"%.3lf\\n\",sum);\r\n\r\n}\r\n	\r\n'),(495,'#include <stdio.h> \r\nint main() \r\n\r\n\r\n{ int m1,m2,m3,m4; \r\nint my1,my2,my3,my4; \r\nint y1,y2,y3,y4; \r\nint n,i; \r\nscanf(\"%d.%d.%d.%d\",&my1,&my2,&my3,&my4); \r\nscanf(\"%d.%d.%d.%d\",&y1,&y2,&y3,&y4); \r\nmy1&=y1; \r\nmy2&=y2; \r\nmy3&=y3; \r\nmy4&=y4; \r\nscanf(\"%d\",&n); \r\nfor(i=0;i<n;i++) \r\n{ \r\n\r\nscanf(\"%d.%d.%d.%d\",&m1,&m2,&m3,&m4); \r\nm1&=y1; \r\nm2&=y2; \r\nm3&=y3; \r\nm4&=y4; \r\n\r\n\r\nif(m1==my1&&m2==my2&&m3==my3&&m4==my4) \r\nprintf(\"INNER\\n\"); \r\nelse \r\nprintf(\"OUTER\\n\"); \r\n} \r\n\r\n\r\nreturn 0; \r\n} '),(496,'#include <stdio.h>\nunsigned int getip(){\n	unsigned int a=0,b,c,d;\n	scanf(\"%d.%d.%d.%d\",&a,&b,&c,&d);\n	//printf(\"%d.%d.%d.%d\\n\",a,b,c,d);\n	a<<=8;\n	a+=b;\n	a<<=8;\n	a+=c;\n	a<<=8;\n	a+=d;\n	return a;\n}\nint main(){\n	unsigned int me,mask,n,other;\n	me=getip();\n	mask=getip();\n	scanf(\"%d\\n\",&n);\n	while(n){\n		other=getip();\n		if ((me&mask)==(other&mask))\n			printf(\"INNER\\n\");\n		else\n			printf(\"OUTER\\n\");\n		n--;\n	}\n\n}\n'),(497,'import java.util.*;\r\npublic class Main \r\n{\r\n	public static void main(String [] args) {\r\n		Scanner in = new Scanner(System.in);\r\n		int year = in.nextInt();\r\n		int month = in.nextInt();\r\n		show(year,month);\r\n	}\r\n	public static void show(int year,int month) {\r\n		System.out.println(\"Su Mo Tu We Th Fr Sa\");\r\n		int day = 1;\r\n		GregorianCalendar calendar = new GregorianCalendar(year,month-1,day);\r\n		for(int i = 1; i < calendar.get(Calendar.DAY_OF_WEEK); i++)\r\n			System.out.print(\"   \");\r\n		while(calendar.get(Calendar.MONTH) == month-1) {\r\n			if(calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY || day == 1)\r\n				System.out.printf(\"%2d\",(day++));\r\n			else\r\n				System.out.printf(\" %2d\",(day++));\r\n			if(calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY)\r\n				System.out.println();\r\n			calendar.add(Calendar.DAY_OF_MONTH, 1);\r\n		}\r\n	}\r\n}'),(498,'import java.util.*;\r\npublic class Main \r\n{\r\n	public static void main(String [] args) {\r\n		Scanner in = new Scanner(System.in);\r\n		int year = in.nextInt();\r\n		int month = in.nextInt();\r\n		show(year,month);\r\n	}\r\n	public static void show(int year,int month) {\r\n		System.out.println(\"Su Mo Tu We Th Fr Sa\");\r\n		int day = 1;\r\n		GregorianCalendar calendar = new GregorianCalendar(year,month-1,day);\r\n		for(int i = 1; i < calendar.get(Calendar.DAY_OF_WEEK); i++)\r\n			System.out.print(\"   \");\r\n		while(calendar.get(Calendar.MONTH) == month-1) {\r\n			if(calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY || day == 1)\r\n				System.out.printf(\"%2d\",(day++));\r\n			else\r\n				System.out.printf(\" %2d\",(day++));\r\n			if(calendar.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY)\r\n				System.out.println();\r\n			calendar.add(Calendar.DAY_OF_MONTH, 1);\r\n		}\r\n	}\r\n}'),(499,'#include <iostream>\r\n#include <set>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    string a;\r\n    string b;\r\n    set<string> s;\r\n    int k =0;\r\n    while(getline(cin,a))\r\n    {\r\n\r\n\r\n            for(int i =0; i < a.size(); i++)\r\n            {\r\n                if(a[i] == \'(\')  break;\r\n                else  b += a[i];\r\n\r\n            }\r\n            //cout<<b<<endl;\r\n            if(s.count(b) == 0)\r\n               {\r\n                  // cout<<s.count(b)<<endl;\r\n                   s.insert(b);\r\n                   b.clear();\r\n               }\r\n            else\r\n               b.clear();\r\n\r\n\r\n    }\r\n    for(set<string>::iterator it = s.begin(); it != s.end(); it++)\r\n    {\r\n        cout<<*it<<endl;\r\n    }\r\n    return 0;\r\n}'),(500,'#include<iostream>\r\n#include<string>\r\n#include<set>\r\nusing namespace std;\r\nint main()\r\n{\r\n   char s[1000];\r\n   set<string> ss;\r\n   while(cin.getline(s,1000))\r\n   {\r\n      int i=0;\r\n      while(s[i]!=\'(\')i++;\r\n      s[i]=0;\r\n      string str=s;\r\n      ss.insert(str);\r\n   }\r\n   for(set<string>::const_iterator p=ss.begin();p!=ss.end();++p)\r\n   cout<<*p<<endl;\r\n}'),(501,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n,i,j,a[3][3],min,mid,max,minx[3],t,midx[3],maxx[3],s,sum[3],k=1;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n		for(i=0;i<3;i++)\r\n			for(j=0;j<3;j++)\r\n				cin>>a[i][j];\r\n			for(i=0;i<3;i++)\r\n			{\r\n				if(a[i][2]>a[i][1]&&a[i][1]>a[i][0])\r\n				{\r\n					max=a[i][2];\r\n					mid=a[i][1];\r\n					min=a[i][0];\r\n				}\r\n				if(a[i][2]>a[i][0]&&a[i][0]>a[i][1])\r\n				{\r\n					max=a[i][2];\r\n					mid=a[i][0];\r\n					min=a[i][1];\r\n				} \r\n				if(a[i][1]>a[i][0]&&a[i][0]>a[i][2])\r\n				{\r\n					max=a[i][1];\r\n					mid=a[i][0];\r\n					min=a[i][2];\r\n				}\r\n				if(a[i][1]>a[i][2]&&a[i][2]>a[i][0])\r\n				{\r\n					max=a[i][1];\r\n					mid=a[i][2];\r\n					min=a[i][0];\r\n				}\r\n				if(a[i][0]>a[i][1]&&a[i][1]>a[i][2])\r\n				{\r\n					max=a[i][0];\r\n					mid=a[i][1];\r\n					min=a[i][2];\r\n				}\r\n				if(a[i][0]>a[i][2]&&a[i][2]>a[i][1])\r\n				{\r\n					max=a[i][0];\r\n					mid=a[i][2];\r\n					min=a[i][1];\r\n				}\r\n				sum[i]=max*8+mid*6;minx[i]=min;midx[i]=mid;maxx[i]=max;\r\n			}\r\n			max=sum[0];\r\n			if(sum[1]>sum[0])\r\n			{  \r\n				max=sum[1];\r\n				if(sum[2]>sum[1])\r\n					max=sum[2];\r\n			}\r\n			else if(sum[2]>sum[0])\r\n				max=sum[2];\r\n			if(max==sum[0]) \r\n				t=0;\r\n			else if(max==sum[1])\r\n				t=1;\r\n			else if(max==sum[2]) \r\n				t=2;\r\n			s=max;\r\n			for(i=0;i<3;i++)\r\n				if(i!=t) \r\n					s+=(maxx[i]+midx[i])*7+minx[i]*5;\r\n				s+=minx[t]*5;\r\n				cout<<\"Test #\"<<k++<<endl;\r\n				cout<<s<<endl<<endl;\r\n	}\r\n	return 0;\r\n}'),(502,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n,i,j,a[3][3],min,mid,max,minx[3],t,midx[3],maxx[3],s,sum[3],k=1;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n		for(i=0;i<3;i++)\r\n			for(j=0;j<3;j++)\r\n				cin>>a[i][j];\r\n			for(i=0;i<3;i++)\r\n			{\r\n				if(a[i][2]>a[i][1]&&a[i][1]>a[i][0])\r\n				{\r\n					max=a[i][2];\r\n					mid=a[i][1];\r\n					min=a[i][0];\r\n				}\r\n				if(a[i][2]>a[i][0]&&a[i][0]>a[i][1])\r\n				{\r\n					max=a[i][2];\r\n					mid=a[i][0];\r\n					min=a[i][1];\r\n				} \r\n				if(a[i][1]>a[i][0]&&a[i][0]>a[i][2])\r\n				{\r\n					max=a[i][1];\r\n					mid=a[i][0];\r\n					min=a[i][2];\r\n				}\r\n				if(a[i][1]>a[i][2]&&a[i][2]>a[i][0])\r\n				{\r\n					max=a[i][1];\r\n					mid=a[i][2];\r\n					min=a[i][0];\r\n				}\r\n				if(a[i][0]>a[i][1]&&a[i][1]>a[i][2])\r\n				{\r\n					max=a[i][0];\r\n					mid=a[i][1];\r\n					min=a[i][2];\r\n				}\r\n				if(a[i][0]>a[i][2]&&a[i][2]>a[i][1])\r\n				{\r\n					max=a[i][0];\r\n					mid=a[i][2];\r\n					min=a[i][1];\r\n				}\r\n				sum[i]=max*8+mid*6;minx[i]=min;midx[i]=mid;maxx[i]=max;\r\n			}\r\n			max=sum[0];\r\n			if(sum[1]>sum[0])\r\n			{  \r\n				max=sum[1];\r\n				if(sum[2]>sum[1])\r\n					max=sum[2];\r\n			}\r\n			else if(sum[2]>sum[0])\r\n				max=sum[2];\r\n			if(max==sum[0]) \r\n				t=0;\r\n			else if(max==sum[1])\r\n				t=1;\r\n			else if(max==sum[2]) \r\n				t=2;\r\n			s=max;\r\n			for(i=0;i<3;i++)\r\n				if(i!=t) \r\n					s+=(maxx[i]+midx[i])*7+minx[i]*5;\r\n				s+=minx[t]*5;\r\n				cout<<\"Test #\"<<k++<<endl;\r\n				cout<<s<<endl<<endl;\r\n	}\r\n	return 0;\r\n}'),(503,'#include<iostream>\r\n#include<stdio.h>\r\n#include<math.h>\r\n#define eps 1e-8\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct point{double x,y;};\r\npoint a[1000];\r\ndouble b[1000],c[2000];\r\nvoid getpoint(double x1,double y1,double x2,double y2,double r,point &p1,point &p2)\r\n{\r\n double a,b,c,det;\r\n a=(y1-y2)*(y1-y2)-r*r;\r\n b=2*((x1*y2-y1*x2)*(y1-y2)+r*r*x1);\r\n c=(x1*y2-y1*x2)*(x1*y2-y1*x2)-r*r*x1*x1-y1*y1*r*r;\r\n det=sqrt(b*b-4*a*c);\r\n p1.x=(-b+det)/2/a;\r\n p2.x=(-b-det)/2/a;\r\n p1.y=p2.y=0;\r\n}\r\ndouble dis(point p1,point p2){\r\n return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\r\n}\r\ndouble xmult(point p1,point p2,point p0){\r\n return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\r\n}\r\ndouble disptoline(point p,point l1,point l2){\r\n return fabs(xmult(p,l1,l2))/dis(l1,l2);\r\n}\r\nint intersect_line_circle(point c,double r,point l1,point l2){\r\n return disptoline(c,l1,l2)<r+eps;\r\n}\r\nint main()\r\n{\r\n int n,i,j,tot;\r\n point sou,p1,p2;\r\n bool d;\r\n \r\n while(1)\r\n {\r\n  scanf(\"%d\",&n);\r\n  if (n==0) break;\r\n  scanf(\"%lf%lf\",&sou.x,&sou.y);\r\n  for(i=1;i<=n;i++)\r\n    scanf(\"%lf%lf%lf\",&a[i].x,&a[i].y,&b[i]);\r\n  tot=0;\r\n  for(i=1;i<=n;i++)\r\n  {\r\n   getpoint(sou.x,sou.y,a[i].x,a[i].y,b[i],p1,p2);\r\n   d=true;\r\n   for(j=1;j<=n;j++)\r\n     if (i!=j&&intersect_line_circle(a[j],b[j],sou,p1)) {d=false;break;}\r\n   if (d==true)c[++tot]=p1.x;\r\n   d=true;\r\n   for(j=1;j<=n;j++)\r\n     if (i!=j&&intersect_line_circle(a[j],b[j],sou,p2)) {d=false;break;}\r\n   if (d==true) c[++tot]=p2.x;\r\n  }\r\n  sort(c+1,c+tot+1);\r\n  for(i=1;i<=tot;i+=2)\r\n    printf(\"%.2lf %.2lf\\n\",c[i],c[i+1]);\r\n  printf(\"\\n\");\r\n }\r\n return 0;\r\n}'),(504,'#include<iostream>\r\n#include<stdio.h>\r\n#include<math.h>\r\n#define eps 1e-8\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct point{double x,y;};\r\npoint a[1000];\r\ndouble b[1000],c[2000];\r\nvoid getpoint(double x1,double y1,double x2,double y2,double r,point &p1,point &p2)\r\n{\r\n double a,b,c,det;\r\n a=(y1-y2)*(y1-y2)-r*r;\r\n b=2*((x1*y2-y1*x2)*(y1-y2)+r*r*x1);\r\n c=(x1*y2-y1*x2)*(x1*y2-y1*x2)-r*r*x1*x1-y1*y1*r*r;\r\n det=sqrt(b*b-4*a*c);\r\n p1.x=(-b+det)/2/a;\r\n p2.x=(-b-det)/2/a;\r\n p1.y=p2.y=0;\r\n}\r\ndouble dis(point p1,point p2){\r\n return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\r\n}\r\ndouble xmult(point p1,point p2,point p0){\r\n return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\r\n}\r\ndouble disptoline(point p,point l1,point l2){\r\n return fabs(xmult(p,l1,l2))/dis(l1,l2);\r\n}\r\nint intersect_line_circle(point c,double r,point l1,point l2){\r\n return disptoline(c,l1,l2)<r+eps;\r\n}\r\nint main()\r\n{\r\n int n,i,j,tot;\r\n point sou,p1,p2;\r\n bool d;\r\n \r\n while(1)\r\n {\r\n  scanf(\"%d\",&n);\r\n  if (n==0) break;\r\n  scanf(\"%lf%lf\",&sou.x,&sou.y);\r\n  for(i=1;i<=n;i++)\r\n    scanf(\"%lf%lf%lf\",&a[i].x,&a[i].y,&b[i]);\r\n  tot=0;\r\n  for(i=1;i<=n;i++)\r\n  {\r\n   getpoint(sou.x,sou.y,a[i].x,a[i].y,b[i],p1,p2);\r\n   d=true;\r\n   for(j=1;j<=n;j++)\r\n     if (i!=j&&intersect_line_circle(a[j],b[j],sou,p1)) {d=false;break;}\r\n   if (d==true)c[++tot]=p1.x;\r\n   d=true;\r\n   for(j=1;j<=n;j++)\r\n     if (i!=j&&intersect_line_circle(a[j],b[j],sou,p2)) {d=false;break;}\r\n   if (d==true) c[++tot]=p2.x;\r\n  }\r\n  sort(c+1,c+tot+1);\r\n  for(i=1;i<=tot;i+=2)\r\n    printf(\"%.2lf %.2lf\\n\",c[i],c[i+1]);\r\n  printf(\"\\n\");\r\n }\r\n return 0;\r\n}'),(505,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a;\r\n	while(scanf(\"%ld\",&a)!=-1)\r\n	{\r\n	printf(\"%d days %d hours %d minutes %d seconds\\n\",a/(60*60*24),(a%(60*60*24))/(60*60),((a%(60*60*24))%(60*60))/60,((a%(60*60*24))%(60*60))%60);\r\n	}\r\n	return 0;\r\n}'),(506,'#include<stdio.h>\r\n\r\nint main(){\r\n	int n;\r\n	while(scanf(\"%d\",&n)!=EOF){\r\n		printf(\"%d days %d hours %d minutes %d seconds\\n\",n/(3600*24),\r\n		n%(3600*24)/3600,n%3600/60,n%3600%60);\r\n	}\r\n}'),(507,'#include <iostream>\r\n#include <cstdio>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int a,b;\r\n	while(scanf(\"%d\",&n)!=EOF)\r\n	{\r\n	for(int i=0;i<n;++i)\r\n	{\r\n       scanf(\"%d %d\",&a,&b);\r\n	   if(b%(a+1)==0)\r\n		   printf(\"Regretful\\n\");\r\n	   else \r\n	   {\r\n		   int c=b%(a+1);\r\n		  printf(\"%d\\n\",c);\r\n	   }\r\n	}\r\n	}\r\n	return 0;\r\n}\r\n'),(508,'#include<stdio.h>\r\nint main()\r\n{\r\n	int num,i;\r\n	int n,m;\r\n	while(scanf(\"%d\",&num)!=EOF)\r\n	{\r\n		for(i=0;i<num;i++)\r\n		{\r\n			scanf(\"%d%d\",&n,&m);\r\n			if(m%(n+1)==0)\r\n				printf(\"Regretful\\n\");\r\n			else\r\n				printf(\"%d\\n\",m%(n+1));\r\n		}\r\n	}\r\n\r\n	return 0;\r\n}'),(509,'#include<stdio.h>\r\n#include<algorithm>\r\nusing namespace std;\r\ntypedef struct {\r\n	char name[12];\r\n	int a,b,c;\r\n}ST;\r\nint cmp(const ST &x,const ST &y)\r\n{\r\n	return (x.c>y.c) || (x.c == y.c) && ( (x.a>y.a)||(x.a==y.a)&&(strcmp(x.name,y.name)<0) );\r\n}\r\n	\r\nint main()\r\n{\r\n	int n,m,num;\r\n	while(scanf(\"%d\",&n)!=EOF&&n)\r\n	{\r\n		ST *s = (ST *)malloc(sizeof(ST)*n);\r\n		for(int i = 0; i<n; i++)\r\n		{\r\n			scanf(\"%s%d%d\",s[i].name,&s[i].a,&s[i].b);\r\n		}\r\n		scanf(\"%d%d\",&m,&num);\r\n		for(int i = 0; i<n; i++)\r\n				s[i].c = (s[i].b > num) ? 1: 0;\r\n		sort(s,s+n,cmp);\r\n		for(int i = 0; i<m&&i<n&&s[i].c; i++)\r\n				printf(\"%s\\n\",s[i].name);\r\n	}\r\n	return 0;\r\n}\r\n'),(510,'#include<stdio.h>\r\n#include<algorithm>\r\nusing namespace std;\r\ntypedef struct {\r\n	char name[12];\r\n	int a,b,c;\r\n}ST;\r\nint cmp(const ST &x,const ST &y)\r\n{\r\n	return (x.c>y.c) || (x.c == y.c) && ( (x.a>y.a)||(x.a==y.a)&&(strcmp(x.name,y.name)<0) );\r\n}\r\n	\r\nint main()\r\n{\r\n	int n,m,num;\r\n	while(scanf(\"%d\",&n)!=EOF&&n)\r\n	{\r\n		ST *s = (ST *)malloc(sizeof(ST)*n);\r\n		for(int i = 0; i<n; i++)\r\n		{\r\n			scanf(\"%s%d%d\",s[i].name,&s[i].a,&s[i].b);\r\n		}\r\n		scanf(\"%d%d\",&m,&num);\r\n		for(int i = 0; i<n; i++)\r\n				s[i].c = (s[i].b > num) ? 1: 0;\r\n		sort(s,s+n,cmp);\r\n		for(int i = 0; i<m&&i<n&&s[i].c; i++)\r\n				printf(\"%s\\n\",s[i].name);\r\n	}\r\n	return 0;\r\n}\r\n'),(511,'#include<iostream>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n	  int Case,n,i,j,k;\r\n	  char str[100][101];\r\n      cin >> Case;\r\n	  while(Case --)\r\n	  {\r\n		   int Minlen = 1000,loc = 0;\r\n	       cin >> n;   \r\n		   for(i = 0; i < n; ++ i)\r\n		   {\r\n			   cin >> str[i];\r\n			   if(Minlen > strlen(str[i]))              //查找输入数据中长度最短的\r\n			   {\r\n				     Minlen = strlen(str[i]);\r\n					 loc = i;\r\n			   }\r\n		   }\r\n		   ///////////////////////////////////////////查找满足条件的\r\n		   char s[101],res[101];\r\n		   for(i = Minlen; i >= 1; -- i)             //从大到小查找       i表示长度\r\n		   {\r\n		        for(j = 0; j <= Minlen - i; ++ j)   //子字符串从j开始\r\n				{\r\n				     k = 0;\r\n					 while(k < i)\r\n					 {\r\n						 s[k]= res[i - k - 1] = str[loc][j + k];\r\n					     ++ k;\r\n					 }\r\n					 s[k] = res[k] = \'\\0\';\r\n                     //从第一个字符串开始查找\r\n					 for(k = 0; (k < n) && ((strstr(str[k],s)||strstr(str[k],res))); ++ k);\r\n					 if(k == n)     //查找成功\r\n					 {\r\n					       cout << i << endl;\r\n						   break;\r\n					 }\r\n				}\r\n				if(k == n)   break;\r\n		   }\r\n		 if(i == 0)   cout << 0 << endl;\r\n	  }\r\n	  return 0;\r\n}\r\n'),(512,'#include<iostream>\r\n#include<string>\r\n#include<vector>\r\n \r\nusing namespace std;\r\nstring ff(const string & s)\r\n{\r\n	char t[111];\r\n	int len=s.length();\r\n	t[len]=0;\r\n	for(int i=len-1;i>=0;i--)\r\n           t[i]=s[len-1-i];\r\n	return t;\r\n}\r\nint f()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	char s[111];\r\n	vector<string> v;\r\n//	cin.sync();\r\n	while(n--)\r\n	{\r\n		string ss;\r\n		cin>>ss;\r\n		v.push_back(ss);\r\n	}\r\n	int m=v[0].length();\r\n	int len=m;\r\n	int vcount=v.size();\r\n	while(m>0)\r\n	{\r\n		for(int i=0;i<=len-m;i++)\r\n		{ \r\n			string t=v[0].substr(i,m);\r\n			string tt=ff(t);\r\n			int j;\r\n			for(  j=1;j<vcount;j++)\r\n				if(v[j].find(t)==string::npos&&v[j].find(tt)==string::npos)\r\n					break;\r\n			if(j==vcount) return m;\r\n		  \r\n		}\r\n		m--;\r\n	}\r\n	return m;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n	cin>>n;\r\n	while(n--)\r\n		cout<<f()<<endl;\r\n \r\n}'),(513,'#include \"stdio.h\"\r\n#include \"string.h\"\r\n#include <algorithm>\r\n#include <map>\r\nusing namespace std;\r\nstruct treeNode\r\n{\r\n	int left,right,cover;\r\n}nodeList[150000];\r\nint iArray[50002];\r\nint iArray_t[50002];\r\nmap<int,int> mp;\r\nint VisitedNodeList[50002]={0},ans=0,n,i;\r\n\r\n\r\nvoid creatTree(int left,int right,int now)\r\n{\r\n	nodeList[now].left = left;\r\n	nodeList[now].right = right;\r\n	nodeList[now].cover = 0;\r\n	if(left == right)\r\n		return;\r\n	int mid = (left+right)/2;\r\n	creatTree(left,mid,now<<1);\r\n	creatTree(mid+1,right,(now<<1)+1);\r\n\r\n}\r\n\r\nvoid InsertTree(int left,int right,int cover,int now)\r\n{\r\n	if(nodeList[now].left == left && nodeList[now].right == right)\r\n	{\r\n		nodeList[now].cover = cover;\r\n		return;\r\n	}\r\n	if(nodeList[now].cover > 0 && nodeList[now].cover != cover)\r\n	{\r\n		nodeList[now*2].cover = nodeList[now].cover;\r\n		nodeList[now*2+1].cover = nodeList[now].cover;\r\n		nodeList[now].cover = 0;\r\n	}\r\n	int mid = (nodeList[now].left + nodeList[now].right)/2;\r\n	if(right <= mid)\r\n		InsertTree(left,right,cover,2*now);\r\n	else if(left > mid)\r\n		InsertTree(left,right,cover,2*now+1);\r\n	else\r\n	{\r\n		InsertTree(left,mid,cover,2*now);\r\n		InsertTree(mid+1,right,cover,2*now+1);\r\n	}\r\n	\r\n}\r\n\r\nvoid SearchTree(int now)\r\n{\r\n	if(nodeList[now].cover != 0)\r\n	{\r\n		if(VisitedNodeList[nodeList[now].cover]==0)\r\n		{\r\n			//printf(\"test:%d --%d %d %d\\n\",now,nodeList[now].left,nodeList[now].right,nodeList[now].cover);\r\n			VisitedNodeList[nodeList[now].cover]=1;\r\n			ans ++ ;\r\n			return ;\r\n		}	\r\n		return;\r\n	}\r\n	if(nodeList[now].left == nodeList[now].right)return ;\r\n	SearchTree(2*now);\r\n	SearchTree(2*now+1);\r\n}\r\nint main()\r\n{\r\n	//freopen(\"input_all.txt\",\"r\",stdin);\r\n	//freopen(\"output_all.txt\",\"w\",stdout);\r\n	while(scanf(\"%d\",&n)==1)\r\n	{\r\n		ans = 0;\r\n		memset(VisitedNodeList,0,sizeof(VisitedNodeList));\r\n		creatTree(1,50000,1);\r\n		\r\n		n *= 2;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n			scanf(\"%d\",&iArray[i]);\r\n		}\r\n		memcpy(iArray_t+1,iArray+1,sizeof(int)*(n));\r\n		sort(iArray_t+1,iArray_t+n+1);\r\n		int iCount = 1;\r\n		for(i=1;i<=n;i++)\r\n			if(iArray_t[i] != iArray_t[i-1])\r\n			{\r\n				if(iArray_t[i-1] + 1 ==  iArray_t[i])\r\n				{\r\n					mp[iArray_t[i]]=mp[iArray_t[i-1]]+1;\r\n				}\r\n				else mp[iArray_t[i]]=iCount*2-1;\r\n				iCount++;\r\n			}\r\n// 		for(i=1;i<=n;i++)\r\n// 		{\r\n// 			printf(\"t:%d %d\\n\",iArray_t[i],mp[iArray_t[i]]);\r\n// 		}\r\n		for(i=1;i<=n;i+=2)\r\n		{\r\n			//printf(\"tt:%d %d\\n\",mp[iArray[i]],mp[iArray[i+1]]);\r\n			InsertTree(mp[iArray[i]],mp[iArray[i+1]],i/2+1,1);\r\n		}\r\n		SearchTree(1);\r\n		printf(\"%d\\n\",ans);\r\n	}\r\n	return 0;\r\n}\r\n'),(514,'#include \"stdio.h\"\r\n#include \"string.h\"\r\n#include <algorithm>\r\n#include <map>\r\nusing namespace std;\r\nstruct treeNode\r\n{\r\n	int left,right,cover;\r\n}nodeList[150000];\r\nint iArray[50002];\r\nint iArray_t[50002];\r\nmap<int,int> mp;\r\nint VisitedNodeList[50002]={0},ans=0,n,i;\r\n\r\n\r\nvoid creatTree(int left,int right,int now)\r\n{\r\n	nodeList[now].left = left;\r\n	nodeList[now].right = right;\r\n	nodeList[now].cover = 0;\r\n	if(left == right)\r\n		return;\r\n	int mid = (left+right)/2;\r\n	creatTree(left,mid,now<<1);\r\n	creatTree(mid+1,right,(now<<1)+1);\r\n\r\n}\r\n\r\nvoid InsertTree(int left,int right,int cover,int now)\r\n{\r\n	if(nodeList[now].left == left && nodeList[now].right == right)\r\n	{\r\n		nodeList[now].cover = cover;\r\n		return;\r\n	}\r\n	if(nodeList[now].cover > 0 && nodeList[now].cover != cover)\r\n	{\r\n		nodeList[now*2].cover = nodeList[now].cover;\r\n		nodeList[now*2+1].cover = nodeList[now].cover;\r\n		nodeList[now].cover = 0;\r\n	}\r\n	int mid = (nodeList[now].left + nodeList[now].right)/2;\r\n	if(right <= mid)\r\n		InsertTree(left,right,cover,2*now);\r\n	else if(left > mid)\r\n		InsertTree(left,right,cover,2*now+1);\r\n	else\r\n	{\r\n		InsertTree(left,mid,cover,2*now);\r\n		InsertTree(mid+1,right,cover,2*now+1);\r\n	}\r\n	\r\n}\r\n\r\nvoid SearchTree(int now)\r\n{\r\n	if(nodeList[now].cover != 0)\r\n	{\r\n		if(VisitedNodeList[nodeList[now].cover]==0)\r\n		{\r\n			//printf(\"test:%d --%d %d %d\\n\",now,nodeList[now].left,nodeList[now].right,nodeList[now].cover);\r\n			VisitedNodeList[nodeList[now].cover]=1;\r\n			ans ++ ;\r\n			return ;\r\n		}	\r\n		return;\r\n	}\r\n	if(nodeList[now].left == nodeList[now].right)return ;\r\n	SearchTree(2*now);\r\n	SearchTree(2*now+1);\r\n}\r\nint main()\r\n{\r\n	//freopen(\"input_all.txt\",\"r\",stdin);\r\n	//freopen(\"output_all.txt\",\"w\",stdout);\r\n	while(scanf(\"%d\",&n)==1)\r\n	{\r\n		ans = 0;\r\n		memset(VisitedNodeList,0,sizeof(VisitedNodeList));\r\n		creatTree(1,50000,1);\r\n		\r\n		n *= 2;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n			scanf(\"%d\",&iArray[i]);\r\n		}\r\n		memcpy(iArray_t+1,iArray+1,sizeof(int)*(n));\r\n		sort(iArray_t+1,iArray_t+n+1);\r\n		int iCount = 1;\r\n		for(i=1;i<=n;i++)\r\n			if(iArray_t[i] != iArray_t[i-1])\r\n			{\r\n				if(iArray_t[i-1] + 1 ==  iArray_t[i])\r\n				{\r\n					mp[iArray_t[i]]=mp[iArray_t[i-1]]+1;\r\n				}\r\n				else mp[iArray_t[i]]=iCount*2-1;\r\n				iCount++;\r\n			}\r\n// 		for(i=1;i<=n;i++)\r\n// 		{\r\n// 			printf(\"t:%d %d\\n\",iArray_t[i],mp[iArray_t[i]]);\r\n// 		}\r\n		for(i=1;i<=n;i+=2)\r\n		{\r\n			//printf(\"tt:%d %d\\n\",mp[iArray[i]],mp[iArray[i+1]]);\r\n			InsertTree(mp[iArray[i]],mp[iArray[i+1]],i/2+1,1);\r\n		}\r\n		SearchTree(1);\r\n		printf(\"%d\\n\",ans);\r\n	}\r\n	return 0;\r\n}\r\n'),(515,'#include <iostream>\r\n#include <stdio.h>\r\n#include <string.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int nCase,kind,turn;\r\n	int aSize,bSize,taSize,nowA,nowB,aCatch,bCatch;\r\n	char a[2500],b[2500],table[60];\r\n	bool mark[52],gameOver=false;\r\n	int i,term,place[52];\r\n	cin>>nCase;\r\n	while(nCase--)\r\n	{\r\n		cin>>kind;\r\n		scanf(\"%s%s\",a,b);\r\n		memset(mark ,false,sizeof(mark));\r\n		bSize=kind*2;\r\n		aSize=bSize;\r\n		aCatch=0;\r\n		bCatch=0;\r\n		taSize=0;\r\n		nowA=0;\r\n		nowB=0;\r\n		turn=2000;\r\n		while (turn>0)\r\n		{\r\n			table[taSize++]=a[nowA];\r\n			if (a[nowA]>=\'a\')\r\n			{\r\n				term=a[nowA]-\'a\'+26;\r\n			}\r\n			else\r\n			{\r\n				term=a[nowA]-\'A\';\r\n			}\r\n			while(mark[term])\r\n			{\r\n				for (i=place[term];i<taSize;i++)\r\n				{\r\n					a[aSize++]=table[i];\r\n					if (table[i]>=\'a\')\r\n					{\r\n						term=table[i]-\'a\'+26;\r\n					}\r\n					else\r\n					{\r\n						term=table[i]-\'A\';\r\n					}\r\n					if (mark[term])\r\n					{\r\n						mark[term]=false;\r\n					}\r\n				}\r\n				aCatch++;\r\n				taSize=place[term];\r\n				mark[term]=false;\r\n\r\n				turn--;\r\n				if (turn<=0)\r\n				{\r\n					break;\r\n				}\r\n				nowA++;\r\n				table[taSize++]=a[nowA];\r\n				if (a[nowA]>=\'a\')\r\n				{\r\n					term=a[nowA]-\'a\'+26;\r\n				}\r\n				else\r\n				{\r\n					term=a[nowA]-\'A\';\r\n				}\r\n			} \r\n			if (turn<=0)\r\n			{\r\n				break;\r\n			}\r\n			mark[term]=true;\r\n			place[term]=taSize-1;\r\n			nowA++;\r\n			turn--;\r\n			if (nowA>=aSize)\r\n			{\r\n				cout<<\"B\"<<\" \"<<aCatch<<\" \"<<bCatch<<endl;\r\n				gameOver=true;\r\n				break;\r\n			}\r\n			if (turn<=0)\r\n			{\r\n				break;\r\n			}\r\n\r\n			table[taSize++]=b[nowB];\r\n			if (b[nowB]>=\'a\')\r\n			{\r\n				term=b[nowB]-\'a\'+26;\r\n			}\r\n			else\r\n			{\r\n				term=b[nowB]-\'A\';\r\n			}\r\n			while (mark[term])\r\n			{\r\n				for (i=place[term];i<taSize;i++)\r\n				{\r\n					b[bSize++]=table[i];\r\n					if (table[i]>=\'a\')\r\n					{\r\n						term=table[i]-\'a\'+26;\r\n					}\r\n					else\r\n					{\r\n						term=table[i]-\'A\';\r\n					}\r\n					if (mark[term])\r\n					{\r\n						mark[term]=false;\r\n					}\r\n				}\r\n				bCatch++;\r\n				taSize=place[term];\r\n				mark[term]=false;\r\n\r\n				nowB++;\r\n				turn--;\r\n				if (turn<=0)\r\n				{\r\n					break;\r\n				}\r\n				table[taSize++]=b[nowB];\r\n				if (b[nowB]>=\'a\')\r\n				{\r\n					term=b[nowB]-\'a\'+26;\r\n				}\r\n				else\r\n				{\r\n					term=b[nowB]-\'A\';\r\n				}\r\n			} \r\n			if (turn<=0)\r\n			{\r\n				break;\r\n			}\r\n			mark[term]=true;\r\n			place[term]=taSize-1;\r\n			nowB++;\r\n			turn--;\r\n			if (nowB>=bSize)\r\n			{\r\n				cout<<\"A\"<<\" \"<<aCatch<<\" \"<<bCatch<<endl;\r\n				gameOver=true;\r\n				break;\r\n			}\r\n		}\r\n		if (!gameOver)\r\n		{\r\n			cout<<\"What a bad game!\"<<endl;\r\n		}\r\n	}\r\n	//system(\"pause\");\r\n	return 0;\r\n}'),(516,'#include <iostream>\r\n#include <stdio.h>\r\n#include <string.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int nCase,kind,turn;\r\n	int aSize,bSize,taSize,nowA,nowB,aCatch,bCatch;\r\n	char a[2500],b[2500],table[60];\r\n	bool mark[52],gameOver=false;\r\n	int i,term,place[52];\r\n	cin>>nCase;\r\n	while(nCase--)\r\n	{\r\n		cin>>kind;\r\n		scanf(\"%s%s\",a,b);\r\n		memset(mark ,false,sizeof(mark));\r\n		bSize=kind*2;\r\n		aSize=bSize;\r\n		aCatch=0;\r\n		bCatch=0;\r\n		taSize=0;\r\n		nowA=0;\r\n		nowB=0;\r\n		turn=2000;\r\n		while (turn>0)\r\n		{\r\n			table[taSize++]=a[nowA];\r\n			if (a[nowA]>=\'a\')\r\n			{\r\n				term=a[nowA]-\'a\'+26;\r\n			}\r\n			else\r\n			{\r\n				term=a[nowA]-\'A\';\r\n			}\r\n			while(mark[term])\r\n			{\r\n				for (i=place[term];i<taSize;i++)\r\n				{\r\n					a[aSize++]=table[i];\r\n					if (table[i]>=\'a\')\r\n					{\r\n						term=table[i]-\'a\'+26;\r\n					}\r\n					else\r\n					{\r\n						term=table[i]-\'A\';\r\n					}\r\n					if (mark[term])\r\n					{\r\n						mark[term]=false;\r\n					}\r\n				}\r\n				aCatch++;\r\n				taSize=place[term];\r\n				mark[term]=false;\r\n\r\n				turn--;\r\n				if (turn<=0)\r\n				{\r\n					break;\r\n				}\r\n				nowA++;\r\n				table[taSize++]=a[nowA];\r\n				if (a[nowA]>=\'a\')\r\n				{\r\n					term=a[nowA]-\'a\'+26;\r\n				}\r\n				else\r\n				{\r\n					term=a[nowA]-\'A\';\r\n				}\r\n			} \r\n			if (turn<=0)\r\n			{\r\n				break;\r\n			}\r\n			mark[term]=true;\r\n			place[term]=taSize-1;\r\n			nowA++;\r\n			turn--;\r\n			if (nowA>=aSize)\r\n			{\r\n				cout<<\"B\"<<\" \"<<aCatch<<\" \"<<bCatch<<endl;\r\n				gameOver=true;\r\n				break;\r\n			}\r\n			if (turn<=0)\r\n			{\r\n				break;\r\n			}\r\n\r\n			table[taSize++]=b[nowB];\r\n			if (b[nowB]>=\'a\')\r\n			{\r\n				term=b[nowB]-\'a\'+26;\r\n			}\r\n			else\r\n			{\r\n				term=b[nowB]-\'A\';\r\n			}\r\n			while (mark[term])\r\n			{\r\n				for (i=place[term];i<taSize;i++)\r\n				{\r\n					b[bSize++]=table[i];\r\n					if (table[i]>=\'a\')\r\n					{\r\n						term=table[i]-\'a\'+26;\r\n					}\r\n					else\r\n					{\r\n						term=table[i]-\'A\';\r\n					}\r\n					if (mark[term])\r\n					{\r\n						mark[term]=false;\r\n					}\r\n				}\r\n				bCatch++;\r\n				taSize=place[term];\r\n				mark[term]=false;\r\n\r\n				nowB++;\r\n				turn--;\r\n				if (turn<=0)\r\n				{\r\n					break;\r\n				}\r\n				table[taSize++]=b[nowB];\r\n				if (b[nowB]>=\'a\')\r\n				{\r\n					term=b[nowB]-\'a\'+26;\r\n				}\r\n				else\r\n				{\r\n					term=b[nowB]-\'A\';\r\n				}\r\n			} \r\n			if (turn<=0)\r\n			{\r\n				break;\r\n			}\r\n			mark[term]=true;\r\n			place[term]=taSize-1;\r\n			nowB++;\r\n			turn--;\r\n			if (nowB>=bSize)\r\n			{\r\n				cout<<\"A\"<<\" \"<<aCatch<<\" \"<<bCatch<<endl;\r\n				gameOver=true;\r\n				break;\r\n			}\r\n		}\r\n		if (!gameOver)\r\n		{\r\n			cout<<\"What a bad game!\"<<endl;\r\n		}\r\n	}\r\n	//system(\"pause\");\r\n	return 0;\r\n}'),(517,'#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\n#include <string>\r\n#include <queue>\r\nusing namespace std;\r\nstruct node\r\n{\r\n    int x,y;\r\n};\r\nint n,m;\r\nqueue<node> q;\r\nint d[8][2]={0,-1,-1,-1,-1,0,-1,1,0,1,1,1,1,0,1,-1};\r\nchar s[30][30];\r\nvoid solve(int xx,int yy)\r\n{\r\n    //if(s[i][j]==\'O\') { ans++; s[i][j]=\'.\';}\r\n    node tem;\r\n    int ans=0;\r\n    tem.x=xx;tem.y=yy;q.push(tem);\r\n    while(!q.empty())\r\n    {\r\n        tem = q.front();q.pop();\r\n        if(s[tem.x][tem.y]==\'O\') ans++;\r\n        s[tem.x][tem.y]=\'.\';\r\n        for(int i=0;i<8;i++)\r\n        {\r\n            int x=tem.x+d[i][0];\r\n            int y=tem.y+d[i][1];\r\n            if(x>=1&&x<=n&&y>=1&&y<=m&&s[x][y]!=\'.\')\r\n            {\r\n                node tt;\r\n                tt.x=x;tt.y=y;\r\n                q.push(tt);\r\n               // s[x][y]=\'.\';\r\n            }\r\n        }\r\n    }\r\n    cout<<ans<<endl;\r\n}\r\nint main()\r\n{\r\n    int x,y;\r\n    while(cin>>n>>m>>x>>y && n+m+x+y){\r\n    for(int i=1;i<=n;i++)\r\n    for(int j=1;j<=m;j++)\r\n    cin>>s[i][j];\r\n    solve(x,y);\r\n    }\r\n    return 0;\r\n}'),(518,'#include <iostream>\r\nusing namespace std;\r\nchar a[105][105];\r\nbool used[105][105];\r\nint sum;\r\nint d[8][2]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\r\nint m,n;\r\nvoid dfs(int i,int j)\r\n{\r\n	if (a[i][j] == \'O\')\r\n	{\r\n		sum++;\r\n	}\r\n	used[i][j]=1;\r\n	int k;\r\n	for (k=0;k<8;k++)\r\n	{\r\n		int ii=i+d[k][0];\r\n		int jj=j+d[k][1];\r\n		if (ii>=1&&ii<=n&&jj>=1&&jj<=m&&!used[ii][jj]&&a[ii][jj]!=\'.\')\r\n		{\r\n			dfs(ii,jj);\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n	//freopen(\"input.in\",\"r\",stdin);\r\n	//freopen(\"output.out\",\"w\",stdout);\r\n	int start_i,start_j;\r\n	while (cin>>n>>m>>start_i>>start_j&&(start_i+start_j+m+n))\r\n	{\r\n		sum=0;\r\n		int i,j;\r\n		memset(used,0,sizeof(used));\r\n		for (i=1;i<=n;i++)\r\n		{\r\n			for (j=1;j<=m;j++)\r\n			{\r\n				cin>>a[i][j];\r\n			}\r\n		}\r\n		dfs(start_i,start_j);\r\n		cout<<sum<<endl;\r\n	}\r\n	return 0;\r\n}'),(519,'#include <stdio.h>\n#include <string.h>\n\nchar func[10000][100];\n\nvoid strSort(int n){\n	int i,j,k;\n	char tmp[100];\n	for(i=0;i<n;i++){\n		k = i;\n		for(j=i+1;j<n;j++){\n			if(strcmp(func[k],func[j]) > 0){\n				k = j;\n			}\n		}\n		if(k != i){\n			strcpy(tmp,func[i]);\n			strcpy(func[i],func[k]);\n			strcpy(func[k],tmp);\n		}\n	}\n}\n\nvoid getFunc(char *str,int i){\n	int j = 0;\n	while(str[j++]){\n		if(str[j] == \'(\'){\n			str[j] = 0;\n			if(strlen(str)){\n				strcpy(func[i],str);\n			}\n			break;\n		}\n	}\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n	freopen(\"in\",\"r\",stdin);\n#endif\n\n	char str[10000];\n	int i=0,j;\n	while(gets(str)){\n		getFunc(str,i++);\n	}\n\n	strSort(i);\n	strcpy(func[i],\"#\");\n\n	for(j=0;j<i;j++){\n		if(strcmp(func[j],func[j+1])){\n			puts(func[j]);\n		}\n	}\n\n	return 0;\n}\n'),(520,'#include <stdio.h>\n#include <string.h>\n\nchar func[10000][100];\n\nvoid strSort(int n){\n	int i,j,k;\n	char tmp[100];\n	for(i=0;i<n;i++){\n		k = i;\n		for(j=i+1;j<n;j++){\n			if(strcmp(func[k],func[j]) > 0){\n				k = j;\n			}\n		}\n		if(k != i){\n			strcpy(tmp,func[i]);\n			strcpy(func[i],func[k]);\n			strcpy(func[k],tmp);\n		}\n	}\n}\n\nvoid getFunc(char *str,int i){\n	int j = 0;\n	while(str[j++]){\n		if(str[j] == \'(\'){\n			str[j] = 0;\n			if(strlen(str)){\n				strcpy(func[i],str);\n			}\n			break;\n		}\n	}\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n	freopen(\"in\",\"r\",stdin);\n#endif\n\n	char str[10000];\n	int i=0,j;\n	while(gets(str)){\n		getFunc(str,i++);\n	}\n\n	strSort(i);\n	strcpy(func[i],\"#\");\n\n	for(j=0;j<i;j++){\n		if(strcmp(func[j],func[j+1])){\n			puts(func[j]);\n		}\n	}\n\n	return 0;\n}\n'),(521,'#include<stdio.h>\r\n#include<math.h>\r\nint fond(int num)\r\n{\r\n	int result=1;\r\n	if(num<5)\r\n		return num;\r\n	while(num)\r\n	{\r\n		if(num/3>=1)\r\n		{\r\n			result*=3;\r\n			num-=3;\r\n			if(num==4)\r\n				return result*4;\r\n		}\r\n		else\r\n		{\r\n			result*=2;\r\n			num-=2;\r\n		}\r\n		if(num<0)\r\n			break;\r\n	}\r\n	return result;\r\n}\r\nint main()\r\n{\r\n	int num;\r\n	while(scanf(\"%d\",&num)!=EOF)\r\n	{\r\n		if(num==0)\r\n			break;\r\n		printf(\"%d\\n\",fond(num));\r\n	}\r\n	return 0;\r\n}'),(522,'#include<stdio.h>\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int a[60],n,i;\r\n    a[1]=1;\r\n    a[2]=2;\r\n    a[3]=3;\r\n    for(i=4;i<=58;i++)\r\n    {\r\n        a[i]=2*a[i-2]>3*a[i-3]?2*a[i-2]:3*a[i-3];\r\n    }\r\n    while(scanf(\"%d\",&n)!=EOF)\r\n    {\r\n        if(n==0)break;\r\n        printf(\"%d\\n\",a[n]);\r\n    }\r\n    return 0;\r\n}\r\n'),(523,'#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	//freopen(\"input.in\",\"r\",stdin);\r\n	//freopen(\"output.out\",\"w\",stdout);\r\n	int ma=0,mi=1,mid;\r\n	int n,k;\r\n	while (cin>>n>>k&&(n+k))\r\n	{\r\n		int a[100005];\r\n		int i;\r\n		for (i=0;i<n;i++)\r\n		{\r\n			scanf(\"%d\",a+i);\r\n			if (a[i]>mi)\r\n			{\r\n				mi=a[i];\r\n			}\r\n			ma+=a[i];\r\n		}\r\n		//cout<<ma<<endl;\r\n		while (ma>mi)\r\n		{\r\n			mid=(ma+mi)/2;\r\n			int sum=0,d=1;\r\n			for (i=0;i<n;i++)\r\n			{\r\n				if (sum+a[i]<=mid)\r\n				{\r\n					sum+=a[i];\r\n				}\r\n				else\r\n				{\r\n					sum=a[i];\r\n					d++;\r\n				}\r\n			}\r\n			if (d<=k)\r\n			{\r\n				ma=mid-1;\r\n			}\r\n			else\r\n			{\r\n				mi=mid+1;\r\n			}\r\n		}\r\n		cout<<mi<<endl;\r\n	}\r\n	return 0;\r\n}'),(524,'#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	//freopen(\"input.in\",\"r\",stdin);\r\n	//freopen(\"output.out\",\"w\",stdout);\r\n	int ma=0,mi=1,mid;\r\n	int n,k;\r\n	while (cin>>n>>k&&(n+k))\r\n	{\r\n		int a[100005];\r\n		int i;\r\n		for (i=0;i<n;i++)\r\n		{\r\n			scanf(\"%d\",a+i);\r\n			if (a[i]>mi)\r\n			{\r\n				mi=a[i];\r\n			}\r\n			ma+=a[i];\r\n		}\r\n		//cout<<ma<<endl;\r\n		while (ma>mi)\r\n		{\r\n			mid=(ma+mi)/2;\r\n			int sum=0,d=1;\r\n			for (i=0;i<n;i++)\r\n			{\r\n				if (sum+a[i]<=mid)\r\n				{\r\n					sum+=a[i];\r\n				}\r\n				else\r\n				{\r\n					sum=a[i];\r\n					d++;\r\n				}\r\n			}\r\n			if (d<=k)\r\n			{\r\n				ma=mid-1;\r\n			}\r\n			else\r\n			{\r\n				mi=mid+1;\r\n			}\r\n		}\r\n		cout<<mi<<endl;\r\n	}\r\n	return 0;\r\n}'),(525,'#include<stdio.h>\r\nint main(){\r\n	int x,y;\r\n	scanf(\"%d %d\",&x,&y);\r\n	printf(\"%d\",x+y);\r\n	return 0;\r\n}\r\n'),(526,'main(a,b){while(~scanf(\"%d%d\",&a,&b))printf(\"%d\\n\",a+b);}'),(527,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<algorithm>\r\n#define num a\r\n#define m n\r\nusing namespace std;\r\nint a[15000];\r\nvoid is(int ans)\r\n{\r\n	if(ans==2)\r\n	{\r\n		printf(\"YES\\n\");\r\n		return;\r\n	}\r\n	int i,t;\r\n	t=0;\r\n	for(i=2;i*i<=ans;i++)\r\n		if(ans%i==0)\r\n		{\r\n			t=1;\r\n			break;\r\n		}\r\n	if(t==0)\r\n		printf(\"YES\\n\");\r\n	else\r\n		printf(\"NO\\n\");\r\n	return;\r\n}\r\nint main()\r\n{\r\n	memset(a,0,sizeof(a));\r\n	int n,k;\r\n	scanf(\"%d%d\",&n,&k);\r\n	int i;\r\n	for(i=0;i<n;i++)\r\n		scanf(\"%d\",&a[i]);\r\n	sort(a,a+n);\r\n	\r\n	int kmax,kmin;\r\n	kmin=a[k-1];\r\n	kmax=a[n-k];\r\n	int ans=kmax-kmin;\r\n	if(ans<2)\r\n		printf(\"NO\\n\");\r\n	else \r\n		is(ans);\r\n	printf(\"%d\\n\",ans);\r\n	return 0;\r\n} '),(528,'#include<cstdio>\r\n#include<iostream>\r\n#include<algorithm>\r\n#include<cmath>\r\nusing namespace std;\r\nbool is(int x){\r\n	for(int i=2;i<=sqrt(x);i++){\r\n		if(x%i==0)return false;\r\n	}\r\n	return true;\r\n}\r\nint main(){\r\n	int a[10005];\r\n	int n,k;\r\n	cin>>n>>k;\r\n	for(int i=0;i<n;i++){\r\n		cin>>a[i];\r\n	}\r\n	sort(a,a+n);\r\n	int m;\r\n	m=a[n-k]-a[k-1];\r\n	if(m<2)cout<<\"NO\"<<endl;\r\n	else{\r\n		if(is(m))cout<<\"YES\"<<endl;\r\n		else cout<<\"NO\"<<endl;\r\n	}\r\n	cout<<m;\r\n}'),(529,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\ntypedef struct peo\r\n{\r\n    char n[50];\r\n    int a,b,e,w,t;\r\n    char c,d;\r\n}peo;\r\nbool cmp(peo x,peo y)\r\n{\r\n    if(x.w==y.w)\r\n        return x.t<y.t;\r\n    else\r\n        return x.w>y.w;\r\n}\r\nint main()\r\n{\r\n    peo p[100];\r\n    int sum=0;\r\n    int i,n;\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n    {\r\n        p[i].a=p[i].b=p[i].e=0;\r\n        p[i].t=i;\r\n        p[i].w=0;\r\n        scanf(\"%s%d%d\\n%c\\n%c%d\",p[i].n,&p[i].a,&p[i].b,&p[i].c,&p[i].d,&p[i].e);\r\n        if(p[i].a>80 && p[i].e>0)\r\n            p[i].w+=8000;\r\n        if(p[i].a>85 && p[i].b>80)\r\n            p[i].w+=4000;\r\n        if(p[i].a>90)\r\n            p[i].w+=2000;\r\n        if(p[i].a>85 && p[i].d==\'Y\')\r\n            p[i].w+=1000;\r\n        if(p[i].b>80 && p[i].c==\'Y\')\r\n            p[i].w+=850;\r\n        sum+=p[i].w;\r\n    }\r\n    sort(p,p+n,cmp);\r\n    printf(\"%s\\n%d\\n%d\\n\",p[0].n,p[0].w,sum);\r\n    return 0;\r\n}'),(530,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\ntypedef struct peo\r\n{\r\n    char n[50];\r\n    int a,b,e,w,t;\r\n    char c,d;\r\n}peo;\r\nbool cmp(peo x,peo y)\r\n{\r\n    if(x.w==y.w)\r\n        return x.t<y.t;\r\n    else\r\n        return x.w>y.w;\r\n}\r\nint main()\r\n{\r\n    peo p[100];\r\n    int sum=0;\r\n    int i,n;\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n    {\r\n        p[i].a=p[i].b=p[i].e=0;\r\n        p[i].t=i;\r\n        p[i].w=0;\r\n        scanf(\"%s%d%d\\n%c\\n%c%d\",p[i].n,&p[i].a,&p[i].b,&p[i].c,&p[i].d,&p[i].e);\r\n        if(p[i].a>80 && p[i].e>0)\r\n            p[i].w+=8000;\r\n        if(p[i].a>85 && p[i].b>80)\r\n            p[i].w+=4000;\r\n        if(p[i].a>90)\r\n            p[i].w+=2000;\r\n        if(p[i].a>85 && p[i].d==\'Y\')\r\n            p[i].w+=1000;\r\n        if(p[i].b>80 && p[i].c==\'Y\')\r\n            p[i].w+=850;\r\n        sum+=p[i].w;\r\n    }\r\n    sort(p,p+n,cmp);\r\n    printf(\"%s\\n%d\\n%d\\n\",p[0].n,p[0].w,sum);\r\n    return 0;\r\n}'),(531,' #include<stdio.h>\r\n  int main(void)\r\n  {  int i,m,t,u,f,d,sum=0,t1=0;\r\n   char ch;\r\n   scanf(\"%d%d%d%d%d\\n\",&m,&t,&u,&f,&d);\r\n   for (i=1;i<=t;i++)\r\n   { scanf(\"%c\\n\",&ch);\r\n    if (ch==\'u\')\r\n    if ((sum+u+d)<=m)\r\n    {  sum=sum+u+d;  t1++;  }\r\n    else break;  if (ch==\'d\')  if ((sum+u+d)<=m)\r\n     {  sum=sum+u+d; t1++;  } else break;  if (ch==\'f\')\r\n       if ((sum+2*f)<=m)\r\n       {  sum=sum+2*f;  t1++; }\r\n       else break;  }  printf(\"%d\",t1);\r\n        return 0;  }\r\n'),(532,' #include<stdio.h>\r\n  int main(void)\r\n  {  int i,m,t,u,f,d,sum=0,t1=0;\r\n   char ch;\r\n   scanf(\"%d%d%d%d%d\\n\",&m,&t,&u,&f,&d);\r\n   for (i=1;i<=t;i++)\r\n   { scanf(\"%c\\n\",&ch);\r\n    if (ch==\'u\')\r\n    if ((sum+u+d)<=m)\r\n    {  sum=sum+u+d;  t1++;  }\r\n    else break;  if (ch==\'d\')  if ((sum+u+d)<=m)\r\n     {  sum=sum+u+d; t1++;  } else break;  if (ch==\'f\')\r\n       if ((sum+2*f)<=m)\r\n       {  sum=sum+2*f;  t1++; }\r\n       else break;  }  printf(\"%d\",t1);\r\n        return 0;  }\r\n'),(533,'#include <iostream>  \r\n#include <cstdlib>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\nint A[100+10][100+10];\r\nint D[100+10][100+10];\r\nint r,c;\r\nint dp(int i,int j)\r\n{\r\n    int &ans=D[i][j];\r\n    if(ans>0) return ans;\r\n    ans=1;\r\n    if(i!=1&&A[i][j]>A[i-1][j]&&ans<dp(i-1,j)+1)  ans=dp(i-1,j)+1;\r\n    if(j!=1&&A[i][j]>A[i][j-1]&&ans<dp(i,j-1)+1)  ans=dp(i,j-1)+1;\r\n    if(i!=r&&A[i][j]>A[i+1][j]&&ans<dp(i+1,j)+1)  ans=dp(i+1,j)+1;\r\n    if(j!=c&&A[i][j]>A[i][j+1]&&ans<dp(i,j+1)+1)  ans=dp(i,j+1)+1;\r\n    return ans;\r\n}    \r\nint main ()\r\n{\r\n    scanf(\"%d%d\",&r,&c);\r\n    memset(A,0,sizeof(A));\r\n    memset(D,0,sizeof(D));\r\n    for(int i=1;i<=r;i++)\r\n    for(int j=1;j<=c;j++)\r\n    scanf(\"%d\",&A[i][j]);\r\n    for(int i=1;i<=r;i++)\r\n    for(int j=1;j<=c;j++)\r\n    dp(i,j);\r\n    int max=D[1][1];\r\n    for(int i=1;i<=r;i++)\r\n    for(int j=1;j<=c;j++)\r\n    if(max<D[i][j])  max=D[i][j];\r\n    cout<<max<<endl;\r\n    return 0;\r\n} '),(534,'#include <iostream>  \r\n#include <cstdlib>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\nint A[100+10][100+10];\r\nint D[100+10][100+10];\r\nint r,c;\r\nint dp(int i,int j)\r\n{\r\n    int &ans=D[i][j];\r\n    if(ans>0) return ans;\r\n    ans=1;\r\n    if(i!=1&&A[i][j]>A[i-1][j]&&ans<dp(i-1,j)+1)  ans=dp(i-1,j)+1;\r\n    if(j!=1&&A[i][j]>A[i][j-1]&&ans<dp(i,j-1)+1)  ans=dp(i,j-1)+1;\r\n    if(i!=r&&A[i][j]>A[i+1][j]&&ans<dp(i+1,j)+1)  ans=dp(i+1,j)+1;\r\n    if(j!=c&&A[i][j]>A[i][j+1]&&ans<dp(i,j+1)+1)  ans=dp(i,j+1)+1;\r\n    return ans;\r\n}    \r\nint main ()\r\n{\r\n    scanf(\"%d%d\",&r,&c);\r\n    memset(A,0,sizeof(A));\r\n    memset(D,0,sizeof(D));\r\n    for(int i=1;i<=r;i++)\r\n    for(int j=1;j<=c;j++)\r\n    scanf(\"%d\",&A[i][j]);\r\n    for(int i=1;i<=r;i++)\r\n    for(int j=1;j<=c;j++)\r\n    dp(i,j);\r\n    int max=D[1][1];\r\n    for(int i=1;i<=r;i++)\r\n    for(int j=1;j<=c;j++)\r\n    if(max<D[i][j])  max=D[i][j];\r\n    cout<<max<<endl;\r\n    return 0;\r\n} '),(535,'#include<iostream>\r\n#include<algorithm>\r\n#include<string>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n	 string  s2;\r\n	 int a[]={1,0,2,3,4,0,5,6,7,8,9};\r\n	 while(cin >>s2)\r\n	 {\r\n		 int sum=0;\r\n        for(int i=0;i<11;i++)\r\n			sum+=a[i]*(s2[i]-48);\r\n		sum%=11;\r\n		char c=\'X\';\r\n		if(sum<10) c=\'0\'+sum;\r\n		if(s2[12]==c)\r\n			s2=\"Right\";\r\n		else s2[12]=c;\r\n	 \r\n		cout<<s2<<endl;\r\n	 }\r\n}'),(536,'#include<iostream>\r\n#include<algorithm>\r\n#include<string>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n	 string  s2;\r\n	 int a[]={1,0,2,3,4,0,5,6,7,8,9};\r\n	 while(cin >>s2)\r\n	 {\r\n		 int sum=0;\r\n        for(int i=0;i<11;i++)\r\n			sum+=a[i]*(s2[i]-48);\r\n		sum%=11;\r\n		char c=\'X\';\r\n		if(sum<10) c=\'0\'+sum;\r\n		if(s2[12]==c)\r\n			s2=\"Right\";\r\n		else s2[12]=c;\r\n	 \r\n		cout<<s2<<endl;\r\n	 }\r\n}'),(537,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\nbool cmp(int a,int b)\r\n{\r\n    return a>b;\r\n}\r\nint main()\r\n{\r\n    int m,n,k,l,d;\r\n    scanf(\"%d%d%d%d%d\",&m,&n,&k,&l,&d);\r\n    int a[1500];\r\n    int b[1500];\r\n    memset(a,0,sizeof(a));\r\n    memset(b,0,sizeof(b));\r\n    int i;\r\n    for(i=1;i<=d;i++)\r\n    {\r\n        int xi,yi,pi,qi;\r\n        scanf(\"%d%d%d%d\",&xi,&yi,&pi,&qi);\r\n        if(xi==pi)\r\n        {\r\n            if(yi>qi)\r\n                a[qi]++;\r\n            else\r\n                a[yi]++;\r\n        }\r\n        else\r\n        {\r\n            if(xi>pi)\r\n                b[pi]++;\r\n            else\r\n                b[xi]++;\r\n        }\r\n    }\r\n    int a1[1500];\r\n    int b1[1500];\r\n    memset(a1,0,sizeof(a1));\r\n    memset(b1,0,sizeof(b1));\r\n    for(i=1;i<=k;i++)\r\n    {\r\n        int j;int w=0;int w1=0;\r\n        for(j=1;j<=m;j++)\r\n        {\r\n            if(b[j]>w)\r\n            {\r\n                w=b[j];\r\n                w1=j;\r\n            }\r\n        }\r\n        b1[i]=w1;\r\n        b[w1]=0;\r\n    }\r\n    for(i=1;i<=l;i++)\r\n    {\r\n        int j;int w=0;int w1=0;\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            if(a[j]>w)\r\n            {\r\n                w=a[j];\r\n                w1=j;\r\n            }\r\n        }\r\n        a1[i]=w1;\r\n        a[w1]=0;\r\n    }\r\n    sort(a1,a1+l+1,cmp);\r\n    sort(b1,b1+k+1,cmp);\r\n    for(i=k-1;i>0;i--)\r\n        printf(\"%d \",b1[i]);\r\n    printf(\"%d\\n\",b1[0]);\r\n    for(i=l-1;i>0;i--)\r\n        printf(\"%d \",a1[i]);\r\n    printf(\"%d\",a1[0]);\r\n    return 0;\r\n}'),(538,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\nbool cmp(int a,int b)\r\n{\r\n    return a>b;\r\n}\r\nint main()\r\n{\r\n    int m,n,k,l,d;\r\n    scanf(\"%d%d%d%d%d\",&m,&n,&k,&l,&d);\r\n    int a[1500];\r\n    int b[1500];\r\n    memset(a,0,sizeof(a));\r\n    memset(b,0,sizeof(b));\r\n    int i;\r\n    for(i=1;i<=d;i++)\r\n    {\r\n        int xi,yi,pi,qi;\r\n        scanf(\"%d%d%d%d\",&xi,&yi,&pi,&qi);\r\n        if(xi==pi)\r\n        {\r\n            if(yi>qi)\r\n                a[qi]++;\r\n            else\r\n                a[yi]++;\r\n        }\r\n        else\r\n        {\r\n            if(xi>pi)\r\n                b[pi]++;\r\n            else\r\n                b[xi]++;\r\n        }\r\n    }\r\n    int a1[1500];\r\n    int b1[1500];\r\n    memset(a1,0,sizeof(a1));\r\n    memset(b1,0,sizeof(b1));\r\n    for(i=1;i<=k;i++)\r\n    {\r\n        int j;int w=0;int w1=0;\r\n        for(j=1;j<=m;j++)\r\n        {\r\n            if(b[j]>w)\r\n            {\r\n                w=b[j];\r\n                w1=j;\r\n            }\r\n        }\r\n        b1[i]=w1;\r\n        b[w1]=0;\r\n    }\r\n    for(i=1;i<=l;i++)\r\n    {\r\n        int j;int w=0;int w1=0;\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            if(a[j]>w)\r\n            {\r\n                w=a[j];\r\n                w1=j;\r\n            }\r\n        }\r\n        a1[i]=w1;\r\n        a[w1]=0;\r\n    }\r\n    sort(a1,a1+l+1,cmp);\r\n    sort(b1,b1+k+1,cmp);\r\n    for(i=k-1;i>0;i--)\r\n        printf(\"%d \",b1[i]);\r\n    printf(\"%d\\n\",b1[0]);\r\n    for(i=l-1;i>0;i--)\r\n        printf(\"%d \",a1[i]);\r\n    printf(\"%d\",a1[0]);\r\n    return 0;\r\n}'),(539,'#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\nusing namespace std;\r\nint f[150][150];\r\nint t[150][150];\r\nint main()\r\n{\r\n    memset(f,0,sizeof(f));\r\n    memset(t,0,sizeof(t));\r\n    int i,j,k,n,r,m;\r\n    int time[150];\r\n    int rp[150];\r\n    int rmb[150];\r\n    memset(time,0,sizeof(time));\r\n    memset(rp,0,sizeof(rp));\r\n    memset(rmb,0,sizeof(rmb));\r\n    scanf(\"%d\",&n);\r\n    for(i=1;i<=n;i++)\r\n        scanf(\"%d%d%d\",&rmb[i],&rp[i],&time[i]);\r\n    scanf(\"%d%d\",&m,&r);\r\n    for(i=1;i<=n;i++)\r\n        for(j=m;j>=rmb[i];j--)\r\n            for(k=r;k>=rp[i];k--)\r\n            {\r\n                if(f[j-rmb[i]][k-rp[i]]+1>f[j][k])\r\n                {\r\n                    f[j][k]=f[j-rmb[i]][k-rp[i]]+1;\r\n                    t[j][k]=t[j-rmb[i]][k-rp[i]]+time[i];\r\n                }\r\n                else\r\n                {\r\n                    if((f[j-rmb[i]][k-rp[i]]+1==f[j][k]) && (t[j-rmb[i]][k-rp[i]]+time[i]<t[j][k]))\r\n                        t[j][k]=t[j-rmb[i]][k-rp[i]]+time[i];\r\n                }\r\n            }\r\n    int max=0;\r\n    int ans=10000000;\r\n    for(j=1;j<=m;j++)\r\n        for(k=1;k<=r;k++)\r\n        {\r\n            if(f[j][k]>max)\r\n            {\r\n                max=f[j][k];\r\n                ans=t[j][k];\r\n            }\r\n            else\r\n            {\r\n                if((f[j][k]==max) && (t[j][k]<ans))\r\n                    ans=t[j][k];\r\n            }\r\n        }\r\n    printf(\"%d\\n\",ans);\r\n    return 0;\r\n}'),(540,'\r\n#include\"stdio.h\"\r\nint n,m,r,time[110],rmb[110],rp[110],f[110][110],t[110][110];\r\nint main()\r\n{\r\n    int i,j,k,ans=100000;\r\n\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n       scanf(\"%d%d%d\",&rmb[i],&rp[i],&time[i]);\r\n    scanf(\"%d%d\",&m,&r);\r\n\r\n\r\n\r\n    for(k=0;k<n;k++)\r\n       for(i=m;i>=rmb[k];i--)\r\n           for(j=r;j>=rp[k];j--)\r\n             {\r\n             if (f[i][j]<f[i-rmb[k]][j-rp[k]]+1)                                 //优先满足MM人数\r\n                 {\r\n                 f[i][j]=f[i-rmb[k]][j-rp[k]]+1;\r\n                 t[i][j]=t[i-rmb[k]][j-rp[k]]+time[k];\r\n                 }\r\n             if (f[i][j]==f[i-rmb[k]][j-rp[k]]+1 && t[i][j] > t[i-rmb[k]][j-rp[k]]+time[k])              //能省时间，就省时间。\r\n                 {\r\n                 f[i][j]=f[i-rmb[k]][j-rp[k]]+1;\r\n                 t[i][j]=t[i-rmb[k]][j-rp[k]]+time[k];\r\n                 }\r\n             }\r\n\r\n\r\n    printf(\"%d\",t[m][r]);\r\n    return 0;\r\n}\r\n'),(541,'#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\nint main()\r\n\r\n{\r\n\r\n       int a[100], v, n, i, j, k, b[20001], t;\r\n\r\n       scanf(\"%d%d\", &v, &n);\r\n\r\n       for (i = 1; i <= n; i++)\r\n\r\n              scanf(\"%d\", &a[i]);\r\n\r\n       memset(b, 0, sizeof(b));\r\n\r\n       k = 0;\r\n\r\n       b[0] = 1;\r\n\r\n       for (i = 1; i <= n; i++)\r\n\r\n       {\r\n\r\n              t = k;\r\n\r\n              for (j = k; j >= 0; j--)\r\n\r\n                     if (b[j] == 1 && j + a[i] <= v)\r\n\r\n                     {\r\n\r\n                            b[j + a[i]] = 1;\r\n\r\n                            if (j + a[i] > t)\r\n\r\n                                   t = j + a[i];\r\n\r\n                     }\r\n\r\n              k = t;\r\n\r\n       }\r\n\r\n       printf(\"%d\\n\", v - k);\r\n\r\n       return 0;\r\n\r\n}\r\n'),(542,'#include<iostream>\r\nusing namespace std;\r\nint f[20001]={0};\r\nint a[31]={0};\r\nint main()\r\n{\r\n	int i,j,aa,bb;\r\n	while(cin>>aa )\r\n	{cin>>bb;\r\n	   memset(f,0,sizeof(int)*(aa+2));\r\n	   for(i=0;i<bb;i++)cin>>a[i];\r\n	for(i=0;i<bb;i++)\r\n	{\r\n		for(j=aa;j>=0;j--)\r\n		{\r\n			int x=f[j];\r\n			int y=0;\r\n			if(j-a[i]>=0)\r\n				y=f[j-a[i]]+a[i];\r\n			f[j]=x>y?x:y;\r\n		}; \r\n		 \r\n		\r\n	}cout<<aa-f[aa]<<endl;\r\n	}\r\n}\r\n\r\n  \r\n \r\n \r\n\r\n\r\n '),(543,'#include<iostream>\r\nusing namespace std;\r\nshort int root(short int s,short int * a)\r\n{       \r\n    if(a[s] == s)\r\n    {\r\n        return s;\r\n    }else\r\n    {\r\n        root(a[s],a);\r\n    }\r\n}\r\nshort int insamelink(short int s1, short int s2,short int *a)\r\n{\r\n    if(root(s1,a)==root(s2,a))\r\n    {\r\n        return 1;\r\n    }else\r\n  \r\n    {\r\n        return 0;\r\n    }\r\n}\r\nint main()\r\n{\r\n    short int n, m,s1,s2;\r\n    short int * a,i,result=0;\r\n    while(scanf(\"%hd%hd\",&n,&m)!=-1)\r\n    {result=0;\r\n    a = ( short int *)malloc((m+1)*sizeof( short int));\r\n    i=0;\r\n    while(i<=m)\r\n    {\r\n        a[i++]=-1;\r\n    }\r\n    i=0;\r\n    while(i<n)\r\n    {\r\n        scanf(\"%hd%hd\",&s1,&s2);\r\n        ++i;\r\n        if(a[s1]==-1)\r\n        {\r\n            if(a[s2]==-1)\r\n            {\r\n                a[s2] = s2;\r\n                a[s1] = s2;\r\n            }else\r\n            {\r\n                a[s1] = root(s2,a);\r\n            }\r\n                  \r\n          \r\n        }else\r\n        {\r\n            if(a[s2]==-1)\r\n            {\r\n                a[s2] =root(s1,a);  \r\n              \r\n            }else\r\n            {\r\n                if(insamelink(s2,s1,a))\r\n                {\r\n                    result++;\r\n                }else\r\n                {\r\n  \r\n                    a[root(s2,a)]=root(s1,a);\r\n                  \r\n                }\r\n            }\r\n        }\r\n    }\r\n    printf(\"%d\\n\",result);\r\n    free(a);\r\n    }\r\n    return 0;\r\n}'),(544,'#include<iostream>\r\n#include<set>\r\n#include<map>\r\nusing namespace std;\r\nint father[50002],a,b,m,n,p;\r\nint find(int x)\r\n{\r\nif(father[x]!=x)\r\nfather[x]=find(father[x]); \r\nreturn father[x];\r\n}\r\nint main(){\r\nint i,m,n,count;\r\nwhile(cin>>m>>n)\r\n{\r\n \r\nfor(i=1;i<=n;i++)\r\nfather[i]=i;\r\ncount=0;\r\nfor(i=1;i<=m;i++){\r\n  cin>>a>>b;\r\na=find(a);\r\nb=find(b);\r\nif(father[a]!=b)\r\nfather[a]=b;\r\nelse count++;\r\n}\r\ncout<<count<<endl;\r\n}\r\n}\r\n\r\n  \r\n \r\n \r\n\r\n\r\n '),(545,'\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	long long   a =1;\r\n	long long arr[30];\r\n	long long arr3[30];\r\n	int i ;\r\n	for(i =1; i <= 20; i++)\r\n	{\r\n		a*=i;\r\n\r\n		while(a % 10 ==0)\r\n		{\r\n			a/=10;\r\n		}\r\n		arr[i] = a;\r\n		//printf(\"arr[%d] == %I64d\\n\",i,arr[i]);\r\n	}\r\n	memcpy(arr3,arr,sizeof(arr));\r\n\r\n	int n,m,t,arr2[100];\r\n\r\n	cin>>n>>m;\r\n\r\n	int len =  (int)log10(arr3[n])+1;\r\n	if(len <= m)  cout<<arr3[n]<<endl;\r\n	else\r\n	{\r\n	  for(t =1; t<= m; t++)\r\n	 {\r\n		arr2[t] = arr[n]%10;\r\n	    arr[n] /= 10;\r\n	 }\r\n\r\n	  for(t = m; t >= 1; t--) cout<<arr2[t];\r\n\r\n	    cout<<endl;\r\n\r\n	}\r\n\r\n	return 0;\r\n\r\n}\r\n'),(546,'#include<iostream>\r\n#include<stack>\r\n#include<cmath>\r\nusing namespace std;\r\n \r\n  \r\nint main()\r\n{ \r\n  int m,n;\r\n  while(cin>>m>>n)\r\n  {\r\n	  int i=1;\r\n	  long long j=1;\r\n	  \r\n	  for(;i<=m;i++)\r\n	  { j*= i;if(j%10==0) j/=10;}\r\n	  stack<int> s;\r\n	  for(i=0;i<n&&j;i++)\r\n	  {s.push(j%10);j/=10;}\r\n	  while(!s.empty())\r\n      {cout<<s.top();s.pop();}cout<<endl;\r\n  }\r\n\r\n}\r\n \r\n\r\n\r\n '),(547,'#include <iostream>\r\n#include <algorithm>\r\n#include <cmath>\r\nusing namespace std;\r\nint cmp(int a,int b)\r\n{\r\n    return a>b;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int a[10005],b[10005];\r\n    cin>>n;\r\n    for(int i =0; i < n; i++)\r\n    {\r\n        cin>>a[i];\r\n    }\r\n     for(int i =0; i < n; i++)\r\n    {\r\n        cin>>b[i];\r\n    }\r\n    int cur =0;\r\n    sort(a,a+n);\r\n    sort(b,b+n,cmp);\r\n    for(int i = 0; i < n; i++)\r\n    {\r\n        cur+=abs(a[i] - b[i]);\r\n    }\r\n    cout<<cur<<endl;\r\n\r\n\r\n\r\n    return 0;\r\n}'),(548,'#include<iostream>\r\n#include<functional>\r\n#include<cmath>\r\n#include<algorithm>\r\nusing namespace std;\r\nint a[10001],b[10001];\r\nint n;\r\nmain()\r\n{\r\n  while(cin>>n)\r\n {\r\n   int i=0;\r\n   while(i<n)\r\n    cin>>a[i++];\r\n    i=0;\r\n    while(i<n)cin>>b[i++];\r\n    sort(a,a+n);\r\n    sort(b,b+n,greater<int>());\r\n    int s=0;\r\n    for(i=0;i<n;i++)\r\n     s+=abs(a[i]-b[i]);\r\n     cout<<s<<endl;\r\n  }\r\n}'),(549,'#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\nint a[20001]={0};\r\nint main()\r\n{\r\n	int i,j;\r\n   for(i=2;i<20001;i++)\r\n	   if(a[i]==0)\r\n		   for(j=2*i;j<20001;j+=i)\r\n		   {a[j]=i;}\r\n     int n;\r\n	 while(scanf(\"%d\",&n)!=-1)\r\n	 {\r\n		 int max=0;\r\n		 int max_index=0;\r\n		 int m;\r\n		 while(n--)\r\n		 {scanf(\"%d\",&m);\r\n		 int tmp=a[m]?a[m]:m;\r\n		 if(tmp>max){max=tmp;max_index=m;}\r\n		 }\r\n		 printf(\"%d\\n\",max_index);\r\n\r\n	 }\r\n}'),(550,'#include<stdio.h>\r\nint main()\r\n{\r\n	int n,i,m,j,k,max,a[5000];\r\n	scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n	{\r\n		scanf(\"%d\",&a[i]);\r\n	}\r\n	m=max=0;\r\n	for(i=0;i<n;i++)\r\n	{\r\n		k=a[i];\r\n		for(j=2;j<=k;j++)\r\n		{\r\n			 \r\n			while(k!=j)\r\n			{\r\n\r\n				if(k%j==0)\r\n				{\r\n					k=k/j;\r\n				}\r\n				else\r\n					break;\r\n			}\r\n		}\r\n		if(m<=k)\r\n		{\r\n			m=k;\r\n			max=i;\r\n		}\r\n	}\r\n	printf(\"%d\",a[max]);\r\n	return 0;\r\n}'),(551,'#include<cstdio>\r\n #include<algorithm>\r\nusing namespace std;\r\n int a[10001];\r\n \r\nint main()\r\n{\r\n	int n;\r\n   while(scanf(\"%d\",&n)!=-1)\r\n   {   \r\n	   int i=0,j;\r\n	   long long re=0;\r\n \r\n       while(i<n)\r\n	   {scanf(\"%d\",&a[i++]); }\r\n        sort(a,a+n);\r\n	   for(j=n-1,i=0;j>0;j-=2,i++)\r\n		   re+=(long long)(a[n-1-i]-a[0+i])*j;\r\n		re*=2;\r\n	   printf(\"%lld\\n\",re);\r\n   }\r\n	 \r\n}\r\n\r\n '),(552,'#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\nint main()\r\n{\r\n    long long n,a[10001];\r\n    long long ans=0;\r\n    cin>>n;\r\n    for(int i=1;i<=n;i++)\r\n		cin>>a[i];\r\n    sort(a+1,a+n+1);\r\n    for(int i=1;i<n;i++)\r\n	{\r\n		ans+=(a[i+1]-a[i])*i*(n-i);\r\n	}\r\n    cout<<ans*2;\r\n    return 0;\r\n}\r\n'),(553,'#include <cstdio>\r\n#include <cmath>\r\nint main()\r\n{\r\n    int a[33]={0};\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    if(n==0) printf(\"0\\n\");\r\n    else\r\n    {\r\n        int flag=0;\r\n        if(n>0) flag=0;\r\n        else flag=1,n=-n;\r\n        int i=1;\r\n        while(n)\r\n        {\r\n            if(n%2==0) n/=2,i*=2;\r\n            else if((int)log2(i)%2==flag) a[(int)(log2(i))]++,n/=2,i*=2;\r\n            else a[(int)(log2(i))]++,a[(int)(log2(i))+1]++,n/=2,i*=2;\r\n        }\r\n    }\r\n    for(int i=0;i<33;i++)\r\n    {\r\n        if(a[i]>1) a[i+1]+=a[i]/2,a[i+2]+=a[i]/2,a[i]=a[i]%2;\r\n    }\r\n    int flag=1;\r\n    for(int i=33;i>=0;i--)\r\n    {\r\n        if(flag)\r\n            if(a[i]==1) flag=0,printf(\"%d\",a[i]); else;\r\n        else printf(\"%d\",a[i]);\r\n    }\r\n    return 0;\r\n}\r\n'),(554,'#include<stdio.h>\r\n#include<math.h>\r\nvoid f(int n)\r\n{\r\n  int a[1111];\r\n  int len=0,i;\r\n  if(n==0){printf(\"0\\n\");return;}\r\n  while(n)\r\n  {\r\n    if(n%-2==-1)\r\n    {a[len++]=1;n/=-2;n++;}\r\n    else\r\n    {a[len++]=n%-2;n/=-2;}\r\n  }\r\n\r\nfor(i=len-1;i>=0;i--)\r\nprintf(\"%d\",a[i]);\r\nprintf(\"\\n\");}\r\nint main()\r\n{\r\n  int m;\r\n  while(scanf(\"%d\",&m)!=-1)\r\n  f(m);\r\n}\r\n'),(555,'\r\n\r\n\r\n\r\n#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int t;\r\n    int n;\r\n    int m;\r\n    int *d_i;\r\n    int **v;\r\n    cin >> n >> m;\r\n    d_i = new int[n];\r\n    for (int i = 0; i<n; i++)\r\n        cin >> d_i[i];\r\n    v = new int*[n + 1];\r\n    for (int i = 0; i<n + 1; i++)\r\n        v[i] = new int[m + 1];\r\n\r\n    for (int i = 0; i <= n; i++)\r\n    {\r\n        for (int j = 0; j <= m; j++)\r\n            v[i][j] = -1;\r\n    }\r\n    v[1][0] = 0;\r\n    v[1][1] = d_i[0];\r\n    for (int i = 2; i <= n; i++)\r\n    {\r\n        for (int j = 0; j <= m; j++)\r\n        {\r\n            if (j == 0)\r\n            {\r\n              if (v[i - 1][0]>v[i - 1][1])\r\n              v[i][j] = v[i][j]>v[i - 1][0] ? v[i][j] : v[i - 1][0];\r\n              else if (v[i - 1][0]<v[i - 1][1])\r\n              v[i][j] = v[i][j]>v[i - 1][1] ? v[i][j] : v[i - 1][1];\r\n            }\r\n            if (j >= 1 && j<=m)\r\n            {\r\n                if ((v[i - 1][j - 1] + d_i[i-1])>v[i][j])\r\n                    v[i][j] = v[i - 1][j - 1] + d_i[i-1];\r\n            }\r\n            if(i>=j)\r\n            {\r\n                v[i][0]=v[i][0]>v[i-j][j]?v[i][0]:v[i-j][j];\r\n            }\r\n                v[i][0] = v[i][0]>v[i - 1][0] ? v[i][0] : v[i - 1][0];\r\n\r\n\r\n        }\r\n    \r\n    }\r\n    cout << v[n][0]<<endl;\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n'),(556,'\r\n\r\n\r\n\r\n#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int t;\r\n    int n;\r\n    int m;\r\n    int *d_i;\r\n    int **v;\r\n    cin >> n >> m;\r\n    d_i = new int[n];\r\n    for (int i = 0; i<n; i++)\r\n        cin >> d_i[i];\r\n    v = new int*[n + 1];\r\n    for (int i = 0; i<n + 1; i++)\r\n        v[i] = new int[m + 1];\r\n\r\n    for (int i = 0; i <= n; i++)\r\n    {\r\n        for (int j = 0; j <= m; j++)\r\n            v[i][j] = -1;\r\n    }\r\n    v[1][0] = 0;\r\n    v[1][1] = d_i[0];\r\n    for (int i = 2; i <= n; i++)\r\n    {\r\n        for (int j = 0; j <= m; j++)\r\n        {\r\n            if (j == 0)\r\n            {\r\n              if (v[i - 1][0]>v[i - 1][1])\r\n              v[i][j] = v[i][j]>v[i - 1][0] ? v[i][j] : v[i - 1][0];\r\n              else if (v[i - 1][0]<v[i - 1][1])\r\n              v[i][j] = v[i][j]>v[i - 1][1] ? v[i][j] : v[i - 1][1];\r\n            }\r\n            if (j >= 1 && j<=m)\r\n            {\r\n                if ((v[i - 1][j - 1] + d_i[i-1])>v[i][j])\r\n                    v[i][j] = v[i - 1][j - 1] + d_i[i-1];\r\n            }\r\n            if(i>=j)\r\n            {\r\n                v[i][0]=v[i][0]>v[i-j][j]?v[i][0]:v[i-j][j];\r\n            }\r\n                v[i][0] = v[i][0]>v[i - 1][0] ? v[i][0] : v[i - 1][0];\r\n\r\n\r\n        }\r\n    \r\n    }\r\n    cout << v[n][0]<<endl;\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n'),(557,'#include <iostream>\r\n#include <string>\r\n#include <cstring>\r\nusing namespace std;\r\nint abc[27];\r\nstring s1,s2;\r\nint dp(int x,int y)\r\n{\r\nint num[256];\r\nint ans[256];\r\nint tmp=1;\r\nmemset(ans,0,sizeof(ans));\r\nmemset(num,0,sizeof(num));\r\nint l=y-x+1;\r\nfor(int i=x;i<=y;i++)\r\n{\r\nnum[i-x+1]=abc[s1[i]-\'a\'];\r\n}\r\nfor(int i=1;i<=l;i++)\r\n{\r\nans[i]=1;\r\nfor(int j=1;j<i;j++)\r\n{\r\nif(num[j]<=num[i])\r\n{\r\nans[i]=max(ans[j]+1,ans[i]);\r\ntmp=max(tmp,ans[i]);\r\n}\r\n}\r\n}\r\nreturn tmp;\r\n}\r\nint main()\r\n{\r\nchar c;\r\nint l=1,k=0,ans[256];\r\nfor(int i=1;i<=26;i++)\r\n{\r\ncin>>c;\r\nabc[c-\'a\']=i;\r\n}\r\ngetline(cin,s1);\r\ngetline(cin,s1);\r\nfor(int i=0;i<s1.size();i++)\r\n{\r\nif(s1[i]==\' \')\r\n{\r\nans[l++]=dp(k,i-1);\r\nk=i+1;\r\n}\r\n}\r\nans[l]=dp(k,s1.size()-1);\r\nfor(int i=1;i<=l;i++)\r\n{\r\ncout<<ans[i];\r\n}\r\nreturn 0;\r\n}'),(558,'#include <iostream>\r\n#include <string>\r\n#include <cstring>\r\nusing namespace std;\r\nint abc[27];\r\nstring s1,s2;\r\nint dp(int x,int y)\r\n{\r\nint num[256];\r\nint ans[256];\r\nint tmp=1;\r\nmemset(ans,0,sizeof(ans));\r\nmemset(num,0,sizeof(num));\r\nint l=y-x+1;\r\nfor(int i=x;i<=y;i++)\r\n{\r\nnum[i-x+1]=abc[s1[i]-\'a\'];\r\n}\r\nfor(int i=1;i<=l;i++)\r\n{\r\nans[i]=1;\r\nfor(int j=1;j<i;j++)\r\n{\r\nif(num[j]<=num[i])\r\n{\r\nans[i]=max(ans[j]+1,ans[i]);\r\ntmp=max(tmp,ans[i]);\r\n}\r\n}\r\n}\r\nreturn tmp;\r\n}\r\nint main()\r\n{\r\nchar c;\r\nint l=1,k=0,ans[256];\r\nfor(int i=1;i<=26;i++)\r\n{\r\ncin>>c;\r\nabc[c-\'a\']=i;\r\n}\r\ngetline(cin,s1);\r\ngetline(cin,s1);\r\nfor(int i=0;i<s1.size();i++)\r\n{\r\nif(s1[i]==\' \')\r\n{\r\nans[l++]=dp(k,i-1);\r\nk=i+1;\r\n}\r\n}\r\nans[l]=dp(k,s1.size()-1);\r\nfor(int i=1;i<=l;i++)\r\n{\r\ncout<<ans[i];\r\n}\r\nreturn 0;\r\n}'),(559,'#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n    int n, l, i;\r\n    char x[255];\r\n    scanf(\"%d\",&n);\r\n    for(i=1;i<=n;i++)\r\n    {\r\n        scanf(\"%s\",x);\r\n        l = strlen(x);\r\n        if (( x[l-1] - \'0\') & 1 ) printf(\"odd\\n\");\r\n        else printf(\"even\\n\");\r\n    }\r\n\r\n    return 0;\r\n}'),(560,'// Powered by PC GO\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main(){\r\n	int n;\r\n	scanf(\"%d\", &n);\r\n	for(n; n; n--){\r\n		char i[64];\r\n		scanf(\"%s\", i);\r\n		size_t len = strlen(i);\r\n		puts(i[len-1] % 2 ? \"odd\" : \"even\");\r\n	}\r\n	return n;\r\n}'),(561,'#include <stdio.h>     \r\n#include <math.h>     \r\nint f[100000]={0};     \r\nint sum[100000]={0};     \r\nvoid set()     \r\n{     \r\n    int i,j,s=0;     \r\n    for( i=2;i<=sqrt(100000);i++)     \r\n          if(f[i]==0)     \r\n    for(j=2*i;j<100000;j+=i)     \r\n            f[j]=1;     \r\n    for( i=2;i<100000;i++)     \r\n    {     \r\n        if(f[i]==0)     \r\n            s+=i;     \r\n        sum[i]=s;     \r\n    }     \r\n}     \r\nint main()     \r\n{     \r\n    int a,b;     \r\n    set();     \r\n    while(scanf(\"%d%d\",&a,&b)!=EOF)     \r\n    printf(\"%d\\n\",sum[b]-sum[a-1]);   \r\n    return 0;     \r\n}  '),(562,'#include<math.h>\r\n#include<stdio.h>\r\nint f[100000]={0};\r\nint sum[100000]={0};\r\nvoid set()\r\n{\r\nint i,j,s=0;\r\nfor( i=2;i<=sqrt(100000);i++)\r\nif(f[i]==0)\r\nfor(j=2*i;j<100000;j+=i)\r\nf[j]=1;\r\nfor( i=2;i<100000;i++)\r\n{	if(f[i]==0) s+=i;\r\n   sum[i]=s;\r\n}\r\n}\r\nint main()\r\n{	int a,b;\r\nset();\r\nwhile(scanf(\"%d%d\",&a,&b)!=-1)\r\n{\r\nprintf(\"%d\\n\",sum[b]-sum[a-1]);\r\n}\r\n}'),(563,'#include  <stdio.h>\r\nint f(int n,int r) \r\n\r\n{  \r\n	int count=0; \r\n	while(n) \r\n	{  \r\n		if(n%r==1)\r\n			count++; \r\n		n/=r; \r\n	}  	\r\n	return count; \r\n} \r\n int main() \r\n{  \r\n	int n,r;  \r\n	while(scanf(\"%d%d\",&n,&r)!=EOF) \r\n		printf(\"%d\\n\",f(n,r)); \r\n	return 0;\r\n}  '),(564,'#include<stdio.h>\r\nmain()\r\n{\r\n	int count,n,r;\r\n	while(scanf(\"%d%d\",&n,&r)!=-1)\r\n	{\r\n		count=0;\r\n		while(n)\r\n		{\r\n			if(n%r==1)count++;\r\n			n/=r;\r\n		}\r\n    printf(\"%d\\n\",count);\r\n	}\r\n}'),(565,'#include <stdio.h>\r\n#include <math.h>\r\nint gcd(int a,int b)\r\n{\r\n	return b?gcd(b,a%b):a;\r\n}\r\nvoid f(int x,int y,int *a,int *b)\r\n{\r\n	y*=gcd(x,y);\r\n	*a=(x-sqrt(x*x-4*y))/2;\r\n	*b=(x+sqrt(x*x-4*y))/2;\r\n}\r\nint main()\r\n{\r\n	int x,y,a,b;\r\n	while(scanf(\"%d%d\",&x,&y)!=EOF)\r\n	{\r\n		f(x,y,&a,&b);\r\n		printf(\"%d %d\\n\",a,b); \r\n	}\r\n	return 0;\r\n}'),(566,'#include<stdio.h>\r\nint main()\r\n{\r\n	int n,m,i;\r\n	while(scanf(\"%d%d\",&n,&m)!=-1)\r\n	{\r\n		if(n==0||m==0)\r\n			printf(\"%d %d\\n\",m,n);\r\n		else\r\n		{\r\n			for(i=n/2;i<=n;i++)\r\n				if(m%i==0&&m%(n-i)==0)\r\n				{\r\n					printf(\"%d %d\\n\",n-i,i);\r\n					break;\r\n				}\r\n		}\r\n	}\r\n	return 0;\r\n}'),(567,'#include<stdio.h>\r\nint main(){\r\n	int i;\r\n	float w,j;\r\n	while(scanf(\"%f %f\",&w,&j)!=EOF){\r\n	for(i=0;;i++){\r\n		if(w>j){break;}\r\n		w=w*1.1;\r\n	}\r\n	printf(\"%d\\n\",i);}\r\n	return 0;}'),(568,'#include<stdio.h>\r\nint main()\r\n{float a,b;\r\nwhile(scanf(\"%f%f\",&a,&b)!=EOF)\r\n{int i=0;while(a<=b){a*=1.1;i++;}printf(\"%d\\n\",i);\r\n}return 0;}\r\n\r\n	'),(569,'#include<stdio.h>\r\n#include<string.h>\r\nchar a[10000]={0};\r\nint main()\r\n{\r\n	int n,m,i,j=1,k;\r\n	char tmp[1000]={0};\r\n	char c;\r\n	scanf(\"%d%d\\n\",&n,&m);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		j=1;\r\n		scanf(\"%c %s\\n\",&c,tmp);\r\n		for(k=0;tmp[k];k++)\r\n			if(tmp[k]==\'0\') j*=2;\r\n			else j=j*2+1;\r\n		a[j]=c;	\r\n	}\r\n	for(i=0;i<m;i++)\r\n	{\r\n		j=1;\r\n		scanf(\"%s\",tmp);\r\n        for(k=0;tmp[k];k++)\r\n		{\r\n			if(tmp[k]==\'0\') j*=2;\r\n			else j=j*2+1;\r\n			if(a[j])\r\n			{\r\n				printf(\"%c\",a[j]);\r\n				j=1;\r\n			}			\r\n		}\r\n		printf(\"\\n\");\r\n	}\r\n}'),(570,'#include<stdio.h>\r\n#include<string.h>\r\nchar a[10000]={0};\r\nint main()\r\n{\r\n	int n,m,i,j=1,k;\r\n	char tmp[1000]={0};\r\n	char c;\r\n	scanf(\"%d%d\\n\",&n,&m);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		j=1;\r\n		scanf(\"%c %s\\n\",&c,tmp);\r\n		for(k=0;tmp[k];k++)\r\n			if(tmp[k]==\'0\') j*=2;\r\n			else j=j*2+1;\r\n		a[j]=c;	\r\n	}\r\n	for(i=0;i<m;i++)\r\n	{\r\n		j=1;\r\n		scanf(\"%s\",tmp);\r\n        for(k=0;tmp[k];k++)\r\n		{\r\n			if(tmp[k]==\'0\') j*=2;\r\n			else j=j*2+1;\r\n			if(a[j])\r\n			{\r\n				printf(\"%c\",a[j]);\r\n				j=1;\r\n			}			\r\n		}\r\n		printf(\"\\n\");\r\n	}\r\n}'),(571,'#include<stdio.h>\r\n#include<math.h>\r\n#include<string.h>\r\n#include<malloc.h>\r\n\r\nint f()\r\n{\r\n	int m,n;\r\n	int max=-1;\r\n	int**a;\r\n	int i,j;\r\n	int i0,j0=-100;\r\n	scanf(\"%d%d\",&m,&n);\r\n	a=(int**)malloc(sizeof(int*)*m);\r\n	for(i=0;i<m;i++)\r\n	{\r\n		a[i]=(int*)malloc(sizeof(int)*n);\r\n		memset(a[i],0,sizeof(int)*n);\r\n		\r\n	}\r\n	\r\n	for(i=0;i<m;i++)\r\n		for(j=0;j<n;j++)\r\n		{\r\n			scanf(\"%d\",&a[i][j]);\r\n			if(a[i][j]==-1)\r\n			{\r\n				i0=i;\r\n				j0=j;\r\n				a[i][j]=0;\r\n                if(i==m-1||j==n-1) max=0;\r\n				continue;\r\n			}\r\n			if(j0==-100||j<j0)continue;\r\n			if(a[i][j]==-2)continue;\r\n			\r\n			if(i==i0)\r\n			{\r\n				if(a[i][j-1]==-2)\r\n					a[i][j]=-2;\r\n				else\r\n					a[i][j]+=a[i][j-1];\r\n			}\r\n			else if(j==j0)\r\n			{\r\n				if(a[i-1][j]==-2)\r\n					a[i][j]=-2;\r\n				else\r\n					a[i][j]+=a[i-1][j];\r\n			}\r\n			else\r\n			{\r\n			if(a[i][j-1]==-2&&a[i-1][j]==-2) a[i][j]=-2; \r\n			else if(a[i][j-1]==-2) a[i][j]+=a[i-1][j];\r\n			else if(a[i-1][j]==-2) a[i][j]+=a[i][j-1];\r\n			else a[i][j]+=(a[i-1][j]>a[i][j-1]?a[i-1][j]:a[i][j-1]);\r\n			}\r\n			\r\n			if((i==m-1||j==n-1)&&a[i][j]>max)\r\n				max=a[i][j];\r\n		}\r\n\r\n	\r\n	for(i=0;i<m;i++)\r\n	{\r\n		free(a[i]);\r\n		}\r\n	free(a);\r\n	return max;\r\n\r\n}\r\n\r\n\r\nint main()\r\n{	\r\n	int N;\r\n	scanf(\"%d\",&N);\r\n	while(N--)\r\n	 printf(\"%d\\n\",f());\r\n}\r\n'),(572,'#include <stdio.h>\r\n#include <string.h>\r\nconst int dir[2][2]={{1,0},{0,1}};\r\nint maze[100][100];\r\nint result[100],k;\r\nint maze_n,maze_m,star_i,star_j;\r\nvoid dfs(int step_i,int step_j,int temp)\r\n{\r\n	int i,temp_i,temp_j;\r\n	if(step_i>=maze_n||step_j>=maze_m)\r\n	{\r\n		result[k++]=temp;\r\n		return ;\r\n	}\r\n	for(i=0;i<2;i++)\r\n	{\r\n		temp_i=step_i+dir[i][0],temp_j=step_j+dir[i][1];\r\n		if(maze[temp_i][temp_j]!=-2)\r\n		{\r\n			temp+=maze[temp_i][temp_j];\r\n			dfs(temp_i,temp_j,temp);\r\n			temp-=maze[temp_i][temp_j];\r\n		}\r\n	}\r\n}\r\nint fond_max()\r\n{\r\n	int max=-1,i;\r\n	for(i=0;i<k;i++)\r\n	{\r\n		if(result[i]>max)\r\n			max=result[i];\r\n	}\r\n	return max;\r\n}\r\nint main()\r\n{\r\n	int cases,i,j;\r\n	scanf(\"%d\",&cases);\r\n	while(cases--)\r\n	{\r\n		scanf(\"%d%d\",&maze_n,&maze_m);\r\n		memset(maze,0,sizeof(maze));\r\n		memset(result,-1,sizeof(result));\r\n		k=0;\r\n		for(i=0;i<maze_n;i++)\r\n		{\r\n			for(j=0;j<maze_m;j++)\r\n			{\r\n				scanf(\"%d\",&maze[i][j]);\r\n				if(maze[i][j]==-1)\r\n					star_i=i,star_j=j;\r\n			}\r\n		}\r\n		dfs(star_i,star_j,0);\r\n		printf(\"%d\\n\",fond_max());\r\n	}\r\n	return 0;\r\n}'),(573,'#include<stdio.h>\r\nint gcd(int a,int b)\r\n{\r\n    return b?gcd(b,a%b):a;\r\n}\r\nint g2(int a,int b)\r\n{\r\n    int x=gcd(a,b);\r\n    if(x==0)return 0;\r\n    return a*b/x;\r\n}\r\nint g3(int a,int b,int c)\r\n{\r\n    return g2(g2(a,b),c);\r\n}\r\nint fun(int a,int b,int c,int d,int e,int f,int g,int h)\r\n{\r\n    int g_abc=g3(a,c,e);\r\n    int g_ac=g2(a,c);\r\n    int g_ce=g2(c,e);\r\n    int g_ae=g2(a,e);\r\n    int ta=g_ce;\r\n    int tc=g_ae;\r\n    int te=g_ac;\r\n    int re;\r\n    while(ta%a!=1)ta+=g_ce;\r\n    while(tc%c!=1)tc+=g_ae;\r\n    while(te%e!=1)te+=g_ac;\r\n    re=ta*b+tc*d+te*f;\r\n    while(re<g) re+=g_abc;\r\n    while(re>h) re-=g_abc;\r\n    return re;\r\n     \r\n}\r\nint main()\r\n{\r\n  int a,b,c,d,e,f,g,h;\r\n  while(scanf(\"%d%d%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f,&g,&h)!=EOF)\r\n      printf(\"%d\\n\",fun(a,b,c,d,e,f,g,h));\r\n}'),(574,'#include<stdio.h>\r\nint main()\r\n{int a,b,c,d,e,f,g,h;	while(scanf(\"%d%d%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f,&g,&h)!=EOF)\r\n	{for(int i=g;i<=h;i++){if(i%a==b&&i%c==d&&i%e==f)printf(\"%d\\n\",i);}}return 0;}'),(575,'#include<stdio.h>\r\nstruct A \r\n{\r\n	int i,j;\r\n};\r\n\r\nstruct A f(int c,int k,int n,int i)\r\n{\r\n	int x=(c+k)*2-4;//计算最外层有几个马\r\nstruct A t;\r\n	if(x<n) return f(c-2,k-2,n-x,i+1);\r\n	if(n<=c) {t.i=1;t.j=n;}\r\n	else if(n<=c+k-1){t.i=n-c+1;t.j=c;} \r\n	else if(n<=c+k-1+c-1){t.i=k;t.j=c-n+(c+k-1);} \r\n	else {t.i=k-n+c+k-1+c-1;t.j=1;}  \r\n	t.i+=i;\r\n	t.j+=i;\r\n    return  t;\r\n}\r\nint main()\r\n{\r\n	int m,n,x;\r\n	while(scanf(\"%d%d%d\",&m,&n,&x)!=EOF)\r\n	{\r\n		int k=m/n;\r\n		int z=m/2+1;\r\n		struct A t;\r\n		if(m%n)k++;			\r\n		if(x==0) \r\n		{	\r\n			t=f(n,k,z,0);\r\n			printf(\"%d %d \",t.i,t.j);\r\n			t=f(n,k,m,0);\r\n			printf(\"%d %d\\n\",t.i,t.j);\r\n		}\r\n		else \r\n		{\r\n			t=f(k,n,z,0);\r\n			printf(\"%d %d \",t.j,t.i);\r\n			t=f(k,n,m,0);\r\n			printf(\"%d %d\\n\",t.j,t.i);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n'),(576,'#include<stdio.h>\r\nstruct A\r\n{\r\n	int i,j;\r\n};\r\n\r\nstruct A f(int c,int k,int n,int i)\r\n{\r\n	int x=(c+k)*2-4;struct A t;\r\n	if(x<n) return f(c-2,k-2,n-x,i+1);\r\n	\r\n	if(n<=c) {t.i=1;t.j=n;}\r\n	else if(n<=c+k-1){t.i=n-c+1;t.j=c;}\r\n	else if(n<=c+k-1+c-1){t.i=k;t.j=c-n+(c+k-1);}\r\n	else {t.i=k-n+c+k-1+c-1;t.j=1;}\r\n	t.i+=i;\r\n	t.j+=i;\r\n    return  t;\r\n}\r\nint main()\r\n{\r\n	int m,n,x;\r\n	while(scanf(\"%d%d%d\",&m,&n,&x)!=EOF)\r\n	{\r\n		int k=m/n;\r\n		int z=m/2+1;\r\n		struct A t;\r\n		if(m%n)k++;			\r\n		if(x==0)\r\n		{	\r\n			t=f(n,k,z,0);\r\n			printf(\"%d %d \",t.i,t.j);\r\n			t=f(n,k,m,0);\r\n			printf(\"%d %d\\n\",t.i,t.j);\r\n		}\r\n		else\r\n		{\r\n			t=f(k,n,z,0);\r\n			printf(\"%d %d \",t.j,t.i);\r\n			t=f(k,n,m,0);\r\n			printf(\"%d %d\\n\",t.j,t.i);\r\n		}\r\n	}\r\n	return 0;\r\n}'),(577,'#include<stdio.h>\r\n#include<malloc.h>\r\nstruct A\r\n{\r\n	char p[10];\r\n	int x;\r\n	int y;\r\n	int z;\r\n};\r\ntypedef struct A DataType;\r\n\r\nint less(DataType a,DataType b)\r\n{\r\n	int aa=a.x*a.x*a.x+a.y*a.y+a.z;\r\n	int bb=b.x*b.x*b.x+b.y*b.y+b.z;	\r\n	return aa>bb;\r\n}\r\n\r\nvoid merge(DataType* arr1,int len1,DataType* arr2,int len2,DataType* arr,int (*comp)(DataType,DataType))\r\n{\r\n	int i1=0,i2=0,i=0;\r\n	while(i1<len1||i2<len2)\r\n		if(i2>=len2||i1<len1&&!comp(arr2[i2],arr1[i1]))\r\n			arr[i++]=arr1[i1++];\r\n		else\r\n			arr[i++]=arr2[i2++];\r\n}\r\n\r\nvoid merge_sort(DataType* arr,unsigned len,int (*comp)(DataType,DataType))\r\n{\r\n	DataType* tmp_arr;\r\n	int int_len=(int)len;\r\n	int n=2,i;\r\n	if(len<=1) \r\n		return;\r\n	tmp_arr=(DataType*)malloc(sizeof(DataType)*len);\r\n	while(n/2<=int_len)\r\n	{\r\n		for(i=0;i<int_len;i+=n)\r\n			merge(arr+i,int_len-i<n/2?int_len-i:n/2,arr+i+n/2,int_len-i-n/2<n/2?int_len-i-n/2:n/2,tmp_arr+i,comp);\r\n		n*=2;\r\n		for(i=0;i<int_len;i+=n)\r\n			merge(tmp_arr+i,int_len-i<n/2?int_len-i:n/2,tmp_arr+i+n/2,int_len-i-n/2<n/2?int_len-i-n/2:n/2,arr+i,comp);\r\n		n*=2;\r\n	}	\r\n	free(tmp_arr);\r\n}\r\nint main()\r\n{\r\n	DataType arr[1000];\r\n	int N;int i=0;\r\n	scanf(\"%d\",&N);\r\n	\r\n	for(i=0;i<N;i++)\r\n	{\r\n		scanf(\"%s%d%d%d\",arr[i].p,&arr[i].x,&arr[i].y,&arr[i].z);\r\n	}\r\n    merge_sort(arr,N,less);\r\n	for(i=0;i<N;i++)\r\n		printf(\"%s %d\\n\",arr[i].p,arr[i].x*arr[i].x*arr[i].x+arr[i].y*arr[i].y+arr[i].z);\r\n	return 0;\r\n}\r\n'),(578,'#include<stdio.h>\r\ntypedef struct\r\n{\r\n	char s[20];\r\n	int x;\r\n}mumber;\r\nmumber e[120];\r\nint cmp(const void *a,const void *b)\r\n{\r\n	return   (*(mumber *)a).x<(*(mumber *)b).x;\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	int x,y,z;\r\n	int i;\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n;i++)\r\n		{\r\n		    scanf(\"%s%d%d%d\",e[i].s,&x,&y,&z);\r\n		    e[i].x=x*x*x+y*y+z;\r\n		}\r\n		qsort(e,n,sizeof(e[0]),cmp);\r\n		for(i=0;i<n;i++)\r\n		printf(\"%s %d\\n\",e[i].s,e[i].x);\r\n		return 0;\r\n}\r\n'),(579,'#include<stdio.h>\r\n#include<string.h>\r\nint a[1000][1000]={0};\r\n\r\nint get_count(int m,int n,int i,int j)\r\n\r\n{\r\n	\r\n	int count=0;\r\n	if(i<0||j<0||i>=m||j>=n)\r\n		return -1;\r\n	if(a[i][j]==0)\r\n		return 0;\r\n    ++count;\r\n	a[i][j]=2;\r\n	if(i-1>=0&&a[i-1][j]==1)\r\n		count+=get_count(m,n,i-1,j);\r\n	if(i+1<m&&a[i+1][j]==1)\r\n		count+=get_count(m,n,i+1,j);\r\n	if(j-1>=0&&a[i][j-1]==1)\r\n		count+=get_count(m,n,i,j-1);\r\n	if(j+1<n&&a[i][j+1]==1)\r\n		count+=get_count(m,n,i,j+1);\r\n	a[i][j]=1;\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int m,n,k,i,j,I;\r\n	scanf(\"%d\",&k);\r\n	while(k--)\r\n	{\r\n		scanf(\"%d%d%d\",&m,&n,&I);\r\n		for(i=0;i<m;i++)\r\n			for(j=0;j<n;j++)\r\n				scanf(\"%d\",&a[i][j]);\r\n		while(I--)\r\n		{\r\n			scanf(\"%d%d\",&i,&j);\r\n			printf(\"%d\\n\",get_count(m,n,i,j));\r\n		}\r\n\r\n	}\r\n	return 0;\r\n\r\n}\r\n'),(580,'#include<stdio.h>\r\nint a[500][500]={0};\r\nint get_count(int m,int n,int i,int j)\r\n{	int count=0;\r\n	if(i<0||j<0||i>=m||j>=n)\r\n		return -1;\r\n	if(a[i][j]==0)\r\n		return 0;\r\n    ++count;\r\n	a[i][j]=2;\r\n	if(i-1>=0&&a[i-1][j]==1)\r\n		count+=get_count(m,n,i-1,j);\r\n	if(i+1<m&&a[i+1][j]==1)\r\n		count+=get_count(m,n,i+1,j);\r\n	if(j-1>=0&&a[i][j-1]==1)\r\n		count+=get_count(m,n,i,j-1);\r\n	if(j+1<n&&a[i][j+1]==1)\r\n		count+=get_count(m,n,i,j+1);\r\n	a[i][j]=1;\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int m,n,k,i,j,I;\r\n	scanf(\"%d\",&k);\r\n	while(k--)\r\n	{\r\n		scanf(\"%d%d%d\",&m,&n,&I);\r\n		for(i=0;i<m;i++)\r\n			for(j=0;j<n;j++)\r\n				scanf(\"%d\",&a[i][j]);\r\n		while(I--)\r\n		{\r\n			scanf(\"%d%d\",&i,&j);\r\n			printf(\"%d\\n\",get_count(m,n,i,j));\r\n		}\r\n\r\n	}\r\n	return 0;\r\n\r\n}'),(581,'#include <iostream> \r\n#include <cmath> \r\n#include <cstdio> \r\n#include <cstring> \r\nusing namespace std; \r\nconst double inf=9999999.99; \r\nconst int maxm=35; \r\nstruct node \r\n{ \r\n    int x,y,z; \r\n}; \r\ndouble maze[maxm][maxm]; \r\nint n; \r\nvoid init() \r\n{ \r\n    for(int i=0;i<n;i++) \r\n    { \r\n        for(int j=0;j<n;j++) \r\n            maze[i][j]=inf; \r\n        maze[i][i]=0.0; \r\n    } \r\n} \r\ndouble prim() \r\n{ \r\n    bool vis[maxm]; \r\n    double dis[maxm]; \r\n    memset(vis,false,sizeof(vis)); \r\n    for(int i=0;i<n;i++) \r\n        dis[i]=maze[0][i]; \r\n    vis[0]=false; \r\n    double max,ans=0; \r\n    int x; \r\n    for(int k=0;k<n;k++) \r\n    { \r\n        max=inf,x=-1; \r\n        for(int i=0;i<n;i++) \r\n            if(!vis[i] && dis[i] < max) max=dis[x=i]; \r\n        if(x==-1) break; \r\n        vis[x]=true; \r\n        ans+=max; \r\n        for(int i=0;i<n;i++) \r\n            if(!vis[i] && dis[i] > maze[x][i]) dis[i]=maze[x][i]; \r\n    } \r\n    return ans; \r\n} \r\nint main() \r\n{ \r\n  //  freopen(\"in.txt\",\"r\",stdin); \r\n    int tc; \r\n    scanf(\"%d\",&tc); \r\n    while(tc--) \r\n    { \r\n        scanf(\"%d\",&n); \r\n        init(); \r\n        node* num=new node[n+1]; \r\n        for(int i=0;i<n;i++) \r\n            scanf(\"%d%d%d\",&num[i].x,&num[i].y,&num[i].z); \r\n        for(int i=0;i<n;i++) \r\n        { \r\n            for(int j=i+1;j<n;j++) \r\n            { \r\n                double tmp=sqrt((num[i].x-num[j].x)*(num[i].x-num[j].x)*1.0+(num[i].y-num[j].y)*(num[i].y-num[j].y)*1.0+(num[i].z-num[j].z)*(num[i].z-num[j].z)*1.0); \r\n                maze[i][j]=maze[j][i]=tmp; \r\n            } \r\n        } \r\n        printf(\"%.2lf\\n\",prim()); \r\n        delete []num; \r\n    } \r\n    return 0; \r\n}'),(582,'#include <stdio.h>\n#include <math.h>\n#include <queue>\n#include <memory.h>\nusing namespace std;\nstruct point\n{\n	int x,y,z;\n};\nstruct type\n{\n	int j;\n	double len;\n	friend bool operator <(type a,type b)\n	{\n		return a.len>b.len;\n	}\n};\ntype t,tt;\ninline int sqr(int num)\n{\n	return num*num;\n}\npoint p[31];\ndouble dis[31][31];\nbool visit[31];\nint main()\n{\n	int repeat,n,i,j,cur;\n	double sum;\n\n	scanf(\"%d\",&repeat);\n	while(repeat--)\n	{\n		scanf(\"%d\",&n);\n		for(i=0;i<n;i++)\n		{\n			scanf(\"%d%d%d\",&p[i].x,&p[i].y,&p[i].z);\n			for(j=0;j<n;j++)\n				dis[i][j]=dis[j][i]=sqrt( sqr(p[i].x-p[j].x)+sqr(p[i].y-p[j].y)+sqr(p[i].z-p[j].z));\n		}\n		sum=0;\n		cur=0;\n		memset(visit,false,sizeof(visit));\n		priority_queue<type> q;\n		for(i=0;i<n-1;i++)\n		{\n			visit[cur]=true;\n			for(j=0;j<n;j++)\n				if( !visit[j])\n				{\n					t.j=j;\n					t.len=dis[cur][j];\n					q.push(t);\n				}\n			while( !q.empty())\n			{\n				t=q.top();\n				q.pop();\n				if( !visit[t.j] ) break;\n			}\n			sum+=t.len;\n			cur=t.j;\n		}\n		printf(\"%.2f\\n\",sum);\n	}\n	return 0;\n}'),(583,'#include<stdio.h>\n#include<string.h>\nint main()\n\n{\n\n       int n,k;\n\n       scanf(\"%d\",&n);\n\n       for(k=0;k<n;k++)\n\n       {\n\n              char t[2000];\n              int a,b,i,j,l;\n              int x,y;\n              char map[32][33]={0};\n              scanf(\"%d %d\", &a,&b);\n              scanf(\"%s\", &t);\n              l=strlen(t)-1;\n              x=31-b;\n              y=a;\n              for(i=0;i<l;i++)\n              {\n                     if(t[i]==\'E\')\n                     {\n                            map[x+1][y+1]=\'X\';\n                            y++;\n                     }\n                     else if(t[i]==\'N\')\n                     {\n                            map[x][y+1]=\'X\';\n                            x--;\n                     }\n                     else if(t[i]==\'W\')\n                     {\n                            map[x][y]=\'X\';\n                            y--;\n                     }\n                     else if(t[i]==\'S\')\n                     {\n                            map[x+1][y]=\'X\';\n                            x++;\n                     }\n              }\n              printf(\"Bitmap #%d\\n\",k+1);\n              for(i=0;i<32;i++)\n              {\n                     for(j=1;j<33;j++)\n                     {\n                            if(map[i][j]!=\'X\')\n                                   map[i][j]=\'.\';\n                            printf(\"%c\",map[i][j]);\n                     }\n                     printf(\"\\n\");\n              }\n              printf(\"\\n\");\n       }\n       return 0;\n}\n'),(584,'#include<stdio.h>\n#include<string.h>\nint main()\n\n{\n\n       int n,k;\n\n       scanf(\"%d\",&n);\n\n       for(k=0;k<n;k++)\n\n       {\n\n              char t[2000];\n              int a,b,i,j,l;\n              int x,y;\n              char map[32][33]={0};\n              scanf(\"%d %d\", &a,&b);\n              scanf(\"%s\", &t);\n              l=strlen(t)-1;\n              x=31-b;\n              y=a;\n              for(i=0;i<l;i++)\n              {\n                     if(t[i]==\'E\')\n                     {\n                            map[x+1][y+1]=\'X\';\n                            y++;\n                     }\n                     else if(t[i]==\'N\')\n                     {\n                            map[x][y+1]=\'X\';\n                            x--;\n                     }\n                     else if(t[i]==\'W\')\n                     {\n                            map[x][y]=\'X\';\n                            y--;\n                     }\n                     else if(t[i]==\'S\')\n                     {\n                            map[x+1][y]=\'X\';\n                            x++;\n                     }\n              }\n              printf(\"Bitmap #%d\\n\",k+1);\n              for(i=0;i<32;i++)\n              {\n                     for(j=1;j<33;j++)\n                     {\n                            if(map[i][j]!=\'X\')\n                                   map[i][j]=\'.\';\n                            printf(\"%c\",map[i][j]);\n                     }\n                     printf(\"\\n\");\n              }\n              printf(\"\\n\");\n       }\n       return 0;\n}\n'),(585,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a[300],j,q,w,i,n;\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf(\"%d\",&a[i]);\r\n	}\r\n	for(j=0;j<n;j++)\r\n	{\r\n		if(a[j]%2==0&&a[j]%4!=0)\r\n		{\r\n			q=a[j]/4;\r\n			w=a[j]/2;\r\n			printf(\"%d %d\\n\",q+1,w);\r\n		}\r\n		else if(a[j]%4==0)\r\n		{\r\n			q=a[j]/4;\r\n			w=a[j]/2;\r\n			printf(\"%d %d\\n\",q,w);			\r\n		}\r\n		else\r\n		{\r\n			printf(\"%d %d\\n\",0,0);\r\n		}\r\n	}\r\n	return 0;\r\n}   '),(586,'#include <stdio.h>\r\nint main()\r\n{\r\n    int t,A;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        scanf(\"%d\",&A);\r\n        if(A&1) printf(\"0 0\\n\");\r\n        else printf(\"%d %d\\n\",A/4+(A%4)/2,A/2);\r\n    }\r\n    return 0;\r\n}\r\n'),(587,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\ntypedef pair<int,int> pii;\r\nconst int maxsize=10;\r\nchar maze[maxsize][maxsize];\r\ninline int ABS(int a)\r\n{\r\n    if(a > 0)\r\n        return a;\r\n    return a*-1;\r\n}\r\nint judge_row(const pii& point,char w)\r\n{\r\n    int star=point.second-2;\r\n    if(star < 0) star=0;\r\n    int end=point.second+2;\r\n    if(end > 7) end=7;\r\n    int count=0;\r\n    bool flag=false;\r\n    for(int i=star;i<=end;i++)\r\n    {\r\n        if(maze[point.first][i]==w)\r\n            count++;\r\n        else\r\n            count=0;\r\n        if(count > 2) flag=true;\r\n    }\r\n    if(flag) return 1;\r\n    return 0;\r\n}\r\nint judge_col(const pii& point,char w)\r\n{\r\n    int star=point.first-2;\r\n    if(star < 0) star=0;\r\n    int end=point.first+2;\r\n    if(end > 7) end=7;\r\n    int count=0;\r\n    bool flag=false;\r\n    for(int i=star;i<=end;i++)\r\n    {\r\n        if(maze[i][point.second]==w)\r\n            count++;\r\n        else\r\n            count=0;\r\n        if(count > 2) flag=true;\r\n    }\r\n    if(flag) return 1;\r\n    return 0;\r\n}\r\nint main()\r\n{\r\n    while(~scanf(\"%s\",maze[0]))\r\n    {\r\n        for(int i=1;i<8;i++)\r\n            scanf(\"%s\",maze[i]);\r\n        pii a,b;\r\n        scanf(\"%d%d%d%d\",&a.first,&a.second,&b.first,&b.second);\r\n        a.first--,b.first--;\r\n        a.second--,b.second--;\r\n        if(ABS(a.first-b.first) + ABS(a.second-b.second) != 1)\r\n        {\r\n            printf(\"Illegal move!\\n\");\r\n            continue;\r\n        }\r\n        if(maze[a.first][a.second]==maze[b.first][b.second])\r\n        {\r\n            printf(\"Illegal move!\\n\");\r\n            continue;\r\n        }\r\n        int ans=0;\r\n        char chtmp;\r\n        chtmp=maze[a.first][a.second];\r\n        maze[a.first][a.second]=maze[b.first][b.second];\r\n        maze[b.first][b.second]=chtmp;\r\n        ans+=judge_row(a,maze[a.first][a.second]);\r\n        ans+=judge_row(b,maze[b.first][b.second]);\r\n        ans+=judge_col(a,maze[a.first][a.second]);\r\n        ans+=judge_col(b,maze[b.first][b.second]);\r\n        if(ans)\r\n            printf(\"Ok!\\n\");\r\n        else\r\n            printf(\"Illegal move!\\n\");\r\n    }\r\n    return 0;\r\n}\r\n'),(588,'#include <stdio.h>\n#include <math.h>\nchar map[8][9];\nint ok(int i,int j,char ch)\n{\n	return i>=0&&j>=0&&i<8&&j<8&&ch==map[i][j];\n}\nint ok2(int i,int j)\n{\n		return i>=0&&j>=0&&i<8&&j<8;\n}\nint can(int si,int sj,int ei,int ej)\n{\n	return ok2(si,sj)&&ok2(ei,ej)&&( (si==ei&&fabs(sj-ej)==1) || (sj==ej&&fabs(si-ei)==1));\n}\nint amount(int si,int sj)\n{\n	int i,count=1;\n\n	for(i=1;;i++)\n		if( ok(si-i,sj,map[si][sj]) ) count++;\n		else break;\n	for(i=1;;i++)\n		if( ok(si+i,sj,map[si][sj]) ) count++;\n		else break;\n	if(count>2) return 1;\n	for(i=count=1;;i++)\n		if( ok(si,sj-i,map[si][sj]) ) count++;\n		else break;\n	for(i=1;;i++)\n		if( ok(si,sj+i,map[si][sj]) ) count++;\n		else break;\n	if(count>2) return 1;\n	else return 0;\n}\nint main()\n{\n	int i,si,sj,ei,ej;\n	char t;\n\n	while(scanf(\"%s\",map[0])!=EOF)\n	{\n		for(i=1;i<8;i++)\n			scanf(\"%s\",map[i]);\n		scanf(\"%d%d%d%d\",&si,&sj,&ei,&ej);\n		si--;sj--;ei--;ej--;\n		t=map[si][sj];\n		map[si][sj]=map[ei][ej];\n		map[ei][ej]=t;\n		if( can(si,sj,ei,ej) && (amount(si,sj) || amount(ei,ej))) puts(\"Ok!\");\n		else puts(\"Illegal move!\");\n	}\n	return 0;\n}'),(589,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\nvector<string> vet1,vet2;\r\nstring list1,op,list2;\r\nvoid deal()\r\n{\r\n    char tmp[128];\r\n    int k=0;\r\n    memset(tmp,0,sizeof(tmp));\r\n    int len=list1.length();\r\n    for(int i=1;i<len;i++)\r\n    {\r\n        if(list1[i]!=\',\' && list1[i]!=\']\')\r\n            tmp[k++]=list1[i];\r\n        else\r\n        {\r\n            if(k!=0)\r\n            {\r\n            vet1.push_back(tmp);\r\n            memset(tmp,0,sizeof(tmp));\r\n            k=0;\r\n            }\r\n        }\r\n    }\r\n    len=list2.length();\r\n    for(int i=1;i<len;i++)\r\n    {\r\n        if(list2[i]!=\',\' && list2[i]!=\']\')\r\n            tmp[k++]=list2[i];\r\n        else\r\n        {\r\n            if(k!=0)\r\n            {\r\n            vet2.push_back(tmp);\r\n            memset(tmp,0,sizeof(tmp));\r\n            k=0;\r\n            }\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n   // freopen(\"in.txt\",\"r\",stdin);\r\n    while(cin>>list1)\r\n    {\r\n        if(list1==\".\") break;\r\n        cin>>op>>list2;\r\n        vet1.clear();\r\n        vet2.clear();\r\n        deal();\r\n        vector<string>::iterator it,it2;\r\n        cout<<\"[\";\r\n        if(op==\"++\")\r\n        {\r\n            for(it=vet1.begin();it!=vet1.end();it++)\r\n            {\r\n                if(it==vet1.end()-1)\r\n                    cout<<*it;\r\n                else\r\n                    cout<<*it<<\",\";\r\n            }\r\n            if(!vet1.empty() && !vet2.empty()) cout<<\",\";\r\n            for(it=vet2.begin();it!=vet2.end();it++)\r\n            {\r\n                if(it==vet2.end()-1)\r\n                    cout<<*it;\r\n                else\r\n                    cout<<*it<<\",\";\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for(it2=vet2.begin();it2!=vet2.end();it2++)\r\n            {\r\n                for(it=vet1.begin();it!=vet1.end();it++)\r\n                {\r\n                    if(*it2==*it)\r\n                    {\r\n                        vet1.erase(it);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            for(it=vet1.begin();it!=vet1.end();it++)\r\n            {\r\n                if(it==vet1.end()-1)\r\n                    cout<<*it;\r\n                else\r\n                    cout<<*it<<\",\";\r\n            }\r\n        }\r\n        cout<<\"]\"<<endl;\r\n    }\r\n    return 0;\r\n}\r\n'),(590,'#include <stdio.h>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main()\n{\n	int i;\n	char s[101],op[3],s2[101];\n	\n	while(scanf(\"%s\",s),s[0]!=\'.\')\n	{\n		scanf(\"%s%s\",op,s2);\n		vector<string> m;\n		vector<string>::iterator it;\n		string t;\n		for(i=0;s[i];i++)\n		{\n			if(s[i]!=\'[\')\n			{\n				if(s[i]==\',\'||s[i]==\']\')\n				{\n					if( t!=\"\" ) m.push_back(t);\n					t=\"\";\n				}\n				else t+=s[i];\n			}\n			\n		}\n		for(i=0;s2[i];i++)\n		{\n			if(s2[i]!=\'[\')\n			{\n				if(s2[i]==\',\'||s2[i]==\']\')\n				{\n					if(op[0]==\'+\')\n					{\n						if( t!=\"\" ) m.push_back(t);\n					}\n					else\n					{\n						for(it=m.begin();it!=m.end();it++)\n						{\n							if( (*it)==t )\n							{\n								m.erase(it);\n								break;\n							}\n						}\n					}\n					t=\"\";\n				}\n				else t+=s2[i];\n			}\n		}\n		putchar(\'[\');\n		for(i=0;i<m.size();i++)\n		{\n			printf(\"%s%s\",m[i].c_str(),i==m.size()-1?\"\":\",\");\n		}\n		putchar(\']\');\n		putchar(10);\n	}\n	return 0;\n}'),(591,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\nusing namespace std;\r\nconst int maxsize=128;\r\nconst int mod=101;\r\nchar str[maxsize],res[maxsize*10];\r\nvoid deal()\r\n{\r\n    int len=strlen(str);\r\n    int tmp;\r\n    char num[maxsize];\r\n    res[0]=\'\\0\';\r\n    for(int i=0;i<len;i++)\r\n    {\r\n        tmp=(str[i]-\'a\'+1);\r\n        tmp*=tmp;\r\n        sprintf(num,\"%d\",tmp);\r\n        strcat(res,num);\r\n    }\r\n}\r\nint main()\r\n{\r\n    int t;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        scanf(\"%s\",str);\r\n        deal();\r\n        int len=strlen(res),ans=0;\r\n        for(int i=0;i<len;i++)\r\n            ans=(ans*10 +(res[i]-\'0\') )%mod;\r\n        printf(\"%d\\n\",ans);\r\n    }\r\n    return 0;\r\n}\r\n'),(592,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<math.h>\n\nint mod10(int x)\n{\n	int a=1,i;\n	for(i=0;i<x;i++)\n		a=(a*10)%101;\n	return a;\n}\n\nint bit(char c)\n{\n	if(c>\'C\')\n	{\n		if(c>\'I\')\n			return 3;\n		else\n			return 2;\n	}\n	else\n		return 1;\n}\n\nint main()\n{\n	int i,j,k,l,len,n,t,sum;\n	int shu[1000];\n	char s[100];\n	scanf(\"%d\",&t);\n	while(t--)\n	{\n		n=0;sum=0;\n		scanf(\"%s\",s);\n		len=strlen(s);\n		for(i=0;i<len;i++)\n		{\n			if(s[i]>=\'a\')\n				s[i]-=32;\n		}\n		for(i=0,j=0;i<len;i++)\n		{\n			n=(s[i]-\'A\'+1)*(s[i]-\'A\'+1);\n			k=bit(s[i]);\n			j+=k;\n			for(l=1;l<=k;l++)\n			{\n				shu[j-l]=n%10;\n				n/=10;\n			}\n		}\n		for(i=j-1,k=0;i>=0;i--,k++)\n			sum+=(shu[i]*mod10(k))%101;\n		printf(\"%d\\n\",sum%101);\n	}\n	return 0;\n}'),(593,'#include <stdio.h>\r\nint a[1111111];\r\nint main()\r\n{\r\n    int i,j,m,n,k,t,p;\r\n    a[1]=1;\r\n    a[2]=2;\r\n    for(i=3;i<=1000010;i++)\r\n    {\r\n        if(a[i]%2==1)  a[i]=a[i-1];\r\n        else   a[i]=(a[i-2]+a[i/2])%1000000000;\r\n\r\n    }\r\n\r\n\r\n    scanf(\"%d\",&k);\r\n    while(k--)\r\n    {\r\n        scanf(\"%d\",&p);\r\n        printf(\"%d\\n\",a[p]);\r\n    }\r\n\r\n    return 0;\r\n}'),(594,'#include <stdio.h>\r\nint a[1111111];\r\nint main()\r\n{\r\n    int i,j,m,n,k,t,p;\r\n    a[1]=1;\r\n    a[2]=2;\r\n    for(i=3;i<=1000010;i++)\r\n    {\r\n        if(a[i]%2==1)  a[i]=a[i-1];\r\n        else   a[i]=(a[i-2]+a[i/2])%1000000000;\r\n    }\r\n    scanf(\"%d\",&k);\r\n    while(k--)\r\n    {\r\n        scanf(\"%d\",&p);\r\n        printf(\"%d\\n\",a[p]);\r\n    }\r\n    return 0;\r\n}'),(595,'#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\nchar map[71][71];\nstring dp[71][71],mx;\nint cmp(string s1,string s2)\n{\n	int i;\n\n	if( s1.length()>s2.length()) return 1;\n	else if( s2.length()>s1.length()) return -1;\n	else \n	{\n		for(i=0;s1[i];i++)\n		{\n			if( s1[i]>s2[i] ) return 1;\n			else if(s1[i]<s2[i]) return -1;\n		}\n		return 0;\n	}\n}\nint main()\n{\n	int w,h,i,j;\n\n	while(scanf(\"%d%d\",&w,&h),w+h)\n	{\n		for(i=0;i<h;i++)\n		{\n			scanf(\"%s\",map[i]);\n			for(j=0;j<w;j++)\n				dp[i][j]=\"\";\n		}\n		mx=\"\";\n		for(i=0;i<h;i++)\n		{\n			for(j=0;j<w;j++)\n			{\n				if(map[i][j]>=\'0\'&&map[i][j]<=\'9\')\n				{\n					if(map[i][j]!=\'0\') dp[i][j]+=map[i][j];\n					if( i>0 && cmp(dp[i-1][j]+map[i][j],dp[i][j])>0) dp[i][j]=dp[i-1][j]+map[i][j];\n					if(j>0 && cmp(dp[i][j-1]+map[i][j],dp[i][j])>0) dp[i][j]=dp[i][j-1]+map[i][j];\n					if(dp[i][j]==\"0\") dp[i][j]=\"\";\n				}\n				if( cmp(dp[i][j],mx)>0 ) mx=dp[i][j];\n			}\n		}\n		for(i=0;i<mx.length();i++)\n			putchar(mx[i]);\n		putchar(10);\n	}\n	return 0;\n}'),(596,'#include <stdio.h>\n#include <string>\n#include <algorithm>\nusing namespace std;\nchar map[71][71];\nstring dp[71][71],mx;\nint cmp(string s1,string s2)\n{\n	int i;\n\n	if( s1.length()>s2.length()) return 1;\n	else if( s2.length()>s1.length()) return -1;\n	else \n	{\n		for(i=0;s1[i];i++)\n		{\n			if( s1[i]>s2[i] ) return 1;\n			else if(s1[i]<s2[i]) return -1;\n		}\n		return 0;\n	}\n}\nint main()\n{\n	int w,h,i,j;\n\n	while(scanf(\"%d%d\",&w,&h),w+h)\n	{\n		for(i=0;i<h;i++)\n		{\n			scanf(\"%s\",map[i]);\n			for(j=0;j<w;j++)\n				dp[i][j]=\"\";\n		}\n		mx=\"\";\n		for(i=0;i<h;i++)\n		{\n			for(j=0;j<w;j++)\n			{\n				if(map[i][j]>=\'0\'&&map[i][j]<=\'9\')\n				{\n					if(map[i][j]!=\'0\') dp[i][j]+=map[i][j];\n					if( i>0 && cmp(dp[i-1][j]+map[i][j],dp[i][j])>0) dp[i][j]=dp[i-1][j]+map[i][j];\n					if(j>0 && cmp(dp[i][j-1]+map[i][j],dp[i][j])>0) dp[i][j]=dp[i][j-1]+map[i][j];\n					if(dp[i][j]==\"0\") dp[i][j]=\"\";\n				}\n				if( cmp(dp[i][j],mx)>0 ) mx=dp[i][j];\n			}\n		}\n		for(i=0;i<mx.length();i++)\n			putchar(mx[i]);\n		putchar(10);\n	}\n	return 0;\n}'),(597,'#include <stdio.h> \r\n#include <math.h> \r\n  \r\nint get_min(int *p,int len) \r\n{ \r\n    int i=0,min=0,tmp; \r\n    do{ \r\n        min=abs(p[i]); \r\n        i++; \r\n    }while(min==0); \r\n    for(i=0;i<(len-1);i++) \r\n    { \r\n        tmp=abs(p[i]); \r\n        if (tmp!=0) \r\n        { \r\n            if(min>tmp) \r\n            { \r\n                min=tmp; \r\n            } \r\n        } \r\n    } \r\n    return min; \r\n} \r\n  \r\nint main() \r\n{ \r\n    int i,T; \r\n    int len=0; \r\n    int arr[20]; \r\n    int sum,tmp; \r\n    scanf(\"%d\",&T); \r\n    while (T) \r\n    { \r\n        sum=0; \r\n        scanf(\"%d\",&len); \r\n        for (i=0;i<len;i++) \r\n        { \r\n            scanf(\"%d\",&arr[i]); \r\n        } \r\n        for (i=0;i<len;i++) \r\n        { \r\n            if(arr[i]>0) \r\n            { \r\n                sum+=arr[i]; \r\n            } \r\n        } \r\n        tmp=get_min(arr,len); \r\n        if (tmp>0) \r\n        { \r\n            sum-=tmp; \r\n        } \r\n        else\r\n        { \r\n            sum+=tmp; \r\n        } \r\n        printf(\"%d\\n\",sum); \r\n        T--; \r\n    } \r\n    return 0; \r\n}'),(598,'#include <stdio.h>\r\n#include <math.h>\r\nint get_min(int *p,int len)\r\n{int i=0,min=0,tmp;\r\ndo{min=abs(p[i]);\r\ni++;\r\n}while(min==0);\r\nfor(i=0;i<(len-1);i++)\r\n{tmp=abs(p[i]);\r\nif (tmp!=0)\r\n{if(min>tmp)\r\n{min=tmp;}}}\r\nreturn min;\r\n}\r\n\r\nint main()\r\n{\r\nint i,T;\r\nint len=0;\r\nint arr[20];\r\nint sum,tmp;\r\nscanf(\"%d\",&T);\r\nwhile (T)\r\n{sum=0;\r\nscanf(\"%d\",&len);\r\nfor (i=0;i<len;i++)\r\n{scanf(\"%d\",&arr[i]);}\r\nfor (i=0;i<len;i++)\r\n{\r\nif(arr[i]>0)\r\n{sum+=arr[i];}\r\n}\r\ntmp=get_min(arr,len);\r\nif (tmp>0)\r\n{	sum-=tmp;}\r\nelse\r\n{sum+=tmp;}\r\nprintf(\"%d\\n\",sum);\r\nT--;}\r\nreturn 0;\r\n}'),(599,'#include <stdio.h>\r\n#define MAX 22\r\ntypedef struct node\r\n{\r\n     double matrix[MAX][MAX];\r\n}Matrix;\r\nMatrix unit,init,result;\r\nint t,n,k;\r\ndouble data[MAX];\r\nvoid Init()\r\n{\r\n    int i,j;\r\n    scanf(\"%d\",&n);\r\n    for(i=1;i<=n;i++)   //输入初始值\r\n        scanf(\"%lf\",&data[i]);\r\n    for(i=1;i<=n;i++)\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            init.matrix[i][j]=0;\r\n            unit.matrix[i][j]=(i==j);  //单位矩阵\r\n        }\r\n    int num;\r\n    double p;\r\n    for(i=1;i<=n;i++)\r\n    {\r\n        scanf(\"%d\",&num);\r\n        if(num==0) //否则除0错误\r\n        {\r\n            init.matrix[i][i]=1.0;   //因为没有分东西给别人,故东西全部给自己,第一错误\r\n            continue;\r\n        }\r\n        p=1.0/num;\r\n        while(num--)\r\n        {\r\n            scanf(\"%d\",&j);\r\n            init.matrix[i][j]=p;\r\n        }\r\n    }\r\n    scanf(\"%d\",&k);   //经过k秒\r\n}\r\nMatrix Mul(Matrix a,Matrix b)  //矩阵乘法\r\n{\r\n    Matrix c;\r\n    int i,j,p;\r\n    for(i=1;i<=n;i++)\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            c.matrix[i][j]=0.0;\r\n            for(p=1;p<=n;p++)\r\n            {\r\n                c.matrix[i][j]+=a.matrix[i][p]*b.matrix[p][j];\r\n            }\r\n        }\r\n    return c;\r\n}\r\nMatrix Cal(int exp)  //矩阵幂\r\n{\r\n    Matrix p,q,res;\r\n    p=unit;  //单位矩阵\r\n    q=init;  //初始矩阵\r\n    while(exp!=1)\r\n    {\r\n        if(exp&1)//幂是奇数\r\n        {\r\n            exp--;\r\n            p=Mul(p,q);  //这里忘记写乘,导致很多次错误,要细心\r\n        }\r\n        else\r\n        {\r\n            exp>>=1;\r\n            q=Mul(q,q);\r\n        }\r\n    }\r\n    res=Mul(p,q);\r\n    return res;\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    double r;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        Init();\r\n        result=Cal(k);\r\n        for(i=1;i<=n;i++)\r\n        {\r\n            r=0;\r\n            for(j=1;j<=n;j++)\r\n                r+=result.matrix[j][i]*data[j];\r\n            if((i-1))  //格式控制\r\n                printf(\" \");\r\n            printf(\"%0.2lf\",r);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\r\n'),(600,'#include <stdio.h>\r\n#define MAX 22\r\ntypedef struct node\r\n{\r\n     double matrix[MAX][MAX];\r\n}Matrix;\r\nMatrix unit,init,result;\r\nint t,n,k;\r\ndouble data[MAX];\r\nvoid Init()\r\n{\r\n    int i,j;\r\n    scanf(\"%d\",&n);\r\n    for(i=1;i<=n;i++)   //输入初始值\r\n        scanf(\"%lf\",&data[i]);\r\n    for(i=1;i<=n;i++)\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            init.matrix[i][j]=0;\r\n            unit.matrix[i][j]=(i==j);  //单位矩阵\r\n        }\r\n    int num;\r\n    double p;\r\n    for(i=1;i<=n;i++)\r\n    {\r\n        scanf(\"%d\",&num);\r\n        if(num==0) //否则除0错误\r\n        {\r\n            init.matrix[i][i]=1.0;   //因为没有分东西给别人,故东西全部给自己,第一错误\r\n            continue;\r\n        }\r\n        p=1.0/num;\r\n        while(num--)\r\n        {\r\n            scanf(\"%d\",&j);\r\n            init.matrix[i][j]=p;\r\n        }\r\n    }\r\n    scanf(\"%d\",&k);   //经过k秒\r\n}\r\nMatrix Mul(Matrix a,Matrix b)  //矩阵乘法\r\n{\r\n    Matrix c;\r\n    int i,j,p;\r\n    for(i=1;i<=n;i++)\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            c.matrix[i][j]=0.0;\r\n            for(p=1;p<=n;p++)\r\n            {\r\n                c.matrix[i][j]+=a.matrix[i][p]*b.matrix[p][j];\r\n            }\r\n        }\r\n    return c;\r\n}\r\nMatrix Cal(int exp)  //矩阵幂\r\n{\r\n    Matrix p,q,res;\r\n    p=unit;  //单位矩阵\r\n    q=init;  //初始矩阵\r\n    while(exp!=1)\r\n    {\r\n        if(exp&1)//幂是奇数\r\n        {\r\n            exp--;\r\n            p=Mul(p,q);  //这里忘记写乘,导致很多次错误,要细心\r\n        }\r\n        else\r\n        {\r\n            exp>>=1;\r\n            q=Mul(q,q);\r\n        }\r\n    }\r\n    res=Mul(p,q);\r\n    return res;\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    double r;\r\n    scanf(\"%d\",&t);\r\n    while(t--)\r\n    {\r\n        Init();\r\n        result=Cal(k);\r\n        for(i=1;i<=n;i++)\r\n        {\r\n            r=0;\r\n            for(j=1;j<=n;j++)\r\n                r+=result.matrix[j][i]*data[j];\r\n            if((i-1))  //格式控制\r\n                printf(\" \");\r\n            printf(\"%0.2lf\",r);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\r\n'),(601,'#include\"stdio.h\"\r\nint main()\r\n{double a[100]={0},b[100]={0},c[100]={0};\r\nint x,i,l=50,j=50,k=50;\r\ndouble y;\r\nwhile(scanf(\"%d %lf\",&x,&y)!=EOF)\r\n{switch(x)\r\n{case 0:a[l]=y;\r\nl--;\r\ncontinue;\r\ncase 1:b[j]=y;\r\nj--;\r\ncontinue;\r\ncase 2:c[k]=y;\r\nk--;\r\ncontinue;}}\r\nfor(i=0;i<10;i++,l++,j++,k++)\r\nprintf(\"%.0lf %.0lf %.0lf\\n\",a[l+1],b[j+1],c[k+1]);}\r\n'),(602,'#include\"stdio.h\"\r\nint main()\r\n{double a[100]={0},b[100]={0},c[100]={0};\r\nint x,i,l=50,j=50,k=50;\r\ndouble y;\r\nwhile(scanf(\"%d %lf\",&x,&y)!=EOF)\r\n{switch(x)\r\n{case 0:a[l]=y;\r\nl--;\r\ncontinue;\r\ncase 1:b[j]=y;\r\nj--;\r\ncontinue;\r\ncase 2:c[k]=y;\r\nk--;\r\ncontinue;}}\r\nfor(i=0;i<10;i++,l++,j++,k++)\r\nprintf(\"%.0lf %.0lf %.0lf\\n\",a[l+1],b[j+1],c[k+1]);}\r\n'),(603,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    char a[2000];\r\n    int x[2000]={0},i;\r\n    while(scanf(\"%s\",a)!=EOF)\r\n    {\r\n        int len=strlen(a);\r\n        int m,n,k,j=0;\r\n        for(; len!=0; len=k)\r\n        {\r\n            m=0,n,k=0;\r\n            for(i=0; i<len; i++)\r\n            {\r\n                n=m*10+a[i]-\'0\';\r\n                m=n%2;\r\n                if(k==0&&n/2!=0)\r\n                    a[k++]=n/2+\'0\';\r\n                else if(k!=0)\r\n                    a[k++]=n/2+\'0\';\r\n                if(i==len-1)\r\n                    x[j++]=m;\r\n            }\r\n        }\r\n        for(i=j-1; i>=0; i--)\r\n            printf(\"%d\",x[i]);\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\r\n'),(604,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{char a[2000];\r\nint x[2000]={0};\r\nwhile(scanf(\"%s\",a)!=EOF)\r\n{int len=strlen(a);\r\nint m,n,k,j=0;\r\nfor(; len!=0; len=k)\r\n{m=0,n,k=0;\r\nfor(int i=0; i<len; i++)\r\n{n=m*10+a[i]-\'0\';\r\nm=n%2;\r\nif(k==0&&n/2!=0)\r\na[k++]=n/2+\'0\';\r\nelse if(k!=0)\r\na[k++]=n/2+\'0\';\r\nif(i==len-1)\r\nx[j++]=m;}}\r\nfor(int i=j-1; i>=0; i--)\r\nprintf(\"%d\",x[i]);\r\nprintf(\"\\n\");    }\r\nreturn 0;\r\n}'),(605,'#include <stdio.h>\r\nint main()\r\n{\r\n    int temp=0,n=778477,m;\r\n    while(~scanf(\"%d\",&m))\r\n    {\r\n        if(n==778477)\r\n            n=m;\r\n        else if(n > m)\r\n            temp=1;\r\n        else\r\n            n=m;\r\n    }\r\n    if(temp)\r\n        printf(\"NO\\n\");\r\n    else\r\n        printf(\"YES\\n\");\r\n    return 0;\r\n}\r\n'),(606,'#include<stdio.h>\n\nint main()\n{\n	int n,f,k=1;\n	scanf(\"%d\",&f);\n	while(scanf(\"%d\",&n)!=EOF)\n	{\n		if(n<f)\n		{\n			k=0;\n			break;\n		}\n		f=n;\n	}\n	puts(k?\"YES\":\"NO\");\n	return 0;\n} '),(607,'#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\n\nconst int INT_ONLY=1;\nconst int SMALL_ONLY=2;\n\nstring roundString(string s)\n{\n	double d=atof(s.c_str());\n	int dec,sign;\n	s=fcvt(d,2,&dec,&sign);\n	return s;\n}\n\nstring formatChinese(int flag,string s)\n{\n	int sLength=s.length();\n	string bigLetter[]={\"零\",\"壹\",\"贰\",\"叁\",\"肆\",\"伍\",\"陆\",\"柒\",\"捌\",\"玖\"};\n	string unit[]={\"元\",\"拾\",\"佰\",\"仟\",\"万\",\"拾\",\"佰\",\"仟\",\"亿\",\"拾\",\"佰\",\"仟\",\"万\"};\n	string small[]={\"分\",\"角\"};\n	string newS=\"\";\n	for(int i=0;i<sLength;i++)\n	{\n		if(flag==INT_ONLY)\n			newS=newS+bigLetter[s.at(i)-48]+unit[sLength-i-1];\n		else if(flag==SMALL_ONLY)\n			newS=newS+bigLetter[s.at(i)-48]+small[sLength-i-1];\n	}\n	return newS;\n}\n\nstring splitNum(string s)\n{\n	if(\"\"==s)\n		return \"\";\n	string intOnly=s.substr(0,s.size()-2);\n	string intPart=formatChinese(1,intOnly);\n	string smallOnly=s.substr(s.size()-2,s.size());\n	string smallPart=formatChinese(2,smallOnly);\n	string newS=intPart+smallPart;\n	return newS;\n}\n\nstring replaceAll(string src,string regex,string replacement)\n{\n	int length=regex.length();\n	while(src.find(regex)<src.length())\n		src.replace(src.find(regex),length,replacement);\n	return src;\n}\n\nstring cleanZero(string s)\n{\n	if(\"\"==s)\n		return \"\";\n	string regex1[]={\"零仟\",\"零佰\",\"零拾\"};\n	string regex2[]={\"零亿\",\"零万\",\"零元\"};\n	string regex3[]={\"亿\",\"万\",\"元\"};\n	string regex4[]={\"零角\",\"零分\"};\n	for(int i=0;i<3;i++)\n		s=replaceAll(s,regex1[i],\"零\");\n	for(int i=0;i<3;i++)\n	{\n		s=replaceAll(s,\"零零零\",\"零\");\n		s=replaceAll(s,\"零零\",\"零\");\n		s=replaceAll(s,regex2[i],regex3[i]);\n	}\n	for(int i=0;i<2;i++)\n		s=replaceAll(s,regex4[i],\"\");\n	s=replaceAll(s,\"亿万\",\"亿\");\n	return s;\n}\n\nint main()\n{\n	string s;\n	int i,j,l,flag;\n	while(cin>>s)\n	{\n		if(s==\"0\"||s==\"0.0\"||s==\"0.00\")\n		{\n			cout<<\"零元整\"<<endl;\n			continue;\n		}\n		if(s==\"10\"||s==\"10.0\"||s==\"10.00\")\n		{\n			cout<<\"拾元整\"<<endl;\n			continue;\n		}\n		l=s.length();\n		for(i=0;i<l;i++)\n			if(s[i]==\'.\')\n			{\n				for(flag=1,j=i+1;s[j]!=\'\\0\';j++)\n					if(s[j]!=\'0\')\n					{\n						flag=0;\n						break;\n					}\n				if(!flag)\n					break;\n			}\n		s=roundString(s);\n		s=splitNum(s);\n		s=cleanZero(s);\n		if(i<l)\n			cout<<s<<endl;\n		else\n			cout<<s<<\"整\"<<endl;\n	}\n	return 0;\n}'),(608,'#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\n\nconst int INT_ONLY=1;\nconst int SMALL_ONLY=2;\n\nstring roundString(string s)\n{\n	double d=atof(s.c_str());\n	int dec,sign;\n	s=fcvt(d,2,&dec,&sign);\n	return s;\n}\n\nstring formatChinese(int flag,string s)\n{\n	int sLength=s.length();\n	string bigLetter[]={\"零\",\"壹\",\"贰\",\"叁\",\"肆\",\"伍\",\"陆\",\"柒\",\"捌\",\"玖\"};\n	string unit[]={\"元\",\"拾\",\"佰\",\"仟\",\"万\",\"拾\",\"佰\",\"仟\",\"亿\",\"拾\",\"佰\",\"仟\",\"万\"};\n	string small[]={\"分\",\"角\"};\n	string newS=\"\";\n	for(int i=0;i<sLength;i++)\n	{\n		if(flag==INT_ONLY)\n			newS=newS+bigLetter[s.at(i)-48]+unit[sLength-i-1];\n		else if(flag==SMALL_ONLY)\n			newS=newS+bigLetter[s.at(i)-48]+small[sLength-i-1];\n	}\n	return newS;\n}\n\nstring splitNum(string s)\n{\n	if(\"\"==s)\n		return \"\";\n	string intOnly=s.substr(0,s.size()-2);\n	string intPart=formatChinese(1,intOnly);\n	string smallOnly=s.substr(s.size()-2,s.size());\n	string smallPart=formatChinese(2,smallOnly);\n	string newS=intPart+smallPart;\n	return newS;\n}\n\nstring replaceAll(string src,string regex,string replacement)\n{\n	int length=regex.length();\n	while(src.find(regex)<src.length())\n		src.replace(src.find(regex),length,replacement);\n	return src;\n}\n\nstring cleanZero(string s)\n{\n	if(\"\"==s)\n		return \"\";\n	string regex1[]={\"零仟\",\"零佰\",\"零拾\"};\n	string regex2[]={\"零亿\",\"零万\",\"零元\"};\n	string regex3[]={\"亿\",\"万\",\"元\"};\n	string regex4[]={\"零角\",\"零分\"};\n	for(int i=0;i<3;i++)\n		s=replaceAll(s,regex1[i],\"零\");\n	for(int i=0;i<3;i++)\n	{\n		s=replaceAll(s,\"零零零\",\"零\");\n		s=replaceAll(s,\"零零\",\"零\");\n		s=replaceAll(s,regex2[i],regex3[i]);\n	}\n	for(int i=0;i<2;i++)\n		s=replaceAll(s,regex4[i],\"\");\n	s=replaceAll(s,\"亿万\",\"亿\");\n	return s;\n}\n\nint main()\n{\n	string s;\n	int i,j,l,flag;\n	while(cin>>s)\n	{\n		if(s==\"0\"||s==\"0.0\"||s==\"0.00\")\n		{\n			cout<<\"零元整\"<<endl;\n			continue;\n		}\n		if(s==\"10\"||s==\"10.0\"||s==\"10.00\")\n		{\n			cout<<\"拾元整\"<<endl;\n			continue;\n		}\n		l=s.length();\n		for(i=0;i<l;i++)\n			if(s[i]==\'.\')\n			{\n				for(flag=1,j=i+1;s[j]!=\'\\0\';j++)\n					if(s[j]!=\'0\')\n					{\n						flag=0;\n						break;\n					}\n				if(!flag)\n					break;\n			}\n		s=roundString(s);\n		s=splitNum(s);\n		s=cleanZero(s);\n		if(i<l)\n			cout<<s<<endl;\n		else\n			cout<<s<<\"整\"<<endl;\n	}\n	return 0;\n}'),(609,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,c,d;\r\n	scanf(\"%d%d%d%d\",&a,&b,&c,&d);\r\n	printf(\"%d %d\",a+c,b+d);\r\n	return 0;\r\n}'),(610,'#include<stdio.h>\n\nint main()\n{\n	int a,b,c,d;\n	scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n	printf(\"%d %d\\n\",a+c,b+d);\n	return 0;\n} '),(611,'#include<stdio.h>\r\n#include<math.h>\r\nint main(){\r\nint a,b,c,d,s,m;\r\nwhile(scanf(\"%d%d\\n%d%d\",&a,&b,&c,&d)!=-1){\r\ns=a*c-d*b;\r\nm=(b*c+a*d);\r\nprintf(\"%d %d\",s,m);\r\n}\r\nreturn 0;\r\n}\r\n'),(612,'#include<stdio.h>\n\nint main()\n{\n	int a,b,c,d;\n	scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n	printf(\"%d %d\\n\",a*c-b*d,a*d+b*c);\n	return 0;\n}'),(613,'#include <iostream.h>\r\nusing namespace std;  \r\nstruct Node{int array[10];};  \r\nint main()  \r\n{  \r\n  int i,N,M,num1,num2;  \r\n  cin>>N>>M;  \r\n  Node pt,pr,pe;  \r\n  for(i=0;i<10;i++)  \r\n  {pt.array[i]=0;pr.array[i]=0;pe.array[i]=0;}  \r\n  for( i=0;i<N;i++)  \r\n     { cin>>num1>>num2;  \r\n    pt.array[num2]=num1;}  \r\n   for( i=0;i<M;i++)  \r\n  { cin>>num1>>num2;  \r\n    pr.array[num2]=num1;  \r\n  }  \r\n  for(i=9;i>=0;i--)  \r\n     { pe.array[i]=pt.array[i]+pr.array[i];  \r\n  if(pe.array[i]!=0) cout<<pe.array[i]<<\" \"<<i<<endl;   \r\n     }  \r\n}'),(614,'#include <iostream.h>\r\nusing namespace std;  \r\nstruct Node{int array[10];};  \r\nint main()  \r\n{  \r\n  int i,N,M,num1,num2;  \r\n  cin>>N>>M;  \r\n  Node pt,pr,pe;  \r\n  for(i=0;i<10;i++)  \r\n  {pt.array[i]=0;pr.array[i]=0;pe.array[i]=0;}  \r\n  for( i=0;i<N;i++)  \r\n     { cin>>num1>>num2;  \r\n    pt.array[num2]=num1;}  \r\n   for( i=0;i<M;i++)  \r\n  { cin>>num1>>num2;  \r\n    pr.array[num2]=num1;  \r\n  }  \r\n  for(i=9;i>=0;i--)  \r\n     { pe.array[i]=pt.array[i]+pr.array[i];  \r\n  if(pe.array[i]!=0) cout<<pe.array[i]<<\" \"<<i<<endl;   \r\n     }  \r\n}'),(615,'#include <cstdio>\r\nconst int g=100000000,d=25;\r\nint f[513][d],len[513];\r\nint ans[d],lans;\r\nvoid Add(int (&a)[d],int (&b)[d],int &l)\r\n{\r\n    int i;\r\n    for (i=0;i<d;++i)\r\n    {\r\n        a[i]+=b[i];\r\n        if (a[i]>=g)\r\n        {\r\n            a[i+1]+=a[i]/g;\r\n            a[i]%=g;\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int w,k,N;\r\n    int i,j;\r\n    scanf(\"%d%d\",&k,&w);\r\n    lans=1;\r\n    N=1<<k;\r\n    for (j=1;j<N;++j) f[j][0]=len[j]=1;\r\n    for (i=2;i<=w/k;++i)\r\n        for (--N,j=1;j<N;++j)\r\n        {\r\n            Add(f[j],f[j-1],len[j]);\r\n            Add(ans,f[j],lans);\r\n        }\r\n    for (--N,j=1;j<N;++j) Add(f[j],f[j-1],len[j]);\r\n    w=N-(1<<(w%k));\r\n    for (j=N-1;j>0&&j>w;--j)\r\n        Add(ans,f[j],lans);\r\n    for (i=d-1;!ans[i];--i);\r\n    printf(\"%d\",ans[i]);\r\n    for (--i;i>=0;--i) printf(\"%08d\",ans[i]);\r\n    return 0;\r\n}'),(616,'#include <cstdio>\r\nconst int g=100000000,d=25;\r\nint f[513][d],len[513];\r\nint ans[d],lans;\r\nvoid Add(int (&a)[d],int (&b)[d],int &l)\r\n{\r\n    int i;\r\n    for (i=0;i<d;++i)\r\n    {\r\n        a[i]+=b[i];\r\n        if (a[i]>=g)\r\n        {\r\n            a[i+1]+=a[i]/g;\r\n            a[i]%=g;\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int w,k,N;\r\n    int i,j;\r\n    scanf(\"%d%d\",&k,&w);\r\n    lans=1;\r\n    N=1<<k;\r\n    for (j=1;j<N;++j) f[j][0]=len[j]=1;\r\n    for (i=2;i<=w/k;++i)\r\n        for (--N,j=1;j<N;++j)\r\n        {\r\n            Add(f[j],f[j-1],len[j]);\r\n            Add(ans,f[j],lans);\r\n        }\r\n    for (--N,j=1;j<N;++j) Add(f[j],f[j-1],len[j]);\r\n    w=N-(1<<(w%k));\r\n    for (j=N-1;j>0&&j>w;--j)\r\n        Add(ans,f[j],lans);\r\n    for (i=d-1;!ans[i];--i);\r\n    printf(\"%d\",ans[i]);\r\n    for (--i;i>=0;--i) printf(\"%08d\",ans[i]);\r\n    return 0;\r\n}'),(617,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	int a,b,c;\r\n	double X1,X2;\r\n	scanf(\"%d%d%d\",&a,&b,&c);\r\n   X1=(-b+sqrt(b*b-4*a*c))/2;\r\n    X2=(-b-sqrt(b*b-4*a*c))/2;\r\n	printf(\"%.2lf %.2lf\\n\",X1,X2);\r\n	return 0;\r\n}'),(618,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n   double a,b,c;\r\n   scanf(\"%lf%lf%lf\",&a,&b,&c);\r\n   printf(\"%.2lf %.2lf\",(-b+sqrt(b*b-4*a*c))/2*a,(-b-sqrt(b*b-4*a*c))/2*a);\r\n   return 0;\r\n\r\n}'),(619,'#include<stdio.h>\r\nint main()\r\n{\r\n	char s[90];\r\n	int i;\r\n	scanf(\"%s\",s);\r\n	for (i=0;s[i]!=0;i++)\r\n	{\r\n		if (s[i]>=\'a\'&&s[i]<=\'z\'||s[i]>=\'A\'&&s[i]<=\'Z\'||s[i]==\'\\n\')\r\n		printf(\"%c\",s[i]);\r\n	}\r\n	printf(\"\\n\");\r\n	return 0;\r\n}\r\n'),(620,'#include<stdio.h>\r\nint main()\r\n{\r\n	char a;\r\n	while(scanf(\"%c\",&a)!=EOF)\r\n	{\r\n		if(a>=\'a\'&&a<=\'z\'||a>=\'A\'&&a<=\'Z\')\r\n			printf(\"%c\",a);\r\n	}\r\n}'),(621,'#include<stdio.h>\r\nmain()\r\n{\r\n int a,b,c,d;\r\n scanf(\"%d %d %d %d\",&a,&b,&c,&d);\r\n printf(\"%d %d %d\\n\",a,b,c);\r\n printf(\"%d %d %d\\n\",a,c,b);\r\n printf(\"%d %d %d\\n\",b,a,c);\r\n printf(\"%d %d %d\\n\",b,c,a);\r\n printf(\"%d %d %d\\n\",c,a,b);\r\n printf(\"%d %d %d\\n\",c,b,a);\r\n printf(\"%d %d %d\\n\",a,b,d);\r\n printf(\"%d %d %d\\n\",a,d,b);\r\n printf(\"%d %d %d\\n\",b,a,d);\r\n printf(\"%d %d %d\\n\",b,d,a);\r\n printf(\"%d %d %d\\n\",d,a,b);\r\n printf(\"%d %d %d\\n\",d,b,a);\r\n printf(\"%d %d %d\\n\",a,c,d);\r\n printf(\"%d %d %d\\n\",a,d,c);\r\n printf(\"%d %d %d\\n\",c,a,d);\r\n printf(\"%d %d %d\\n\",c,d,a);\r\n printf(\"%d %d %d\\n\",d,a,c);\r\n printf(\"%d %d %d\\n\",d,c,a);\r\n printf(\"%d %d %d\\n\",b,c,d);\r\n printf(\"%d %d %d\\n\",b,d,c);\r\n printf(\"%d %d %d\\n\",c,b,d);\r\n printf(\"%d %d %d\\n\",c,d,b);\r\n printf(\"%d %d %d\\n\",d,b,c);\r\n printf(\"%d %d %d\\n\",d,c,b);\r\n return 0;\r\n}'),(622,'#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a[4];\r\n	while(cin>>a[0]>>a[1]>>a[2]>>a[3])\r\n	{\r\n		\r\n		for(int i=3;i>=0;i--)\r\n		{\r\n		 swap(a[i],a[3]);sort(a,a+3);\r\n		 do\r\n		 {\r\n			cout<<a[0]<<\" \"<<a[1]<<\" \"<<a[2]<<endl;\r\n		 }\r\n		 while(next_permutation(a,a+3));\r\n		 swap(a[i],a[3]);\r\n		}\r\n	}\r\n}'),(623,'#include<stdio.h>           \r\nint main()\r\n{\r\n	int n,a[50],i,j,k,r,b[30],t,m,e,l;\r\n	scanf(\"%d\",&n);\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf(\"%d %d\",&a[i],&b[i]);\r\n		}\r\n		for(l=0;l<n;l++)\r\n		{\r\n			m=a[l]/2+1;\r\n			for(e=0;e<b[l];e++)\r\n			{\r\n				for(j=1;j<=m;j++)\r\n				{\r\n					for(k=1;k<=j-1;k++)\r\n					{\r\n						printf(\" \");	\r\n					}\r\n					printf(\"X\");\r\n					for(r=1;r<=a[l]-2*j;r++)\r\n					{\r\n						printf(\" \");\r\n					}\r\n					if(j<m)\r\n					{\r\n						printf(\"X\");\r\n					}\r\n					printf(\"\\n\");\r\n				}\r\n				for(j=1;j<=m-2;j++)\r\n				{\r\n					for(k=1;k<=m-j-1;k++)\r\n					{\r\n						printf(\" \");\r\n					}\r\n					printf(\"X\");\r\n					for(r=1;r<=2*j-1;r++)\r\n					{\r\n						printf(\" \");\r\n					}\r\n					printf(\"X\");\r\n					printf(\"\\n\");\r\n				}\r\n			}\r\n			printf(\"X\");\r\n			for(i=1;i<=a[l]-2;i++)\r\n			{\r\n				printf(\" \");\r\n			}\r\n			printf(\"X\");\r\n			printf(\"\\n\\n\");\r\n		}\r\n	return 0;\r\n}\r\n\r\n'),(624,'#include<stdio.h>\r\nvoid main()\r\n{\r\n	int	n,q,x,y,i,j,k;\r\n	scanf(\"%d\",&n);\r\n	\r\n	for(q=0;q<n;q++)\r\n	{\r\n		scanf(\"%d %d\",&x,&y);\r\n		\r\n		printf(\"X\");\r\n		for(i=1;i<x;i++)\r\n		if(i==x-1)\r\n			printf(\"X\\n\");\r\n		else\r\n			printf(\" \");\r\n		for(i=0;i<y;i++)\r\n		for(j=1;j<x;j++)\r\n		{\r\n			for(k=0;k<x;k++)\r\n			if(j+k>4&&j<x/2+1||j<k&&j>=x/2)\r\n				break;\r\n			else if(k==j||k+j==x-1)\r\n			  	 printf(\"X\");\r\n				 else\r\n				 printf(\" \");\r\n		printf(\"\\n\");\r\n		}\r\n		if(q<n-1)\r\n		printf(\"\\n\");\r\n	}\r\n}\r\n'),(625,'#include <stdio.h>\r\n#define MAX 30\r\n\r\nint justfy(char *str)\r\n{\r\n char *p = str;\r\n int subint[4];\r\n int i, flag = 1;\r\n\r\n while (*p)\r\n {\r\n  if (!( *p >= \'0\' && *p <= \'9\' || *p == \'.\'))\r\n   flag = 0;\r\n  p++;\r\n }\r\n if(flag)\r\n {\r\n  sscanf (str, \"%d.%d.%d.%d\", \r\n    &subint[0], &subint[1], &subint[2], &subint[3]);\r\n  for (i=0; i<4; i++)\r\n   if (subint[i] > 255)\r\n    flag = 0;\r\n }\r\n\r\n return flag;\r\n}\r\nint main ()\r\n{\r\n char str[30]; \r\n int flag[MAX];\r\n int i = 0, j;\r\n\r\n while (gets (str) != NULL && i < MAX)\r\n {\r\n  flag[i] = justfy (str);\r\n  i++;\r\n }\r\n for (j=0; j<i; j++)\r\n  printf (flag[j]? \"Y\\n\": \"N\\n\");\r\n\r\n return 0;\r\n}'),(626,'#include <stdio.h>\r\n#include <string.h>\r\nbool fun(int n)\r\n{\r\n    if(n>=0&&n<=255)return 1;\r\n    else return 0;\r\n}\r\nint main()\r\n{\r\n    char str[30];\r\n	int i,len;\r\n	bool flag;\r\n    while(scanf(\"%s\",str)!=EOF)\r\n    {\r\n        int a,b,c,d;\r\n        a=b=c=d=-1;\r\n		flag=1;\r\n		len=strlen(str);\r\n		for(i=0;i<len;i++)\r\n		{\r\n			if((i!=len-1)&&str[i]==\'0\'&&str[i+1]!=\'.\')\r\n				flag=0;\r\n		}\r\n		\r\n        sscanf(str,\"%d.%d.%d.%d\",&a,&b,&c,&d);\r\n        if(flag&&fun(a)&&fun(b)&&fun(c)&&fun(d))\r\n			printf(\"Y\\n\");\r\n        else \r\n			printf(\"N\\n\");\r\n    }\r\n    return 0;\r\n}\r\n'),(627,'#include<stdio.h>\r\n#include<math.h>\r\nint fac(int n);\r\nint main()\r\n{\r\n	int n,m,a,b,k,s;\r\n	scanf(\"%d%d\",&n,&k);\r\n	a=n/2;\r\n	s=0;\r\n	while(a>=0)\r\n	{\r\n		b=n-2*a;\r\n		m=a+b;\r\n		s+=((pow(k-1,a+b))*(fac(m)/(fac(a)*fac(b))));\r\n		a--;\r\n	}\r\n	printf(\"%d\",s);\r\n	return 0;\r\n}\r\nint fac(int n)\r\n{\r\n	int res;\r\n	if(n==1||n==0)\r\n		res=1;\r\n	else\r\n		res=n*fac(n-1);\r\n	return res;\r\n}'),(628,'#include<stdio.h>\r\n#include<math.h>\r\nint fac(int n);\r\nint main()\r\n{\r\n	int n,m,a,b,k,s;\r\n	scanf(\"%d%d\",&n,&k);\r\n	a=n/2;\r\n	s=0;\r\n	while(a>=0)\r\n	{\r\n		b=n-2*a;\r\n		m=a+b;\r\n		s+=((pow(k-1,a+b))*(fac(m)/(fac(a)*fac(b))));\r\n		a--;\r\n	}\r\n	printf(\"%d\",s);\r\n	return 0;\r\n}\r\nint fac(int n)\r\n{\r\n	int res;\r\n	if(n==1||n==0)\r\n		res=1;\r\n	else\r\n		res=n*fac(n-1);\r\n	return res;\r\n}'),(629,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    char a[11];\r\n    int sum=0; \r\n      int i;\r\n    while(scanf(\"%s\",a)!=-1)\r\n    { \r\n                            sum=0; \r\n    int len=strlen(a);\r\n  \r\n    for(i=0;i<len;i++)\r\n    sum+=a[i]-\'0\'; \r\n    printf(\"%d\\n\",sum); \r\n    } \r\n    return 0; \r\n    \r\n} \r\n'),(630,'#include<stdio.h>\r\nint main()\r\n{\r\n	char a[11];\r\n	int i;\r\n	int s=0;\r\n	while(scanf(\"%s\",a)!=-1)\r\n	{\r\n		s=0;\r\n		for(i=0;a[i]!=0;i++)\r\n			s+=(a[i]-\'0\');\r\n		printf(\"%d\\n\",s);\r\n	}\r\n}'),(631,'/*------------------------------------------------\r\n【程序设计】\r\n--------------------------------------------------\r\n\r\n功能：输入3个数，Y,M,D，分别表示年月日，请返回这一天是这一年的第几天？//保证输入合法\r\n例如:2012 6 18\r\n输出\r\n------------------------------------------------*/\r\n\r\n#include<iostream>\r\n#include<cstdio>\r\n#include<string>\r\n#include<fstream>\r\nusing namespace std;\r\nvoid wwjt();\r\nint  fun(int y,int m,int d)\r\n{\r\n\r\n  /**********Program**********/\r\n  int ans=0;\r\n  int day[]={31,28,31,30,31,30,31,31,30,31,30,31};\r\n  if (y%400==0 || (y%100!=0 && y%4==0)) day[1]++;\r\n  for (int i=0;i<m-1;++i) ans+=day[i];\r\n    return ans+d;\r\n  /**********  End  **********/\r\n}\r\n\r\nmain()\r\n{\r\n   // freopen(\"in.txt\",\"r\",stdin);\r\n    int result,y,m,d;\r\n    while (cin>>y>>m>>d)\r\n    {\r\n\r\n    result=fun(y,m,d);\r\n    cout<<result<<endl;\r\n    }\r\n  //wwjt();\r\n}\r\n\r\n'),(632,'#include<stdio.h>\r\nint main()\r\n{int y,m,d;\r\n	int days;\r\n	int a[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};\r\n	while(scanf(\"%d%d%d\",&y,&m,&d)!=EOF)\r\n	{\r\n		days=a[m-1]+d;\r\n        if(y%4==0&&y%100!=0||y%400==0 && m>2)\r\n			printf(\"%d\\n\",days+1);\r\n         else\r\n			printf(\"%d\\n\",days);\r\n	}\r\n	return 0;\r\n}'),(633,'#include<stdio.h>\r\nint main()\r\n{\r\n	long int i,j,sum;\r\n	while(~scanf(\"%X%X\",&i,&j))\r\n	{\r\n		sum=i+j;\r\n	printf(\"%X\",sum);\r\n	printf(\"\\n\");\r\n	}\r\n}\r\n'),(634,'#include<stdio.h>\r\nint main(){\r\n	int a,b;\r\n	while(~scanf(\"%x%x\",&a,&b))\r\n		printf(\"%X\\n\",a+b);\r\n}'),(635,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n    int n,num[1024],i,flag;\r\n    char tmp,j;\r\n   // freopen(\"in.txt\",\"r\",stdin);\r\n    while(scanf(\"%d\",&n)!=EOF)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf(\"%d\",&num[i]);\r\n        for(j=\'A\';j<=\'Z\';j++)\r\n        {\r\n            flag=0;\r\n            for(i=0;i<n;i++)\r\n            {\r\n                tmp=j^num[i];\r\n                if(tmp<\'A\' || tmp>\'Z\')\r\n                {\r\n                    flag=1;\r\n                    break;\r\n                }\r\n            }\r\n            if(!flag)\r\n            {\r\n                for(i=0;i<n;i++)\r\n                    printf(\"%c\",j^num[i]);\r\n                printf(\"\\n\");\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n'),(636,'#include<iostream>\r\n#include<cstring>\r\n#include<fstream>\r\n using namespace std;\r\n   char a[10000];\r\nint main()\r\n{  int n,i,t;\r\n	while(cin>>n)\r\n	{\r\n	for(i=0;i<n;i++)\r\n	{   cin>>t;\r\n	    a[i]=t;\r\n	}\r\n\r\n   for(  i=65;i<91;i++)\r\n   {\r\n       for(t=0;t<n;t++)\r\n		   if((i^a[t])>90||(i^a[t])<65) break;\r\n	  if(t==n) break;\r\n   }\r\n   for(t=0;t<n;t++)\r\n	   cout<<(char)(a[t]^i);\r\n   cout<<endl;}\r\n}'),(637,'/*\r\nID:hataksu2\r\nPROG:milk2\r\nLANG:C++\r\n*/\r\n#include<cstdio>\r\n#include<algorithm>\r\nstruct myPair\r\n{\r\n	int frm,to;\r\n	bool operator < (const myPair& other)const\r\n	{\r\n		if(frm!=other.frm)\r\n			return frm < other.frm;\r\n		else\r\n			return to<other.to;\r\n	}\r\n};\r\nusing std::sort;\r\nmyPair myPairs[6000];\r\nint main()\r\n{\r\n	//freopen(\"milk2.in\",\"r\",stdin);\r\n	//freopen(\"milk2.out\",\"w\",stdout);\r\n	int n,i;\r\n	int full,vacancy;\r\n	int end;\r\n	myPair curFullInterval;\r\n	while(~scanf(\"%d\",&n))\r\n	{\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf(\"%d%d\",&myPairs[i].frm,&myPairs[i].to);\r\n		}\r\n		sort(myPairs+0,myPairs+n);\r\n		full=vacancy=0;\r\n		end=myPairs[0].frm;\r\n		curFullInterval = myPairs[0];\r\n		for(i=0;i<n;i++)\r\n		{\r\n			if(myPairs[i].frm>end)\r\n			{\r\n				if(myPairs[i].frm-end>vacancy)\r\n				{\r\n					vacancy=myPairs[i].frm-end;\r\n				}\r\n				curFullInterval = myPairs[i];\r\n			}\r\n			else\r\n			{\r\n				if(curFullInterval.to<myPairs[i].to)//update curFullInterval.to\r\n					curFullInterval.to=myPairs[i].to;\r\n			}\r\n			if(curFullInterval.to-curFullInterval.frm>full)//update full\r\n				full = curFullInterval.to-curFullInterval.frm;\r\n			if(curFullInterval.to>end)//update end\r\n				end= curFullInterval.to;\r\n		}\r\n		printf(\"%d %d\\n\",full,vacancy);\r\n	}\r\n	return 0;\r\n}\r\n'),(638,'#include <cstdio>\r\n#include <cstring>\r\nint time[1000][1000]={0};\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf(\"%d\",&n)!=EOF)\r\n	{\r\n        memset(time,0,sizeof(time));\r\n	    int a,b,without=0,within=0,start=0,end=0,t=1;\r\n	    for (int i=0;i<n;i++)\r\n        {\r\n            scanf(\"%d%d\",&a,&b);\r\n            for (;a<b;a++)\r\n                time[a/1000][a%1000]=1;\r\n        }\r\n        for(int tt=0;tt<1000;tt++)\r\n        for (int i=0;i<1000;i++)\r\n        {\r\n            if(t==0)\r\n                if(time[tt][i]==1)\r\n                {\r\n                    start=tt*1000+i;\r\n                    t=1;\r\n                }else;\r\n            else\r\n            {\r\n                if(time[tt][i]==0)\r\n                {\r\n                    end=tt*1000+i;\r\n                    t=0;\r\n                }\r\n            }\r\n            if(within<end-start)\r\n                within=end-start;\r\n            if(without<start-end && end!=0)\r\n                without=start-end;\r\n        }\r\n        printf(\"%d %d\\n\",within,without);\r\n	}\r\n\r\n	return 0;\r\n}\r\n'),(639,'#include<stdio.h>\r\n#include <string.h>\r\nint main()\r\n{\r\n    int i,k,j,o,n,sum,x,y,p,q;\r\n    char arry2[400],f,g;\r\n    char arry[800];\r\n    while(scanf(\"%d\",&n)!=EOF)\r\n    {\r\n        sum=0;\r\n        scanf(\"%s\",arry2);\r\n\r\n		strcpy(arry,arry2);\r\n        strcat(arry,arry2);\r\n        for(i=n;i<=2*n;i++)\r\n        {\r\n			k=x=y=p=q=0;\r\n            for(j=i;j<=2*n;j++)\r\n            {\r\n			    if(arry[j]!=\'w\')\r\n				{\r\n                	f=arry[j];\r\n					break;\r\n				}\r\n			}\r\n			for(o=i-1;o>=0;o--)\r\n            {\r\n			    if(arry[o]!=\'w\')\r\n				{\r\n                	g=arry[o];\r\n					break;\r\n				}\r\n			}\r\n			if(g!=f)\r\n			{\r\n				for(j=i;j<2*n;j++)\r\n				{\r\n			        if(arry[j]==\'w\'||arry[j]==f)\r\n					    k++;\r\n			    	else\r\n				    	break;\r\n				}\r\n                for(o=i-1;o>=0;o--)\r\n				{\r\n			        if(arry[o]==\'w\'||arry[o]==g)\r\n					    k++;\r\n				    else\r\n					    break;\r\n				}\r\n			}\r\n            else\r\n			{\r\n				for(j=i;j<2*n;j++)\r\n				{\r\n			        if((arry[j]==\'w\'||arry[j]==f)&&p==0)\r\n					    k++;\r\n			    	else\r\n					{\r\n				    	x++;\r\n						p=1;\r\n						if(arry[j+1]==f)\r\n							break;\r\n					}\r\n				}\r\n				for(o=i-1;o>=0;o--)\r\n				{\r\n			        if((arry[o]==\'w\'||arry[o]==g)&&q==0)\r\n					    k++;\r\n				    else\r\n					{\r\n						y++;\r\n						q=1;\r\n						if(arry[o-1]==g)\r\n							break;\r\n					}\r\n				}\r\n				if(x>y)\r\n					k=k+x;\r\n				else\r\n					k=k+y;\r\n			}\r\n            if(k>sum)\r\n            sum=k;\r\n        }\r\n		if(sum>n)\r\n			sum=n;\r\n        printf(\"%d\\n\",sum);\r\n    }\r\n    return 0;\r\n}\r\n'),(640,'#include <iostream>\r\n#include <cstring>\r\n#include <string>\r\n#define Max_n 400\r\n\r\nusing namespace std;\r\n\r\n\r\nint main() {\r\n    int n;\r\n	while(cin>>n){\r\n	bool hash[Max_n]={0};\r\n    string necklace;\r\n    cin>>necklace;\r\n    int maxl,maxr;\r\n    int max=0;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        memset(hash,false,sizeof(hash));\r\n        maxl=maxr=0;\r\n        int l=(i-1+n)%n,r=i;\r\n        int il=(i-1+n)%n,ir=i;\r\n        int flag=0;\r\n        int a=0;\r\n        while(!hash[l]&&((necklace[l]==necklace[il]||a)||necklace[l]==\'w\'))\r\n        {\r\n            if(!flag&&necklace[il]==\'w\')\r\n            {\r\n                if(necklace[l]!=\'w\')\r\n                {\r\n                    il=l;\r\n                    flag=1;\r\n		    a=0;\r\n                }\r\n	  	    else a=1;\r\n            }\r\n            maxl++;\r\n            hash[l]=true;\r\n            l=(l-1+n)%n;\r\n        }\r\n        flag=0;\r\n	a=0;\r\n        while(!hash[r]&&((necklace[r]==necklace[ir]||a)||necklace[r]==\'w\'))\r\n        {\r\n            if(!flag&&necklace[ir]==\'w\')\r\n            {\r\n                if(necklace[r]!=\'w\')\r\n                {\r\n                    flag=1;\r\n                    ir=r;\r\n                    a=0;\r\n                }\r\n		else a=1;\r\n            }\r\n            maxr++;\r\n            hash[r]=true;\r\n            r=(r+1)%n;\r\n        }\r\n        if(max<maxr+maxl) max=maxr+maxl;\r\n    }\r\n    cout<<max<<endl;\r\n}\r\n    return 0;\r\n}\r\n\r\n'),(641,'#include<stdio.h>\r\nint main()\r\n{\r\n int res,i,n,t;\r\n while(scanf(\"%d\",&n)!=EOF)\r\n {\r\n  if(n==0)\r\n   break;\r\n  \r\n  for(i=res=0;i<n;i++)\r\n  {\r\n   scanf(\"%d\",&t);\r\n   res^=t;\r\n  }\r\n  printf(\"%d\\n\",res);\r\n }\r\n return 0;\r\n}'),(642,'#include<stdio.h>\r\nint main(){\r\nint i,k,n,s;\r\nwhile(scanf(\"%d\",&n),n)\r\n{\r\ns=0;\r\nfor(i=0;i<n;i++){\r\nscanf(\"%d\",&k);\r\ns^=k;\r\n}\r\nprintf(\"%d\\n\",s);\r\n}\r\n}'),(643,'#include <iostream>\r\n#include <sstream>\r\n#include <set>\r\n#include <string>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    string str;\r\n    char c;\r\n    int ans=0;\r\n    set<string> s;\r\n    while(cin>>str)\r\n    {\r\n        if(str==\"#\") break;\r\n        if(s.find(str)==s.end()) ans++, s.insert(str);\r\n        c=getchar();\r\n        if(c==\'\\n\') cout<<ans<<endl, ans=0, s.clear();\r\n    }\r\n    return 0;\r\n}\r\n'),(644,'#include <iostream>\r\n#include <set>\r\n#include <iterator>\r\n#include <sstream>\r\n#include <string>\r\nusing namespace std;\r\nint main()\r\n{\r\n\r\nstring line;\r\nwhile(getline(cin,line),line!=\"#\"){\r\n  istringstream iss(line);\r\n  set<string> s((istream_iterator<string>(iss)),istream_iterator<string>());\r\n  cout<<s.size()<<endl;\r\n}\r\nreturn !cout;\r\n}'),(645,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a;\r\n	int b[10000];\r\n	int c;\r\n	int d;\r\n	int i;\r\n	int j;\r\n	while(1)\r\n	{\r\n		scanf(\"%d\",&a);\r\n		scanf(\"%d\",&c);\r\n		if(a!=0&&c!=0)\r\n		{\r\n			a=a*100;\r\n			for(i=0,j=-1;i<=99;i++)\r\n			{\r\n				d=a+i;\r\n				if(d%c==0)\r\n				{j++;\r\n					b[j]=i;\r\n					\r\n				}\r\n			}\r\n			for(i=0;i<j;i++)\r\n			{\r\n				if(b[i]<10)\r\n					printf(\"0%d \",b[i]);\r\n				else\r\n					printf(\"%d \",b[i]);\r\n\r\n			}\r\n			printf(\"%d\",b[j]);\r\n			printf(\"\\n\");\r\n		}\r\n		\r\n		else\r\n			break;	\r\n	}\r\n	return 0;\r\n}'),(646,'#include <cstdio>\r\n\r\nint main()\r\n{\r\n	int a, b, i, j;\r\n\r\n	while(~scanf(\"%d%d\", &a, &b) && a+b)\r\n	{\r\n		a*=100;\r\n		for(i=0, j=0; i<100; i++)\r\n			if((a+i)%b==0) \r\n			{\r\n				if(j) printf(\" \");            \r\n				printf(\"%02d\", i);\r\n				j=1;\r\n			}\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(647,'#include <cstring>\r\n#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n\r\nint str1[2005],str2[2005];\r\nint str3[2005];\r\n\r\nvoid f(int n,int* str1,int* str2,int* str3)\r\n{\r\n	if(n<=0) return;\r\n	int p;\r\n	for(int i=0;i<n;i++)\r\n			if(str2[i]==str1[0]) {p=i;break;}\r\n	f(p,str1+1,str2,str3);\r\n	f(n-p-1,str1+p+1,str2+p+1,str3+p);\r\n	str3[n-1]=str1[0];\r\n}\r\n\r\nint main()\r\n{\r\n    int xxx;\r\n	cin>>xxx;\r\n	while(xxx--)\r\n	{\r\n	    int n;\r\n	    cin>>n;\r\n\r\n		for(int i=0;i<n;i++)\r\n            cin>>str2[i];\r\n		for(int i=0;i<n;i++)\r\n            str1[i]=str2[i];\r\n        sort(str1,str1+n);\r\n\r\n		f(n,str2,str1,str3);\r\n\r\n        printf(\"%d\",str3[0]);\r\n		for(int i=1;i<n;i++)\r\n			printf(\" %d\",str3[i]);\r\n		printf(\"\\n\\n\");\r\n\r\n	}\r\n	return 0;\r\n}\r\n'),(648,'#include <cstring>\r\n#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n\r\nint str1[2005],str2[2005];\r\nint str3[2005];\r\n\r\nvoid f(int n,int* str1,int* str2,int* str3)\r\n{\r\n	if(n<=0) return;\r\n	int p;\r\n	for(int i=0;i<n;i++)\r\n			if(str2[i]==str1[0]) {p=i;break;}\r\n	f(p,str1+1,str2,str3);\r\n	f(n-p-1,str1+p+1,str2+p+1,str3+p);\r\n	str3[n-1]=str1[0];\r\n}\r\n\r\nint main()\r\n{\r\n    int xxx;\r\n	cin>>xxx;\r\n	while(xxx--)\r\n	{\r\n	    int n;\r\n	    cin>>n;\r\n\r\n		for(int i=0;i<n;i++)\r\n            cin>>str2[i];\r\n		for(int i=0;i<n;i++)\r\n            str1[i]=str2[i];\r\n        sort(str1,str1+n);\r\n\r\n		f(n,str2,str1,str3);\r\n\r\n        printf(\"%d\",str3[0]);\r\n		for(int i=1;i<n;i++)\r\n			printf(\" %d\",str3[i]);\r\n		printf(\"\\n\\n\");\r\n\r\n	}\r\n	return 0;\r\n}\r\n'),(649,'#include <stdlib.h>\r\n#include <stdio.h>\r\nint W,H;\r\nchar z[21][21];\r\nint f(int x, int y) {\r\n    if(x<0 ||x >= W || y < 0 || y>= H)\r\n        return 0;\r\n    if(z[x][y] == \'#\')\r\n        return 0;\r\n    else {\r\n        z[x][y] = \'#\';\r\n        return 1+f(x-1,y)+f(x+1,y)+f(x, y-1) +f(x, y+1);\r\n    }\r\n}\r\nvoid main()\r\n{\r\n    int i, j, num;\r\n    while(scanf(\"%d%d\", &H, &W) && W != 0 && H != 0) {\r\n        num = 0;\r\n        for(i=0;i<W;i++)\r\n            scanf(\"%s\",z[i]);\r\n        for(i=0;i<W;i++)\r\n            for(j=0;j<H;j++)\r\n                if(z[i][j] == \'@\') printf(\"%d\\n\",f(i,j));\r\n    }\r\n    \r\n}\r\n'),(650,'#include <stdlib.h>\r\n#include <stdio.h>\r\nint W,H;\r\nchar z[21][21];\r\nint f(int x, int y) {\r\n    if(x<0 ||x >= W || y < 0 || y>= H)\r\n        return 0;\r\n    if(z[x][y] == \'#\')\r\n        return 0;\r\n    else {\r\n        z[x][y] = \'#\';\r\n        return 1+f(x-1,y)+f(x+1,y)+f(x, y-1) +f(x, y+1);\r\n    }\r\n}\r\nint main()\r\n{\r\n    int i, j, num;\r\n    while(scanf(\"%d%d\", &H, &W) && W != 0 && H != 0) {\r\n        num = 0;\r\n        for(i=0;i<W;i++)\r\n            scanf(\"%s\",z[i]);\r\n        for(i=0;i<W;i++)\r\n            for(j=0;j<H;j++)\r\n                if(z[i][j] == \'@\') printf(\"%d\\n\",f(i,j));\r\n    }\r\n    \r\n}'),(651,'#include<iostream>\r\n#include<string>\r\n#include<map>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cstdio>\r\nusing namespace std;\r\nmap<string,string>M;\r\nint main()\r\n{\r\n    string a,b;\r\n    //freopen(\"in.txt\",\"r\",stdin);\r\n    cin>>a;\r\n    getchar();\r\n    while (cin>>a && a!=\"END\")\r\n    {\r\n        cin>>b;\r\n        M[b]=a;\r\n    }\r\n    cin>>a;\r\n    getchar();\r\n    char tmp[3010];\r\n    while (1){\r\n        gets(tmp);\r\n        if (!strcmp(tmp,\"END\")) break;\r\n        int len=strlen(tmp);\r\n        b=\"\";\r\n        for (int i=0;i<len;++i)\r\n        {\r\n            if (tmp[i]>=\'a\' && tmp[i]<=\'z\')\r\n            {\r\n                b+=tmp[i];\r\n            }\r\n            else\r\n            {\r\n                if (M[b]!=\"\")\r\n                cout<<M[b];\r\n                else\r\n                cout<<b;\r\n                cout<<tmp[i];\r\n                b=\"\";\r\n            }\r\n        }\r\n        cout<<endl;\r\n    }\r\n    return 0;\r\n}\r\n'),(652,'#include<iostream> \r\n#include<fstream> \r\n#include<algorithm> \r\n#include<string> \r\n#include<list> \r\n#include<queue> \r\n#include<map> \r\n#include<stack> \r\n#include<cmath> \r\n#include<bitset> \r\nusing namespace std; \r\nofstream out(\"d://1.txt\"); \r\nvoid f() \r\n{ \r\nstring a[1000],b[1000],str; \r\nint i=0; \r\ncin>>str; \r\nwhile(1) \r\n{ \r\ncin>>a[i]; \r\nif(a[i]==\"END\") break; \r\ncin>>b[i]; \r\ni++; \r\n} \r\ncin>>str; \r\nwhile(1) \r\n{ \r\nchar ss[1000]; \r\ncin.get(); \r\ncin.get(ss,999); \r\nstr=ss; \r\nif(str.find(\"END\")!=string::npos) break; \r\nfor(int j=0;j<i;j++) \r\nwhile(str.find(b[j])!=string::npos) \r\n{ \r\nstr.replace(str.find(b[j]),b[j].length(),a[j]); \r\n} \r\ncout<<str<<endl; \r\n} \r\n} \r\nint main() \r\n{ \r\nf(); \r\n} '),(653,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <math.h>\r\nint main()\r\n{\r\n    int a[5050];\r\n    int n,i,N,flag2,flag3,count,z;\r\n    scanf(\"%d\",&n);\r\n    while(n--)\r\n    {\r\n        scanf(\"%d\",&N);\r\n        for(i = 1; i <= N; i++)\r\n            a[i] = 1;\r\n        count = N;\r\n\r\n        while(count != 3)\r\n        { flag2 = 0;\r\n        flag3 = 0;\r\n            for(i = 1; i <= N; i++)\r\n            {\r\n                if(a[i] == 1)\r\n                {\r\n                    flag2++;\r\n                    if(flag2 == 2)\r\n                    {\r\n                        flag2 = 0;\r\n                        a[i] = 0;\r\n                        count--;\r\n\r\n                        if(count == 3)\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if(count != 3)\r\n            {\r\n                for(i = 1; i <= N; i++)\r\n                {\r\n                    if(a[i] == 1)\r\n                    {\r\n                        flag3++;\r\n                        if(flag3 == 3)\r\n                        {\r\n                            flag3 = 0;\r\n                            a[i] = 0;\r\n                            count--;\r\n                            if(count == 3)\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        z = 0;\r\n        for(i = 1; i <= N; i++)\r\n        {\r\n            if(a[i] == 1)\r\n            {\r\n                z++;\r\n                if(z == 3)\r\n                    printf(\"%d\\n\",i);\r\n                else\r\n                    printf(\"%d \",i);\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}'),(654,'#include <cstdio>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid make(int t[], int n, int k, int& size)\r\n{\r\n	for(int i=1, j=0; i<=n; i++)\r\n	{\r\n		if(t[i]) continue;\r\n		j++;\r\n		if(j%k==0) t[i]=1, size--;\r\n		if(size==3) return ;\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	int t, n;\r\n	for(cin>>t; t--;)\r\n	{\r\n		cin>>n;\r\n		int t[5555]={0}, k=0; \r\n		int size=n;\r\n		while(size>3)	\r\n		{\r\n			k?make(t, n, 3, size):make(t, n, 2, size);\r\n			k=1-k;\r\n		}\r\n		for(int i=1, flag=0; i<=n; i++)\r\n			if(t[i]==0)\r\n			{\r\n				if(flag) cout<<\" \";\r\n				cout<<i;\r\n				flag=1;\r\n			}\r\n		cout<<endl;\r\n	}\r\n	return 0;\r\n}\r\n'),(655,'#include<stdio.h>\r\n#include<queue>\r\nusing namespace std;\r\nstruct node\r\n{\r\n	double m;\r\n	int num;\r\n};\r\nbool operator<(node a,node b)\r\n{\r\n	return a.m>b.m;\r\n}\r\n\r\nint main()\r\n{\r\n	int m,n;\r\n	node t;\r\n	while(scanf(\"%d%d\",&m,&n)!=EOF)\r\n	{\r\n		priority_queue<node> pq;\r\n		int i;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf(\"%lf%d\",&t.m,&t.num);\r\n			pq.push(t);\r\n		}\r\n		double sum=0;\r\n		while(m>0)\r\n		{\r\n			t=pq.top();\r\n			if(m>=t.num)\r\n			{\r\n				sum+=t.num*t.m;\r\n				m-=t.num;\r\n			}\r\n			else\r\n			{\r\n				sum+=t.m*m;\r\n				m-=m;\r\n			}\r\n			pq.pop();\r\n		}\r\n		printf(\"%.0lf\\n\",sum);\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n			\r\n\r\n\r\n\r\n\r\n	\r\n'),(656,'#include <iostream> \r\n#include <algorithm> \r\nusing namespace std; \r\nstruct Node \r\n{ \r\nint p, a; \r\n}; \r\nbool cmp(Node a, Node b) \r\n{ \r\nreturn a.p<b.p; \r\n} \r\nint main() \r\n{ \r\nint n, m, ans=0; \r\nNode cow[5555]; \r\ncin>>n>>m; \r\nfor(int i=0; i<m; i++) \r\n{ \r\ncin>>cow[i].p>>cow[i].a; \r\n} \r\nsort(cow, cow+m, cmp); \r\nint i=0; \r\nwhile(n>0) \r\n{ \r\nif(cow[i].a<=n) ans+=cow[i].p*cow[i].a; \r\nelse ans+=cow[i].p*n; \r\nn-=cow[i].a; i++; \r\n} \r\ncout<<ans<<endl; \r\n} '),(657,'#include<stdio.h>\r\n#include<iostream>\r\n#include<stdlib.h>\r\nusing namespace std;\r\nint main(){\r\n	int n,i,j,k;\r\n	int flag1;\r\n	int flag2;\r\n	int temp;\r\n	int mark=1;\r\n	while(scanf(\"%d\",&n)&&n){\r\n		mark=0;\r\n		int *s = new int[n];\r\n		for(int i=0;i<n;++i){\r\n			scanf(\"%d\",&s[i]);\r\n		}\r\n		for( i=0;i<n;++i){\r\n			flag1 = 0;\r\n			flag2 = 0;\r\n			for( j=i+1;j<n;++j){\r\n				if(s[j]<s[i]){\r\n					 temp = s[j];\r\n					flag1 = 1;\r\n					break;\r\n				}\r\n			}\r\n			if(flag1==1){\r\n				for( k=j+1;k<n;++k){\r\n					if(s[k]<s[i]){\r\n						if(s[k]<temp){\r\n							temp = s[k];\r\n						}\r\n						else{\r\n							flag2=1;\r\n							break;\r\n						}\r\n					}\r\n				}\r\n			}\r\n			if(flag2==1){\r\n				mark=1;\r\n			}\r\n		}\r\n		if(mark)\r\n			printf(\"No\\n\");\r\n		else\r\n			printf(\"Yes\\n\");	\r\n	}\r\n	\r\n} '),(658,'#include <iostream>\r\n#include <stack>\r\n#include <queue>\r\n\r\nusing namespace std;\r\n\r\nint n;\r\n\r\nint main()\r\n{\r\n	while(cin>>n && n)\r\n	{\r\n		queue<int> out;\r\n		stack<int> in;\r\n		for(int i=1; i<=n; i++) \r\n		{\r\n			int x; cin>>x;\r\n			out.push(x);\r\n		}\r\n		for(int i=1; i<=n; i++)\r\n		{\r\n			in.push(i);\r\n			while(!in.empty() && in.top()==out.front()) in.pop(), out.pop();\r\n		}\r\n		if(in.empty()) cout<<\"Yes\\n\";\r\n				  else cout<<\"No\\n\";\r\n	}\r\n	return 0;\r\n}'),(659,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n    int i,n,k,b[8];\r\n    char a[255];\r\n    while(scanf(\"%d\", &n) != EOF)\r\n    {\r\n        if(n==0)break;\r\n        while(n--)\r\n        {\r\n            k=0;\r\n            scanf(\"%s\",&a);\r\n            for(i=0;a[i]!=\'\\0\'&&i<255;i++)\r\n            {\r\n                if(a[i]==\')\')\r\n                {\r\n                    if(a[i+1]==\'>\')\r\n                    {\r\n                        k++;\r\n                        break;\r\n\r\n                    }\r\n                }\r\n                if(a[i+1]==\'(\')\r\n                {\r\n                    if(a[i]==\'<\')\r\n                    {\r\n                        k++;\r\n                        break;\r\n\r\n                    }\r\n                }\r\n                else if(a[i]==\']\')\r\n                {\r\n                    if(a[i+1]==\'>\'||a[i+1]==\')\')\r\n                    {\r\n                        k++;\r\n                        break;\r\n                    }\r\n                }\r\n                else if(a[i+1]==\'[\')\r\n                {\r\n                    if(a[i]==\'<\'||a[i]==\'(\')\r\n                    {\r\n                        k++;\r\n                        break;\r\n                    }\r\n                }\r\n                else if(a[i]==\'}\')\r\n                {\r\n                    if(a[i+1]==\'>\'||a[i+1]==\')\'||a[i+1]==\']\')\r\n                    {\r\n                        k++;\r\n                        break;\r\n                    }\r\n                }\r\n                else if(a[i+1]==\'}\')\r\n                {\r\n                   if(a[i]==\'<\'||a[i]==\'(\'||a[i]==\'[\')\r\n                    {\r\n                        k++;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            for(i=0;i<8;i++)\r\n            {\r\n                b[i]=0;\r\n            }\r\n            for(i=0;a[i]!=\'\\0\'&&i<255;i++)\r\n            {\r\n                if(a[i]==\'<\')b[0]++;\r\n                else if(a[i]==\'>\')b[1]++;\r\n                else if(a[i]==\'(\')b[2]++;\r\n                else if(a[i]==\')\')b[3]++;\r\n                else if(a[i]==\'[\')b[4]++;\r\n                else if(a[i]==\']\')b[5]++;\r\n                else if(a[i]==\'{\')b[6]++;\r\n                else if(a[i]==\'}\')b[7]++;\r\n\r\n            }\r\n            if(k==0&&b[0]==b[1]&&b[2]==b[3]&&b[4]==b[5]&&b[6]==b[7])\r\n            {\r\n                printf(\"YES\\n\");\r\n            }\r\n            else\r\n            {\r\n               printf(\"NO\\n\");\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n'),(660,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nint judge(char a)\r\n{\r\n	if(a==\'<\') return 1;\r\n	else if(a==\'(\') return 2;\r\n	else if(a==\'[\') return 3;\r\n	else if(a==\'{\') return 4;\r\n	else if(a==\'>\') return -1;\r\n	else if(a==\')\') return -2;\r\n	else if(a==\']\') return -3;\r\n	else if(a==\'}\') return -4;\r\n	else return 6;\r\n}\r\n\r\nint main()\r\n{\r\n	int t;\r\n	for(scanf(\"%d\",&t);t--;)\r\n	{\r\n		char str[300]=\"\";\r\n		cin>>str;\r\n		stack<char> s;\r\n		s.push(\'+\');\r\n		int i;\r\n		for(i=0;i<strlen(str);i++)\r\n		{\r\n			if(judge(s.top())+judge(str[i])==0&&judge(s.top())>judge(str[i])) s.pop();\r\n			else if(judge(s.top())>=judge(str[i])) s.push(str[i]);\r\n			else {s.push(str[i]);break;}\r\n		}\r\n		if(judge(s.top())==6) puts(\"YES\");\r\n		else puts(\"NO\");\r\n	}\r\n	return 0;\r\n}'),(661,'#include<stdio.h>  \r\nint a[1001],l[4],x,y,z,n;  \r\nint main()  \r\n{  \r\n    scanf(\"%d\",&n);  \r\n    for (int i=1;i<=n;++i)  \r\n    {  \r\n        scanf(\"%d\",&a[i]);  \r\n        ++l[a[i]];  \r\n    }  \r\n    for (int i=1;i<=l[1];++i)  \r\n        if (a[i]!=1) ++x;  \r\n    for (int i=l[1]+1;i<=l[1]+l[2];++i)  \r\n        if (a[i]==3) ++y;  \r\n    for (int i=l[1]+l[2]+1;i<=n;++i)  \r\n        if (a[i]==2) ++z;  \r\n    if (y>z) x+=y;  \r\n    else x+=z;\r\n    printf(\"%d\\n\",x);  \r\n    return 0;  \r\n}  \r\n'),(662,'#include <cstdio>\r\n#include <iostream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		int a[5555], b[5555];\r\n		for(int i=0; i<n; i++) cin>>a[i], b[i]=a[i];\r\n		sort(a, a+n);\r\n		int ans=0;\r\n		for(int i=0; i<n; i++)\r\n			if(a[i]!=b[i]) ans++;\r\n		if(ans%2==1) ans=ans/2+1;\r\n				else ans=ans/2;\r\n		cout<<ans<<endl;\r\n	}\r\n	return 0;\r\n}\r\n'),(663,'/*\r\nID:wy262372\r\nPROG:preface\r\nLANG:C\r\n*/\r\n#include<stdio.h>\r\n#include<string.h>\r\nchar ch[8]={\' \',\'I\',\'V\',\'X\',\'L\',\'C\',\'D\',\'M\'};\r\nint a[8],num;\r\nFILE *in,*out;\r\nvoid f(int n)\r\n{\r\n	int i,j,k,t=0;\r\n	do\r\n	{\r\n		t+=2;\r\n		k=n%10;\r\n		if (k==9){a[t+1]++;a[t-1]++;}\r\n		else\r\n		{\r\n			if (k>=5) {a[t]++;k-=5;}\r\n			if (k==4) {a[t]++;a[t-1]++;}\r\n			else {a[t-1]=a[t-1 ]+k; }\r\n		}\r\n		n/=10;\r\n	}\r\n	while (n>0);\r\n\r\n}\r\nmain()\r\n{\r\n	int i,j,k,n;\r\n	//freopen(\"in.txt\",\"r\",stdin);\r\n	in=stdin;\r\n	out=stdout;\r\n\r\n	while (fscanf (in,\"%d\",&num)!=EOF)\r\n	{\r\n            	memset(a,0,sizeof(a));\r\n        for (i=1;i<=num;i++)\r\n        {\r\n            f(i);\r\n        }\r\n        for (i=1;i<=7;i++)\r\n        {\r\n            if (a[i]) fprintf (out,\"%c %d\\n\",ch[i],a[i]);\r\n        }\r\n	}\r\n	fclose (in);\r\n	fclose (out);\r\n\r\n	return 0;\r\n}\r\n'),(664,'/*\r\nID:wy262372\r\nPROG:preface\r\nLANG:C\r\n*/\r\n#include<stdio.h>\r\n#include<string.h>\r\nchar ch[8]={\' \',\'I\',\'V\',\'X\',\'L\',\'C\',\'D\',\'M\'};\r\nint a[8],num;\r\nFILE *in,*out;\r\nvoid f(int n)\r\n{\r\n	int i,j,k,t=0;\r\n	do\r\n	{\r\n		t+=2;\r\n		k=n%10;\r\n		if (k==9){a[t+1]++;a[t-1]++;}\r\n		else\r\n		{\r\n			if (k>=5) {a[t]++;k-=5;}\r\n			if (k==4) {a[t]++;a[t-1]++;}\r\n			else {a[t-1]=a[t-1 ]+k; }\r\n		}\r\n		n/=10;\r\n	}\r\n	while (n>0);\r\n\r\n}\r\nmain()\r\n{\r\n	int i,j,k,n;\r\n	//freopen(\"in.txt\",\"r\",stdin);\r\n	in=stdin;\r\n	out=stdout;\r\n\r\n	while (fscanf (in,\"%d\",&num)!=EOF)\r\n	{\r\n            	memset(a,0,sizeof(a));\r\n        for (i=1;i<=num;i++)\r\n        {\r\n            f(i);\r\n        }\r\n        for (i=1;i<=7;i++)\r\n        {\r\n            if (a[i]) fprintf (out,\"%c %d\\n\",ch[i],a[i]);\r\n        }\r\n	}\r\n	fclose (in);\r\n	fclose (out);\r\n\r\n	return 0;\r\n}\r\n'),(665,'#include <stdio.h>\r\nint main()\r\n{\r\n    int i = 0, j = 0, t = 0, n = 0;\r\n    double a = 0, max = 0;\r\n    scanf(\"%d\", &t);\r\n    while(t--)\r\n    {\r\n        scanf(\"%d\", &n);\r\n        for(i = 0; i<n; i++)\r\n        {\r\n            scanf(\"%lf\", &a);\r\n            if(max<a)\r\n                max = a;\r\n        }\r\n        printf(\"%.2lf\\n\", max);\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n'),(666,'#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int n1, n2;\r\n	double x, max=0;\r\n	scanf(\"%d\", &n1);\r\n	while(n1--)\r\n	{\r\n		scanf(\"%d\", &n2);\r\n		while(n2--)\r\n		{\r\n			scanf(\"%lf\", &x);\r\n			if(max<x)max = x;\r\n		}\r\n		printf(\"%.2lf\\n\", max);\r\n	}\r\n}'),(667,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <string>\r\n#include <algorithm>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n,m,a;\r\n    while(cin>>n>>m>>a)\r\n    {\r\n        if(m%a>0) m=(m)/a+1;\r\n        else m=m/a;\r\n        if(n%a>0) n=(n)/a+1;\r\n        else n=n/a;\r\n        cout<<m*n<<endl;\r\n    }\r\n    return 0;\r\n}\r\n'),(668,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	double n,m,a;\r\n	while(scanf(\"%lf%lf%lf\",&n,&m,&a)!=EOF)printf(\"%.0lf\\n\",ceil(n/a)*ceil(m/a));\r\n	return 0;\r\n}'),(669,'#include <iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<algorithm>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int num[5],s,n;\r\n    int Min;\r\n    while (scanf (\"%d\",&n)!=EOF)\r\n    {\r\n        memset(num,0,sizeof(num));\r\n        for (int i=0;i<n;++i)\r\n        {\r\n            scanf (\"%d\",&s);\r\n            num[s]++;\r\n        }\r\n        num[4]+=num[2]/2;\r\n        num[2]%=2;\r\n        Min=min(num[3],num[1]);\r\n        num[4]+=Min;\r\n        num[3]-=Min,num[1]-=Min;\r\n        Min=min(num[2],num[1]/2);\r\n        num[4]+=Min;\r\n        num[2]-=Min,num[1]-=(Min*2);\r\n        if (num[2]==1 && num[1]>=1) num[1]-=1;\r\n        num[4]+=num[1]/4;\r\n        if (num[1]%4!=0) num[4]+=1;\r\n        printf (\"%d\\n\",num[4]+num[3]+num[2]);\r\n    }\r\n    return 0;\r\n}'),(670,'#include<stdio.h>\r\nint main()\r\n{\r\nint n;\r\nwhile(scanf(\"%d\",&n)!=EOF)\r\n{\r\nint c=0,i,j,a[10000];\r\nfor(i=0;i<n;i++)\r\n{\r\nscanf(\"%d\",&a[i]);\r\nif(a[i]>0&&a[i]<5)\r\nc=c+a[i];\r\n}\r\nj=c/4;\r\nif(c%4!=0)\r\nj=j+1;\r\nprintf(\"%d\\n\",j);\r\n}\r\nreturn 0;\r\n\r\n}'),(671,'#include <stdio.h> \r\n#include <string.h> \r\nint main() \r\n{ \r\n    int num,time=0,t,i,s,p,gift,moneyt; \r\n    char name[10][14]={0},now[14]={0},fri[14]={0}; \r\n    int money[10]={0,0,0,0,0,0,0,0,0,0}; \r\n    scanf(\"%d\",&num); \r\n    for (i=0;i<num;i++) \r\n        scanf(\"%s\",name[i]); \r\n    for(i=0;i<num;i++) \r\n    { \r\n        scanf(\"%s\",now); \r\n        for (t=0;t<num;t++) \r\n        { \r\n            if (strcmp(now,name[t])); \r\n            else\r\n            { \r\n                scanf(\"%d %d\",&moneyt,&time); \r\n                if(time!=0) \r\n                    gift=moneyt/time; \r\n                else\r\n                    break; \r\n                for (s=0;s<time;s++) \r\n                { \r\n                    money[t]=money[t]-gift; \r\n                    scanf(\"%s\",fri); \r\n                    for(p=0;p<num;p++) \r\n                        if(strcmp(fri,name[p])); \r\n                        else\r\n                        { \r\n                            money[p]=money[p]+gift; \r\n                            break; \r\n                        } \r\n                } \r\n                break; \r\n            } \r\n        } \r\n    } \r\n    for(i=0;i<num;i++) \r\n    printf(\"%s %d\\n\",name[i],money[i]); \r\n    return 0; \r\n} \r\n'),(672,'#include <stdio.h>\r\n#include <string.h>\r\nint main()\r\n{\r\n	int num,time=0,t,i,s,p,gift,moneyt;\r\n	char name[10][14]={0},now[14]={0},fri[14]={0};\r\n	int money[10]={0,0,0,0,0,0,0,0,0,0};\r\n	scanf(\"%d\",&num);\r\n	for (i=0;i<num;i++)\r\n		scanf(\"%s\",name[i]);\r\n	for(i=0;i<num;i++)\r\n	{\r\n		scanf(\"%s\",now);\r\n		for (t=0;t<num;t++)\r\n		{\r\n			if (strcmp(now,name[t]));\r\n			else\r\n			{\r\n				scanf(\"%d %d\",&moneyt,&time);\r\n				if(time!=0)\r\n					gift=moneyt/time;\r\n				else\r\n					break;\r\n				for (s=0;s<time;s++)\r\n				{\r\n					money[t]=money[t]-gift;\r\n					scanf(\"%s\",fri);\r\n					for(p=0;p<num;p++)\r\n						if(strcmp(fri,name[p]));\r\n						else\r\n						{\r\n							money[p]=money[p]+gift;\r\n							break;\r\n						}\r\n				}\r\n				break;\r\n			}\r\n		}\r\n	}\r\n	for(i=0;i<num;i++)\r\n	printf(\"%s %d\\n\",name[i],money[i]);\r\n	return 0;\r\n}'),(673,'#include <stdio.h> \r\nchar getletter(int n) \r\n{ \r\n    if(n<=9&&n>=0) \r\n        return \'0\'+n; \r\n    else\r\n        return \'A\'+n-10; \r\n} \r\nvoid tran(char res[],int *w,int n,int num) \r\n{ \r\n    int i,t; \r\n    char unres[2000]={0}; \r\n    for(i=0;i<2000;i++) \r\n    { \r\n        if(num==0) \r\n            break; \r\n        unres[i]=getletter(num%n); \r\n        num=num/n; \r\n    } \r\n    *w=i; \r\n    for(t=0;t<i;t++) \r\n        res[t]=unres[i-t-1]; \r\n} \r\nint pal(char res[],int w) \r\n{ \r\n    int n; \r\n    for(n=0;n<w;n++) \r\n        if(res[n]!=res[w-n-1]) \r\n            return 0; \r\n    return 1; \r\n} \r\nint main() \r\n{ \r\n    int n,s,t=0,i=1,j,w,p; \r\n    char ss[5000]; \r\n    scanf(\"%d %d\",&n,&s); \r\n    while(t<n) \r\n    { \r\n        p=0; \r\n        for(j=2;j<=10;j++) \r\n        { \r\n            tran(ss,&w,j,s+i); \r\n            if(pal(ss,w)) \r\n                p++; \r\n            if(p==2) \r\n            { \r\n                printf(\"%d\\n\",s+i); \r\n                t++; \r\n                break; \r\n            } \r\n        } \r\n        i++; \r\n    } \r\n    return 0; \r\n} \r\n\r\n'),(674,'#include <iostream>\r\nusing namespace std;\r\nchar a[]={\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\'};\r\nbool check(int m,int b)\r\n{string s;\r\nint i;\r\n  do\r\n   {s=a[m%b]+s;\r\n      m/=b;\r\n   }while(m); \r\n   if(s.length()==1)return 1;\r\n   for(i=0;i<=s.length()/2-1;i++)\r\n     if(s[i]!=s[s.length()-i-1])\r\n        return 0;\r\n   return 1;\r\n}\r\nint main()\r\n{\r\n    int c=0,k,n,m,i,j;\r\n    cin>>n>>m;\r\n    for(i=m+1;c<n;i++)\r\n    {\r\n      k=0;\r\n      for(j=2;j<=10;j++)\r\n      {\r\n         if(check(i,j))\r\n            k++;\r\n         if (k==2)\r\n         {c++;\r\n           cout <<i<<endl;\r\n           break;}\r\n         }\r\n      }\r\n    }'),(675,'#include<stdio.h>\r\nmain()\r\n{\r\n	int x;\r\n	int s=2;\r\n	int count=2;\r\n	int i=1;\r\n	while(scanf(\"%d\",&x)!=EOF && x)\r\n	{\r\n		while(1)\r\n		{\r\n			if(x<=count)\r\n			{\r\n				printf(\"%d\\n\",i);\r\n				break;\r\n			}\r\n			i++;\r\n			s*=2;\r\n			count+=s;\r\n		}\r\n		s=2;\r\n		i=1;\r\n		count=2;\r\n	}\r\n}'),(676,'#include<math.h>\r\n#include<stdio.h>\r\nint main()\r\n{\r\nint n,t;\r\nwhile(scanf(\"%d\",&n)!=EOF)\r\n{\r\nif(n==0)\r\nbreak;\r\nt=log(n+1)/log(2);\r\nprintf(\"%d\\n\",t);\r\n}\r\n}\r\n'),(677,'#include<stdio.h>\r\n#include<math.h>\r\npan(int x)\r\n{\r\n	int i;\r\n	for(i=2;i<=sqrt(x);i++)\r\n		if(x%i==0)\r\n			return 1;\r\n	return 0;\r\n}\r\nmain()\r\n{\r\n	int i;\r\n	int x;\r\n	while(scanf(\"%d\",&x)!=EOF && x)\r\n	{\r\n		for(i=4;i<sqrt(x);i++)\r\n			if(x%i==0)\r\n				if(pan(i) && pan(x/i))\r\n				{\r\n					printf(\"Yes\\n\");\r\n					break;\r\n				}\r\n		if(i>sqrt(x))\r\n			printf(\"No\\n\");\r\n	}\r\n}'),(678,'#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n;\r\n    while(cin>>n && n)\r\n    {\r\n        int flag=2,c=0;\r\n        while(n!=1)\r\n        {\r\n            if(n%flag==0) c++, n/=flag;\r\n            else flag++;\r\n        }\r\n        if(c>=4) cout<<\"Yes\"<<endl;\r\n        else cout<<\"No\"<<endl;\r\n    }\r\n}\r\n'),(679,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n=0;\r\n    int i;\r\n    while(1)\r\n    {\r\n            cin>>i;\r\n            if(i==0) break;\r\n            n=n^i;\r\n            \r\n    }\r\n    cout<<n;\r\n   return 0;\r\n}\r\n'),(680,'#include<stdio.h>\r\n\r\nmain(){\r\nint a=1,b;\r\nscanf(\"%d\",&a);\r\nwhile(b!=0){\r\nscanf(\"%d\",&b);\r\na=a^b;\r\n}\r\n\r\nprintf(\"%d\",a);\r\n}\r\n'),(681,'#include<stdio.h>\r\nint main()\r\n{ \r\n	int n ,res;\r\n	while(scanf(\"%d\",&n)!=EOF)\r\n    {	\r\n		res=0;\r\n		if(n==0)\r\n		 return 0;\r\n		res = 2*n +2*n*n;\r\n		\r\n		printf(\"%d\\n\",res);\r\n	}\r\n}'),(682,'#include\"stdio.h\"\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf(\"%d\",&n),n!=0)\r\n		printf(\"%d\\n\",2*n*n+2*n);\r\n}'),(683,'#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{\r\n    char str[100];\r\n    int i;\r\n    str[0]=getchar();\r\n    while(str[0]!=\'#\')\r\n    {\r\n        for(i=1;i<5;i++)\r\n        {\r\n            str[i]=getchar();\r\n        }\r\n        if(str[0]==str[1])\r\n        {\r\n            if(str[0]==str[2])\r\n            {\r\n                if(str[2]==str[3])\r\n                {\r\n                    cout<<150<<endl;\r\n                }\r\n                else cout<<140<<endl;\r\n\r\n            }\r\n            else\r\n            {\r\n                if(str[3]==str[0])cout<<130<<endl;\r\n                else if(str[3]==str[2])cout<<120<<endl;\r\n                else cout<<110<<endl;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if(str[2]==str[0])\r\n            {\r\n                if(str[3]==str[0])cout<<100<<endl;\r\n                else if(str[3]==str[1])cout<<90<<endl;\r\n                else cout<<80<<endl;\r\n            }\r\n            else\r\n            {\r\n                if(str[2]==str[1])\r\n                {\r\n                    if(str[3]==str[0])cout<<70<<endl;\r\n                    else if(str[3]==str[1])cout<<60<<endl;\r\n                    else cout<<50<<endl;\r\n                }\r\n                else\r\n                {\r\n                    if(str[3]==str[0])cout<<40<<endl;\r\n                    else if(str[3]==str[1])cout<<30<<endl;\r\n                    else if(str[3]==str[2])cout<<20<<endl;\r\n                    else cout<<10<<endl;\r\n                }\r\n            }\r\n        }\r\n        str[0]=getchar();\r\n    }\r\n}\r\n'),(684,'#include<stdio.h>\r\nint main()\r\n{\r\n	char a[5];\r\n	while(1)\r\n	{\r\n	scanf(\"%s\",a);\r\n	if(a[0]==\'#\') return 0;\r\n	if(a[1]==a[2]&&a[2]==a[3]&&a[3]==a[0]&&a[0]==a[1])\r\n		printf(\"150\\n\");\r\n	else if(a[0]==a[1]&&a[1]==a[2])\r\n		printf(\"140\\n\");\r\n	else if(a[0]==a[1]&&a[0]==a[3])\r\n		printf(\"130\\n\");\r\n	else if(a[0]==a[1]&&a[2]==a[3])\r\n		printf(\"120\\n\");\r\n	else if(a[0]==a[1]&&a[2]!=a[3])\r\n		printf(\"110\\n\");\r\n	else if(a[0]==a[2]&&a[2]==a[3])\r\n		printf(\"100\\n\");\r\n	else if(a[0]==a[2]&&a[1]==a[3])\r\n		printf(\"90\\n\");\r\n	else if(a[0]==a[2])\r\n		printf(\"80\\n\");\r\n	else if(a[2]==a[1]&&a[0]==a[3])\r\n		printf(\"70\\n\");\r\n	else if(a[1]==a[2]&&a[2]==a[3])\r\n		printf(\"60\\n\");\r\n	else if(a[2]==a[1])\r\n		printf(\"50\\n\");\r\n	else if(a[0]==a[3])\r\n		printf(\"40\\n\");\r\n	else if(a[3]==a[1])\r\n		printf(\"30\\n\");\r\n	else if(a[3]==a[2])\r\n		printf(\"20\\n\");\r\n	else \r\n		printf(\"10\\n\");\r\n	}\r\n	return 0;\r\n}'),(685,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a[35];\r\n	int sum=0;\r\n	while(cin>>a[1])\r\n	{\r\n		a[0]=0;\r\n		if(a[1]==0) break;\r\n		for(int i=2; i<=30; i++) cin>>a[i], a[i]+=a[i-1];\r\n		for(int i=1; i<=30; i++)\r\n		{\r\n			int flag=0;\r\n			for(int j=1; j<=i; j++)\r\n				if(a[i]-a[j-1]==14) \r\n				{\r\n					cout<<j<<\" \"<<i<<endl;\r\n					flag=1;\r\n					break;\r\n				}\r\n			if(flag) break;\r\n		}\r\n	}\r\n	return 0;\r\n}'),(686,'#include<stdio.h>\r\nint main()\r\n{\r\n	int a[30];\r\n	int i,j;\r\n	int m;\r\n	int sum;\r\n	while(1)\r\n	{\r\n	sum=0;\r\n	scanf(\"%d\",a);\r\n	if(a[0]==0) return 0;\r\n	for(m=0;m<29;m++)\r\n	{\r\n		scanf(\"%d\",&a[m+1]);\r\n	}\r\n	for(i=0;sum<14;i++)\r\n	{		\r\n		for(j=i;sum<14;j++)\r\n		{\r\n			sum+=a[j];\r\n		}\r\n		if(sum==14){ i++;break;}\r\n		else sum=0;\r\n	}\r\n	printf(\"%d %d\\n\",i,j);\r\n	}\r\n	return 0;\r\n}'),(687,'#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\nint cday(int y,int m)\r\n{\r\n    int sum=0;\r\n    m--;\r\n    switch(m)\r\n    {\r\n    case 1:\r\n        sum+=31;\r\n        break;\r\n    case 2:\r\n        sum+=60;\r\n        break;\r\n    case 3:\r\n        sum+=91;\r\n        break;\r\n    case 4:\r\n        sum+=121;\r\n        break;\r\n    case 5:\r\n        sum+=152;\r\n        break;\r\n    case 6:\r\n        sum+=182;\r\n        break;\r\n    case 7:\r\n        sum+=213;\r\n        break;\r\n    case 8:\r\n        sum+=244;\r\n        break;\r\n    case 9:\r\n        sum+=274;\r\n        break;\r\n    case 10:\r\n        sum+=305;\r\n        break;\r\n    case 11:\r\n        sum+=335;\r\n        break;\r\n    case 0:\r\n        sum=0;\r\n        break;\r\n    }\r\n    if(m>1)\r\n    {\r\n        if(y%4==0&&y%100!=0||y%400==0)\r\n        {\r\n            return sum;\r\n        }\r\n        return sum-1;\r\n    }\r\n    return sum;\r\n\r\n}\r\nint cday1(int y,int m)\r\n{\r\n    int sum=0;\r\n    switch(m)\r\n    {\r\n    case 1:\r\n        sum+=351;\r\n        break;\r\n    case 2:\r\n        sum+=320;\r\n        break;\r\n    case 3:\r\n        sum+=291;\r\n        break;\r\n    case 4:\r\n        sum+=260;\r\n        break;\r\n    case 5:\r\n        sum+=230;\r\n        break;\r\n    case 6:\r\n        sum+=199;\r\n        break;\r\n    case 7:\r\n        sum+=169;\r\n        break;\r\n    case 8:\r\n        sum+=138;\r\n        break;\r\n    case 9:\r\n        sum+=107;\r\n        break;\r\n    case 10:\r\n        sum+=77;\r\n        break;\r\n    case 11:\r\n        sum+=46;\r\n        break;\r\n    case 12:\r\n        sum+=16;\r\n        break;\r\n    }\r\n    if(m<=2)\r\n    {\r\n        if(y%4==0&&y%100!=0||y%400==0)\r\n        {\r\n            return sum;\r\n        }\r\n        return sum-1;\r\n    }\r\n    return sum;\r\n\r\n}\r\nvoid caculate(int y,int m)\r\n{\r\n    int day,day1=0,sum=0;\r\n    if(y>2000)\r\n    {\r\n        for(int i=2000; i<y; i++)\r\n        {\r\n            if(i%4==0&&i%100!=0||i%400==0)\r\n            {\r\n                day1+=366;\r\n            }\r\n            else day1+=365;\r\n        }\r\n        day=cday(y,m)+15;\r\n        sum=day+day1;\r\n         if(sum%7==1) cout<<14<<endl;\r\n        else if(sum%7==2) cout<<16<<endl;\r\n        else cout<<15<<endl;\r\n    }\r\n    else\r\n    {\r\n        for(int i=1999;i>y;i--)\r\n        {\r\n            if(i%4==0&&i%100!=0||i%400==0)\r\n            {\r\n                day1+=366;\r\n            }\r\n            else day1+=365;\r\n        }\r\n        day=cday1(y,m);\r\n        sum=day1+day;\r\n        if(sum%7==5)cout<<16<<endl;\r\n        else if(sum%7==6)cout<<14<<endl;\r\n        else cout<<15<<endl;\r\n\r\n    }\r\n\r\n\r\n}\r\nint main()\r\n{\r\n    int y,m;\r\n    cin>>y>>m;\r\n    while(y&&m)\r\n    {\r\n        caculate(y,m);\r\n        cin>>y>>m;\r\n    }\r\n}\r\n'),(688,'#include <iostream> \r\n#include <cstring> \r\n#include <cstdio> \r\n\r\n\r\nusing namespace std; \r\nint a[5000][30]; \r\nint main() \r\n{ \r\nint flag=0; \r\nint n, m; \r\nwhile(cin>>n>>m && n+m) \r\n{ \r\nif(n==2013) flag=1; \r\n} \r\nif(flag) cout<<16<<endl<<15<<endl<<14<<endl; \r\nelse cout<<15<<endl<<16<<endl<<14<<endl; \r\nreturn 0; \r\n} '),(689,'#include<cstdio>\r\n#include<iostream>\r\n#include<cstring>\r\n#include<string>\r\nusing namespace std;\r\nbool isMatch(const char *s, const char *p) {\r\n        // Note: The Solution object is instantiated only once and is reused by each test case.\r\n        if(*p == \'\\0\')\r\n		return *s == \'\\0\' ;\r\n	if(*(p+1) != \'*\')\r\n	{\r\n		return ((*p == *s)||(*p == \'.\' && *s != \'\\0\'))\r\n				&& isMatch(s+1,p+1);\r\n	}\r\n	while ((*p == *s) || (*p == \'.\' && *s != \'\\0\'))\r\n	{\r\n        if (isMatch(s, p+2))\r\n        	return true;\r\n        s++;\r\n    }\r\n    return isMatch(s, p+2);\r\n    }\r\n    //\"124\",\"*23\"\r\nint main(){\r\n    string s;\r\n\r\n    while(cin>>s){\r\n        char *a=new char[s.length()];\r\n        char *b=new char[s.length()];\r\n        int i=1;\r\n        int j=0;\r\n                while(s[i]!=\'\\\"\'){\r\n                    a[j++]=s[i++];\r\n                }\r\n                a[j]=0;\r\n                i+=3;\r\n                j=0;\r\n                while(s[i]!=\'\\\"\'){\r\n                    b[j++]=s[i++];\r\n                }\r\n                b[j]=0;\r\n        if(isMatch(a,b))\r\n            cout<<\"true\"<<endl;\r\n        else cout<<\"false\"<<endl;\r\n        delete[] a,b;\r\n    }\r\n}\r\n'),(690,'#include <iostream>\r\n#include <string>\r\n#include <set>\r\n#include <queue>\r\n\r\nusing namespace std;\r\n\r\nbool ismatch(const char *a, const char*b)\r\n{\r\n	if(*b==0) return *a==0;\r\n	if(*(b+1)!=\'*\')\r\n	{\r\n		if((*b)==(*a) || ((*b)==\'.\' && (*a)!=0)) return ismatch(a+1, b+1);\r\n		return false;\r\n	}\r\n	else\r\n	{\r\n		while((*b)==(*a) || ((*b)==\'.\' && (*a)!=0))\r\n		{\r\n			if(ismatch(a, b+2)) return true;\r\n			a++;\r\n		}\r\n		return ismatch(a, b+2);\r\n	}\r\n	return false;\r\n}\r\n\r\nint main()\r\n{\r\n	string str;\r\n	while(cin>>str)\r\n	{\r\n		string a, b;\r\n		int flag=0, r=0;\r\n		for(int i=0; i<str.size(); i++)\r\n		{\r\n			if(str[i]==\',\') { flag=1; continue; }\r\n			else if(str[i]==\'\\\"\') { r=!r; continue; }\r\n			if(flag && r) b+=str[i];\r\n			else if(r) a+=str[i];\r\n		}\r\n		cout<<(ismatch(a.c_str(), b.c_str())?\"true\":\"false\")<<endl;\r\n	}\r\n	return 0;\r\n}\r\n'),(691,'#include <stdio.h> \r\nint main() \r\n{ \r\n    int n=0,t=0; \r\n    char r[5][11][5]={{{0},{\'I\'},{\'I\',\'I\'},{\'I\',\'I\',\'I\'},{\'I\',\'V\'},{\'V\'},{\'V\',\'I\'},{\'V\',\'I\',\'I\'},{\'V\',\'I\',\'I\',\'I\'},{\'I\',\'X\'}},{{0},{\'X\'},{\'X\',\'X\'},{\'X\',\'X\',\'X\'},{\'X\',\'L\'},{\'L\'},{\'L\',\'X\'},{\'L\',\'X\',\'X\'},{\'L\',\'X\',\'X\',\'X\'},{\'X\',\'C\'}},{{0},{\'C\'},{\'C\',\'C\'},{\'C\',\'C\',\'C\'},{\'C\',\'D\'},{\'D\'},{\'D\',\'C\'},{\'D\',\'C\',\'C\'},{\'D\',\'C\',\'C\',\'C\'},{\'C\',\'M\'}},{{0},{\'M\'},{\'M\',\'M\'},{\'M\',\'M\',\'M\'},{\'M\',\'M\',\'M\'}}}; \r\n    while(scanf(\"%d\",&n)!=EOF) \r\n    { \r\n        int a[6]={0},i=0; \r\n        t=n; \r\n        while(t) \r\n        { \r\n            a[i]=t%10; \r\n            t/=10; \r\n            i++; \r\n        } \r\n        for(int q=i-1;q>=0;q--) \r\n            printf(\"%s\",r[q][a[q]]); \r\n        printf(\"\\n\"); \r\n    } \r\n} '),(692,'#include <iostream>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    char *b[100]={0};\r\n    int m=0,p=0,x=0;\r\n   while(cin>>n&&n!=0)\r\n   {\r\n       p=0;\r\n       x=0;\r\n       m=0;\r\n    char *a[][10]={\" \",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\" \",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\" \",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\" \",\"M\",\"MM\",\"MMM\"};\r\n    while(n>0.99999)\r\n    {\r\n        x=n%10;\r\n        n=n/10;\r\n        b[m]=a[p][x];\r\n        p++;\r\n        m++;\r\n    }\r\n    for(int i=m-1;i>=0;i--)\r\n    printf(\"%s\",b[i]);\r\n    cout<<endl;\r\n   }\r\n}\r\n'),(693,'#include <stdio.h> \r\nint main() \r\n{ \r\n    char r[20]={0}; \r\n    while(scanf(\"%s\",r)!=EOF) \r\n    { \r\n        int n=0,k=0,s=0,g=0; \r\n        for(int i=0;i<20;i++) \r\n        { \r\n            if(r[i]==\'M\') k==1?n+=800:n+=1000; \r\n            if(r[i]==\'D\') k==1?n+=300:n+=500; \r\n            if(r[i]==\'C\') s==1?n+=80:n=n+100,k=1; \r\n            if(r[i]==\'L\') s==1?n+=30:n+=50; \r\n            if(r[i]==\'X\') g==1?n+=8:n=n+10,s=1; \r\n            if(r[i]==\'V\') g==1?n+=3:n+=5; \r\n            if(r[i]==\'I\') n=n+1,g=1; \r\n        } \r\n        printf(\"%d\\n\",n); \r\n        for(int t=0;t<20;t++) \r\n        r[t]=0; \r\n    } \r\n} \r\n  '),(694,'#include <stdio.h>\r\nint main()\r\n{\r\n    char r[20]={0};\r\n    while(scanf(\"%s\",r)!=EOF)\r\n    {\r\n        int n=0,k=0,s=0,g=0;\r\n        for(int i=0;i<20;i++)\r\n        {\r\n            if(r[i]==\'M\') k==1?n+=800:n+=1000;\r\n            if(r[i]==\'D\') k==1?n+=300:n+=500;\r\n            if(r[i]==\'C\') s==1?n+=80:n=n+100,k=1;\r\n            if(r[i]==\'L\') s==1?n+=30:n+=50;\r\n            if(r[i]==\'X\') g==1?n+=8:n=n+10,s=1;\r\n            if(r[i]==\'V\') g==1?n+=3:n+=5;\r\n            if(r[i]==\'I\') n=n+1,g=1;\r\n        }\r\n        printf(\"%d\\n\",n);\r\n        for(int t=0;t<20;t++)\r\n        r[t]=0;\r\n    }\r\n}'),(695,'#include<cstdio> \r\n#include<iostream> \r\n#include<cstring> \r\n#include<string> \r\nusing namespace std; \r\nbool isMatch(const char *s, const char *p) \r\n{ \r\n    bool star = false; \r\n    const char *str, *ptr; \r\n    for (str = s, ptr = p; *str != \'\\0\'; str++, ptr++) \r\n    { \r\n        switch (*ptr) \r\n        { \r\n        case \'?\': \r\n            break; \r\n        case \'*\': \r\n            star = true; \r\n            s = str, p = ptr; \r\n            while (*p == \'*\') p++; \r\n            if (*p == \'\\0\') return true; \r\n            str = s - 1; \r\n            ptr = p - 1; \r\n            break; \r\n        default: \r\n            if (*str != *ptr) \r\n            { \r\n// 如果前面没有\'*\'，则匹配不成功 \r\n                if (!star) return false; \r\n                s++; \r\n                str = s - 1; \r\n                ptr = p - 1; \r\n            } \r\n        } \r\n    } \r\n    while (*ptr == \'*\') ptr++; \r\n    return (*ptr == \'\\0\'); \r\n} \r\n//\"124\",\"*23\" \r\nint main() \r\n{ \r\n    string s; \r\n  \r\n    while(cin>>s) \r\n    { \r\n        char *a=new char[s.length()]; \r\n        char *b=new char[s.length()]; \r\n        int i=1; \r\n        int j=0; \r\n        while(s[i]!=\'\\\"\') \r\n        { \r\n            a[j++]=s[i++]; \r\n        } \r\n        a[j]=0; \r\n        i+=3; \r\n        j=0; \r\n        while(s[i]!=\'\\\"\') \r\n        { \r\n            b[j++]=s[i++]; \r\n        } \r\n        b[j]=0; \r\n        if(isMatch(a,b)) \r\n            cout<<\"true\"<<endl; \r\n        else cout<<\"false\"<<endl; \r\n        delete[] a,b; \r\n    } \r\n}'),(696,'#include<cstdio>\r\n#include<iostream>\r\n#include<cstring>\r\n#include<string>\r\nusing namespace std;\r\nbool isMatch(const char *s, const char *p)\r\n{\r\n    bool star = false;\r\n    const char *str, *ptr;\r\n    for (str = s, ptr = p; *str != \'\\0\'; str++, ptr++)\r\n    {\r\n        switch (*ptr)\r\n        {\r\n        case \'?\':\r\n            break;\r\n        case \'*\':\r\n            star = true;\r\n            s = str, p = ptr;\r\n            while (*p == \'*\') p++;\r\n            if (*p == \'\\0\') return true;\r\n            str = s - 1;\r\n            ptr = p - 1;\r\n            break;\r\n        default:\r\n            if (*str != *ptr)\r\n            {\r\n// 如果前面没有\'*\'，则匹配不成功\r\n                if (!star) return false;\r\n                s++;\r\n                str = s - 1;\r\n                ptr = p - 1;\r\n            }\r\n        }\r\n    }\r\n    while (*ptr == \'*\') ptr++;\r\n    return (*ptr == \'\\0\');\r\n}\r\n//\"124\",\"*23\"\r\nint main()\r\n{\r\n    string s;\r\n\r\n    while(cin>>s)\r\n    {\r\n        char *a=new char[s.length()];\r\n        char *b=new char[s.length()];\r\n        int i=1;\r\n        int j=0;\r\n        while(s[i]!=\'\\\"\')\r\n        {\r\n            a[j++]=s[i++];\r\n        }\r\n        a[j]=0;\r\n        i+=3;\r\n        j=0;\r\n        while(s[i]!=\'\\\"\')\r\n        {\r\n            b[j++]=s[i++];\r\n        }\r\n        b[j]=0;\r\n        if(isMatch(a,b))\r\n            cout<<\"true\"<<endl;\r\n        else cout<<\"false\"<<endl;\r\n        delete[] a,b;\r\n    }\r\n}\r\n'),(697,'#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\nint main()\r\n{\r\n    string a,b;\r\n    while(cin>>a>>b)\r\n    {\r\n        int i=a.find(b);\r\n        if(i==-1)\r\n            cout<<\"NULL\"<<endl;\r\n        else\r\n            cout<<a.substr(i,a.length()-1)<<endl;\r\n    }\r\n    return 0;\r\n}\r\n'),(698,'#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\nint main()\r\n{\r\n    string a,b;\r\n    while(cin>>a>>b)\r\n        a.find(b)==-1?cout<<\"NULL\"<<endl:cout<<a.substr(a.find(b),a.length()-1)<<endl;\r\n    return 0;\r\n}\r\n'),(699,'#include<iostream> \r\n#include<stack> \r\n#include<string> \r\nusing namespace std; \r\nbool f(const string& s){ \r\n    stack<char> a; \r\n    for(int i=0;i<s.length();i++){ \r\n        if((s[i]==\'}\'||s[i]==\')\'||s[i]==\']\')&&a.size()==0)return 0; \r\n        if(s[i]==\'{\'||s[i]==\'(\'||s[i]==\'[\'){ \r\n            a.push(s[i]); \r\n        } \r\n        else if(s[i]==\')\'){ \r\n            if(a.top()==\'(\')a.pop(); \r\n            else return 0; \r\n        } \r\n        else if(s[i]==\'}\'){ \r\n            if(a.top()==\'{\')a.pop(); \r\n            else return 0; \r\n        } \r\n        else{ \r\n            if(a.top()==\'[\')a.pop(); \r\n            else return 0; \r\n        } \r\n    } \r\n    if(a.size()>0)return 0; \r\n    return 1; \r\n} \r\nint main(){ \r\n    //freopen(\"in.txt\",\"r\",stdin); \r\n    string s; \r\n    while(cin>>s){ \r\n        if(f(s))cout<<\"true\"<<endl; \r\n        else cout<<\"false\"<<endl; \r\n    } \r\n}'),(700,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n\r\nusing namespace std;\r\nclass Stack{\r\n    public:\r\n    char a[200];\r\n    int top;\r\n    Stack()\r\n    {\r\n        memset(a,0,sizeof(char)*200);\r\n        top=0;\r\n    }\r\n};\r\nint main()\r\n{\r\n    Stack s;\r\n    char b[200]={0};\r\n    int i=0;\r\n    while(cin>>b)\r\n    {\r\n        s.top=0;\r\n        s.a[s.top]=\'0\';\r\n        i=0;\r\n    while(1)\r\n    {\r\n        if(b[i]==\'\\0\') break;\r\n        if((s.a[s.top-1]==(b[i]-1))||(s.a[s.top-1]==(b[i]-2)))\r\n        {s.top--;i++;}\r\n        else  s.a[s.top++]=b[i++];\r\n    }\r\n    if(s.top==0) cout<<\"true\"<<endl;\r\n    else cout<<\"false\"<<endl;\r\n\r\n    }return 0;\r\n}\r\n'),(701,'#include<stdio.h>\r\nint search_row1_row2_cow(int arr[100][100], int a,int b,int c)\r\n{\r\n	int k;\r\n	if(a>b)\r\n    {\r\n    	k=a;\r\n    	a=b;\r\n    	b=k;	\r\n    }\r\n	for(k=a+1;k<b;k++)\r\n	if(arr[k][c]!=0)\r\n		return 1;\r\n	return 0;	\r\n}\r\n\r\n\r\n\r\nint search_cow1_cow2_row(int arr[100][100], int a,int b,int c)\r\n{\r\n	int k;\r\n	if(a>b)\r\n    {\r\n    	k=a;\r\n    	a=b;\r\n    	b=k;	\r\n    }\r\n	for(k=a+1;k<b;k++)\r\n	if(arr[c][k]!=0)\r\n		return 1;\r\n	return 0;\r\n}\r\n\r\n\r\nvoid judge_1(int arr[100][100],int row1,int cow1,int row2, int cow2)\r\n{\r\n	int a,b,c,d;\r\n	if(arr[row1][cow1]==arr[row2][cow2])\r\n   	  { \r\n   	     if(row1!=row2&&cow1!=cow2)\r\n   	     {\r\n            if(arr[row1][cow2]==0||arr[row2][cow1]==0)\r\n            {\r\n               a=search_row1_row2_cow(arr,row1,row2,cow1);\r\n               b=search_cow1_cow2_row(arr,cow1,cow2,row2);\r\n               c=search_row1_row2_cow(arr,row1,row2,cow2);\r\n               d=search_cow1_cow2_row(arr,cow1,cow2,row1);\r\n               if((a==0&&b==0)||(c==0&&d==0))\r\n               {\r\n               	  arr[row1][cow1]=0;\r\n				  arr[row2][cow2]=0;\r\n                  printf(\"Yes\\n\");\r\n               }\r\n               else\r\n               printf(\"No\\n\");\r\n	        }\r\n	        else\r\n	        printf(\"No\\n\");\r\n	     }\r\n	     else if(row1==row2)\r\n	     {\r\n	     	a=search_cow1_cow2_row(arr,cow1,cow2,row1);\r\n	     	if(a==0)\r\n	        printf(\"Yes\\n\");\r\n	        else\r\n	        printf(\"No\\n\");\r\n	     }\r\n	     else if(cow1==cow2)\r\n	     {\r\n	     	a=search_row1_row2_cow(arr,row1,row2,cow1);\r\n	     	if(a==0)\r\n	        printf(\"Yes\\n\");\r\n	        else\r\n	        printf(\"No\\n\");\r\n	     }\r\n      }\r\n      else\r\n      printf(\"No\\n\");\r\n} \r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n   int row,cow,k,i,time;\r\n   int row1,cow1,row2,cow2;\r\n   scanf(\"%d %d\",&row,&cow);\r\n   int arr[100][100]; \r\n   for( k=0;k<row;k++)\r\n   for( i=0;i<cow;i++)\r\n   scanf(\"%d \",&arr[k][i]);\r\n   scanf(\"%d\",&time);\r\n   for(k=1;k<=time;k++)\r\n   {\r\n   	  scanf(\"%d %d %d %d\",&row1,&cow1,&row2,&cow2);\r\n   	  judge_1(arr,row1,cow1,row2,cow2);\r\n   } \r\n}'),(702,'#include<cstdio>\r\n#include<iostream>\r\nusing namespace std;\r\nint a[100][100];\r\nbool g(int x1,int y1,int x2,int y2,int sel){\r\n	if(sel==1){\r\n		for(int i=std::min(y1,y2)+1;i<std::max(y1,y2);++i){\r\n			if(a[x1][i]!=0)return false;\r\n		}\r\n		return true;\r\n	}\r\n	else{\r\n		for(int i=std::min(x1,x2)+1;i<std::max(x1,x2);++i){\r\n			if(a[i][y1]!=0)return false;\r\n		}\r\n		return true;\r\n	}\r\n	return false;\r\n}\r\nbool f(int x1,int y1,int x2,int y2){\r\n	if(a[x1][y1]!=a[x2][y2])return false;\r\n	if(g(x1,y1,x1,y2,1)&&g(x1,y2,x2,y2,2)&&(!a[x1][y2]))return true;\r\n	if(g(x1,y1,x2,y1,2)&&g(x2,y1,x2,y2,1)&&(!a[x2][y1]))return true;\r\n	return false;\r\n}\r\nint main(){\r\n	//freopen(\"in.txt\",\"r\",stdin);\r\n	//ofstream fout(\"out1.txt\");\r\n	int m,n;\r\n	int k;\r\n	int x1,y1,x2,y2;\r\n	cin>>m>>n;\r\n	for(int i=0;i<m;i++){\r\n		for(int j=0;j<n;j++){\r\n			cin>>a[i][j];\r\n		}\r\n	}\r\n	cin>>k;\r\n	while(k--){\r\n		cin>>x1>>y1>>x2>>y2;\r\n		if(f(x1,y1,x2,y2)==1){\r\n			cout<<\"Yes\"<<endl;\r\n			a[x1][y1]=0;\r\n			a[x2][y2]=0;\r\n		}\r\n		else cout<<\"No\"<<endl;\r\n	}\r\n}'),(703,'#include<stdio.h>\r\nint main()\r\n{\r\n    int n,min=0,a,m;\r\n    scanf(\"%d\",&n);\r\n    scanf(\"%d\",&a);\r\n    min=a;\r\n    m=1;\r\n    for(int i=1;i<n;i++)\r\n    {\r\n        scanf(\"%d\",&a);\r\n        if(a<min) min=a,m=i+1;\r\n    }\r\n    printf(\"%d\",m);\r\n    return 0;\r\n}'),(704,'#include<stdio.h>\r\nint main(){\r\nint n,i,a[9999],min=9999,m=0;\r\nscanf(\"%d\",&n);\r\nfor(i=0;i<n;i++){\r\nscanf(\"%d\",&a[i]);\r\nif(a[i]<min){\r\nmin=a[i];\r\nm=i+1;}\r\n}\r\nprintf(\"%d\",m);\r\nreturn 0;}'),(705,'#include <cstdio>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	char str[100];\r\n	int n, m;\r\n	cin>>n;\r\n	for(int i=0; i<n; i++)\r\n	{\r\n		gets(str);\r\n		int res=0;\r\n		for(char *a=str; *a; a++)\r\n		{\r\n			if(*a==\' \') res++;\r\n		}\r\n		if(res==n-1) { cout<<\"YES\"<<endl; return 0;}\r\n	}\r\n	cout<<\"NO\"<<endl;\r\n}'),(706,'#include<stdio.h>\r\nint main()\r\n{\r\n	int m,n,i,j,t;\r\n	scanf(\"%d%d\",&n,&m);\r\n	for(i=0;i<n;i++)\r\n	for(j=1;j<m;j++)\r\n	scanf(\"%d\",&t);\r\n	{	if(m==t)\r\n		printf(\"YES\\n\");\r\n	else \r\n		printf(\"NO\\n\");\r\n	}\r\n	\r\n	return 0;\r\n\r\n\r\n	\r\n}'),(707,'#include <stdio.h>\r\nint main()\r\n{\r\n    int a[1000][1000];\r\n    int m,n,i,j;\r\n    int x,y,z;\r\n    scanf(\"%d%d\",&n,&m);\r\n    x=0,y=0;\r\n    z=0;\r\n    for(i=0;i<n;i++)\r\n\r\n        for(j=0;j<m;j++)\r\n        {\r\n            scanf(\"%d\",&a[i][j]);\r\n            if(a[i][j]>a[x][y])\r\n                z=i,x=i,y=j;\r\n        }\r\n        printf(\"%d\\n\",z+1);\r\n    return 0;\r\n}'),(708,'#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n, m, ans, tmp=0, a;\r\n	cin>>n>>m;\r\n	for(int i=1; i<=n; i++)\r\n		for(int j=1; j<=m; j++)\r\n		{\r\n			cin>>a;\r\n			if(a>tmp) tmp=a, ans=i;\r\n		}\r\n	cout<<ans<<endl;\r\n}'),(709,'#include <stdio.h>\r\n#include <iostream>\r\n#include <cstring>\r\nusing namespace std;\r\nint a[1000];\r\nint main()\r\n{\r\n    int n;\r\n    int sum=0;\r\n    for(cin>>n;n--;)\r\n    {\r\n        int cou,m;\r\n        cin>>cou>>m;\r\n        sum+=m;\r\n        for(int i=0;i<cou;++i)\r\n        {\r\n            cin>>a[i];\r\n            if(a[i]<m)\r\n            sum+=(20);\r\n        }\r\n    }\r\n    cout<<sum<<endl;\r\n\r\n\r\n    return 0;\r\n}\r\n'),(710,'#include<stdio.h>\r\nint main()\r\n{\r\n	int i,a,j,m,n,k[100],sum=0;\r\n	scanf(\"%d\",&i);\r\n	for(n=1;n<=i;n++)\r\n	{\r\n		scanf(\"%d\",&m);\r\n		scanf(\"%d\",&a);\r\n		for(j=0;j<m;j++)\r\n		{\r\n			scanf(\"%d\",&k[j]);\r\n			if(k[j]==a)\r\n				sum=sum+j*20+a;\r\n		}\r\n	}\r\n	printf(\"%d\\n\",sum);\r\n	return 0;\r\n}'),(711,'#include <stdio.h>\r\nint main()\r\n{\r\n	char a;\r\n	int t=0,s=0;\r\n	while((a=getchar())!=EOF)\r\n	{\r\n	    if(t==4 || s==4) continue;\r\n	    if(a==\'/\' && s==0)\r\n            s=1;\r\n            else if(a==\' \' && (s==1 || s==2 || s==3))\r\n                ;\r\n                else if(a==\'=\' && s==1)\r\n                    s=2;\r\n                    else if(a==\'0\' && s==2)\r\n                        s=3;\r\n                        else if((a==\';\'||a==\')\') && s==3)\r\n                            s=4;\r\n                            else\r\n                            s=0;\r\n	    if(a==\'=\' && t==0)\r\n            t=1;\r\n        else if(a==\' \' && (t==1 || t==2 || t==3))\r\n                ;\r\n            else if(((a>=\'0\'&&a<=\'9\')||(a>=\'a\'&&a<=\'z\')||(a==\'(\')) && t==1)\r\n                t=1;\r\n                else if(a==\'/\' && t==1)\r\n                    t=2;\r\n                    else if(a==\'0\' && t==2)\r\n                        t=3;\r\n                        else if((a==\';\'||a==\')\') && t==3)\r\n                            t=4;\r\n                            else\r\n                            t=0;\r\n	}\r\n	if(t==4 || s==4)printf(\"Runtime Error!\");\r\n	else printf(\"GOOD!\");\r\n}'),(712,'#include <stdio.h>\r\n#include<string.h>\r\nchar a[1000];\r\nint main()\r\n{\r\n	int length,i;\r\n	int mark=0;\r\n	while(gets(a)){\r\n		 length = strlen(a);\r\n		 for(i=0;i<length-3;i++){\r\n		 	if(a[i]==\'/\'&&a[i+2]==\'0\')\r\n		 	mark=1;\r\n		 }\r\n	}\r\n		if(mark)\r\n		printf(\"Runtime Error!\\n\");\r\n		else{\r\n			printf(\"GOOD!\\n\");\r\n		}\r\n}'),(713,'#include <stdio.h>\r\n#include <iostream>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    char a[1000];\r\n    char b[1000];\r\n    gets(a);\r\n    gets(b);\r\n    int res1=0;\r\n    int res2=0;\r\n    int l1=strlen(a);\r\n    int l2=strlen(b);\r\n    for(int i=0;i<l1;++i)\r\n        res1+=(int)a[i];\r\n    for(int i=0;i<l2;++i)\r\n        res2+=(int)b[i];\r\n\r\n    printf(\"%s\\n\",res1>res2?a:b);\r\n    return 0;\r\n}\r\n'),(714,'#include<stdio.h>\r\nint main()\r\n{\r\n    char a[100]={0},b[100]={0};\r\n    int n=0,m=0,i=0;\r\n    gets(a);gets(b);\r\n    for(i=0;i<100;i++)  n=n+a[i],m=m+b[i];\r\n    printf(\"%s\",(n>m)?a:b);\r\n    return 0;\r\n}'),(715,'#include <cstdio>\r\n#include <cmath>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nbool pan(int a)\r\n{\r\n	if(a<2) return false;\r\n	for(int i=2; i<=sqrt(a); i++) \r\n		if(a%i==0) return false;\r\n	return true;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	int a=0, b=1, c;\r\n	for(int i=0; i<=n; i++)\r\n	{\r\n		if(pan(a)) cout<<a<<endl;\r\n		c=a+b, a=b, b=c;\r\n	}\r\n	return 0;\r\n}'),(716,'#include<stdio.h>\r\nint pan(int x)\r\n{\r\n	for(int i=2;i<x;i++)\r\n		if(x%i==0)\r\n			return 0;\r\n	return 1;\r\n}\r\nint main()\r\n{\r\n	int n,a[40]={0,1,1};\r\n	scanf(\"%d\",&n);\r\n	for(int i=3;i<n;i++)\r\n	{\r\n		a[i]=a[i-1]+a[i-2];\r\n		if(pan(a[i])==1)\r\n			printf(\"%d\\n\",a[i]);\r\n	}\r\n}'),(717,'#include<iostream>\r\n#include<cstdio>\r\n#include<cstring>\r\n#include<cstdlib>\r\n#include<cmath>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n,m;\r\n    double d=0;\r\n    cin>>n>>m;\r\n    for(int i=1;i<n;i++)\r\n    {\r\n        double p=(double)i/n*(n+m);\r\n        d=d+fabs(p-floor(p+0.5))/(n+m);\r\n    }\r\n    printf(\"%.4f\",d*10000);\r\nreturn 0;\r\n}'),(718,'#include<stdio.h>\r\n#include<math.h>\r\ndouble f(int n,int m)\r\n{\r\n   double r=0,  x=(m+n)*1.0/n;\r\n   for(int i=1;i<n;i++)\r\n      r+=fabs(x*i-(int)(x*i+0.5))/(m+n);\r\n   return r*10000;\r\n\r\n}\r\nint main()\r\n{\r\n	int n,m;\r\n	while(scanf(\"%d%d\",&n,&m)!=-1)\r\n		printf(\"%.4lf\\n\",f(n,m));\r\n}'),(719,'#include <stdio.h> \r\nint getSum( int x ); \r\nint main( ) \r\n{ \r\n    int m ,n, t, count; \r\n    while(scanf(\"%d%d\", &m,&n)!=EOF && m && n ) \r\n    { \r\n        count=0; \r\n        if( m > n ){t=m; m=n; n=t;} \r\n        for(t=m; t<=n; t++) \r\n        { \r\n            if( getSum(t) % 11 == 0 ) \r\n                ++count; \r\n        } \r\n        printf(\"%d\\n\", count); \r\n    } \r\n} \r\nint getSum( int x) \r\n{ \r\n    int s=0; \r\n    while ( x ) \r\n    { \r\n        s += x % 10; \r\n        x /= 10; \r\n    } \r\n    return s; \r\n}'),(720,'#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\nint ji(int n)\r\n{  int sum=0;\r\n  while(n)\r\n  {\r\n      sum+=n%10;\r\n      n/=10;\r\n  }\r\n\r\n   return sum;\r\n}\r\nint main()\r\n{\r\n int n,m,count;\r\n while(cin>>m>>n&&(n+m))\r\n {count=0;\r\n  if(m>n)\r\n  swap(m,n);\r\n  for(m;m<=n;m++)\r\n  if(!(ji(m)%11))\r\n    count++;\r\n  cout<<count<<endl;\r\n }\r\n}\r\n'),(721,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int fac[100]={0,1,1};\r\n	int i;\r\n	int n;\r\n\r\n	for(i=3; i<100; i++)\r\n		fac[i]=fac[i-1]+fac[i-2];\r\n	while( scanf(\"%d\", &n)!=EOF && n)\r\n	{\r\n		printf(\"%d\\n\", fac[n]);\r\n	}\r\n	return 0;\r\n}'),(722,'#include<iostream>\r\nusing namespace std;\r\nint a[42]={0,1};\r\nint main()\r\n{  int i,n;\r\n   for(i=2;i<42;i++)\r\n   a[i]=a[i-1]+a[i-2];\r\n   while(cin>>n&&n)\r\n   cout<<a[n]<<endl;\r\n   return 0;\r\n\r\n}\r\n\r\n\r\n\r\n'),(723,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int n;\r\n\r\n	while ( scanf(\"%d\", &n)!=EOF )\r\n	{\r\n		if( n*395>=3000 )\r\n			printf(\"%.2lf\\n\", 395*.2);\r\n		else if( n*395>=1000 )\r\n			printf(\"%.2lf\\n\", 395*.1);\r\n		else \r\n			printf(\"0.00\\n\");\r\n	}\r\n	return 0;\r\n}'),(724,'#include <stdio.h>\r\nint main()\r\n{\r\n	int n;\r\n	while (scanf(\"%d\",&n)!=EOF)\r\n	{\r\n	if (n<3)\r\n		printf(\"0.00\\n\");\r\n	else if (n>=3 && n<8)\r\n		printf(\"39.50\\n\");\r\n	else \r\n		printf(\"79.00\\n\");\r\n	}\r\n}'),(725,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int n;\r\n	int t;\r\n	int i;\r\n	int start,stop;\r\n	while ( scanf(\"%d\", &n) && n )\r\n	{\r\n		t = 0;\r\n		start=0;\r\n		for(i=0; i<n; i++)\r\n		{\r\n			scanf(\"%d\", &stop);\r\n			if( stop > start )\r\n				t += (stop-start)*6;\r\n			else\r\n				t += (start - stop)*4;\r\n			t+=5;\r\n			start = stop;\r\n\r\n		}\r\n		printf(\"%d\\n\", t);\r\n	}\r\n	return 0;\r\n}'),(726,'#include<stdio.h>\r\nint f(int n)\r\n{\r\n	int sum=n*5;\r\n	int a,oa=0;\r\n	for(int i=0;i<n;i++)\r\n	{\r\n		scanf(\"%d\",&a);\r\n		if(a>=oa)sum+=6*(a-oa);\r\n		else sum+=4*(oa-a);\r\n		oa=a;\r\n	}\r\n	return sum;\r\n}\r\nint main()\r\n{\r\n	int a;\r\n	\r\n  while( scanf(\"%d\",&a)&& a)\r\n	  printf(\"%d\\n\",f(a));\r\n \r\n}'),(727,'#include <stdio.h>\r\n#define LEN 1001\r\nint count=0;\r\nint binsearch( int *p, int x, int n);\r\nint main( )\r\n{\r\n	int n;\r\n	int R[LEN];\r\n	int i,x;\r\n	while( scanf(\"%d\", &n)!=EOF )\r\n	{\r\n		count = 0;\r\n		for(i=0; i<n; ++i)\r\n			scanf(\"%d\", &R[i]);\r\n		scanf(\"%d\", &x);\r\n		if( binsearch(R,x,n)!= -1 )\r\n			printf(\"%d\\n\",count);\r\n		else\r\n			printf(\"%d NO\\n\",count);\r\n	}\r\n	return 0;\r\n}\r\nint binsearch( int *p, int x, int n)\r\n{\r\n	int low, mid, high;\r\n	low =0;\r\n	high = n-1;\r\n	while( low <= high)\r\n	{\r\n		mid = (low+high)/2;\r\n		if( x == p[mid] )\r\n		{count++;\r\n		return mid;\r\n		}\r\n		else if ( x<p[mid] )\r\n			high = mid - 1;\r\n		else\r\n			low = mid + 1;\r\n		count++;\r\n	}\r\n	return -1;\r\n}'),(728,'#include <stdio.h>\r\n#define LEN 1001\r\nint count=0;\r\nint binsearch( int *p, int x, int n);\r\nint main( )\r\n{\r\n	int n;\r\n	int R[LEN];\r\n	int i,x;\r\n	while( scanf(\"%d\", &n)!=EOF )\r\n	{\r\n		count = 0;\r\n		for(i=0; i<n; ++i)\r\n			scanf(\"%d\", &R[i]);\r\n		scanf(\"%d\", &x);\r\n		if( binsearch(R,x,n)!= -1 )\r\n			printf(\"%d\\n\",count);\r\n		else\r\n			printf(\"%d NO\\n\",count);\r\n	}\r\n	return 0;\r\n}\r\nint binsearch( int *p, int x, int n)\r\n{\r\n	int low, mid, high;\r\n	low =0;\r\n	high = n-1;\r\n	while( low <= high)\r\n	{\r\n		mid = (low+high)/2;\r\n		if( x == p[mid] )\r\n		{count++;\r\n		return mid;\r\n		}\r\n		else if ( x<p[mid] )\r\n			high = mid - 1;\r\n		else\r\n			low = mid + 1;\r\n		count++;\r\n	}\r\n	return -1;\r\n}'),(729,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int n;\r\n	int flag;\r\n	while( scanf(\"%d\", &n) != EOF)\r\n	{\r\n		flag = 1;\r\n		while( n )\r\n		{\r\n			if(n%10 )\r\n			{\r\n				printf(\"%d\",n%10);\r\n				flag = 0;\r\n				\r\n			}\r\n			else\r\n			{\r\n				if( flag == 0 )\r\n					printf(\"%d\",n%10);\r\n			}\r\n			n/=10;\r\n		}\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(730,'#include<stdio.h>\r\nint main()\r\n{\r\n int n,m;\r\n while(scanf(\"%d\",&n)!=EOF)\r\n {\r\n    m=0;\r\n while(n)\r\n {\r\n  m=m*10+n%10;\r\n  n=n/10;\r\n }\r\n printf(\"%d\\n\",m);\r\n }\r\n\r\n return 0;\r\n}\r\n'),(731,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;cin>>n;\r\n	while(n--)\r\n	{\r\n		char a[1000];\r\n		cin>>a;\r\n		int i=0;\r\n		int count=0;\r\n		while(a[i])\r\n		{\r\n			if(a[i]>=0&&a[i]<128)count++;\r\n			i++;\r\n		}\r\n		cout<<(i-count)/3<<endl;\r\n	}\r\n}'),(732,'#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;cin>>n;\r\n	while(n--)\r\n	{\r\n		char a[1000];\r\n		cin>>a;\r\n		int i=0;\r\n		int count=0;\r\n		while(a[i])\r\n		{\r\n			if(a[i]>=0&&a[i]<128)count++;\r\n			i++;\r\n		}\r\n		cout<<(i-count)/3<<endl;\r\n	}\r\n}'),(733,'#include<fstream>\r\n#include<cstdlib>\r\n#include<cstdio>\r\n#include<algorithm>\r\n#include<iostream>\r\nusing namespace std;\r\nint  t(char* a)\r\n{\r\n	int count=0;\r\n    while(*a)\r\n	{if(*a>127||*a<0) count++;a++;}\r\n	return count/2;\r\n}\r\nint main()\r\n{ \r\n /*\r\n	ofstream out1(\"C://1.txt\");\r\n	int i=30;\r\n	while(i--) \r\n	{\r\n		int x=rand();\r\n		int y=rand()*2+rand();\r\n		 out1<<x<<\" \"<<y<<endl;\r\n	    \r\n	}\r\n   out1<<0<<\" \"<<0<<endl;\r\n	out1.close(); \r\n	ifstream in(\"C://1.txt\");\r\n    ofstream out;\r\n    out.open(\"C://2.txt\");*/\r\n	 int a,b;\r\n	   while( (cin>>a>>b)&&a )\r\n	   {\r\n		   int x=b-2*a;\r\n		   if(x>=0&&x%2==0 )\r\n			   cout<<a-x/2<<\" \"<<x/2<<endl;\r\n		   else cout<<\"NO\"<<endl;\r\n       }\r\n	   \r\n\r\n}\r\n '),(734,'#include<stdio.h>\r\nint main()\r\n{\r\n	int h,f,ji,tu;\r\n	while(scanf(\"%d%d\",&h,&f)!=EOF&&h!=0&&f!=0)\r\n	{\r\n		tu=2*h-f/2;\r\n		ji=f/2-h;\r\n		if(tu+ji==h&&tu>0&&ji>0)\r\n			printf(\"%d %d\\n\",tu,ji);\r\n		else\r\n			printf(\"NO\\n\");\r\n	}\r\n	return 0;\r\n}'),(735,'#include <stdio.h> \r\nint main( ) \r\n{ \r\n    int m,mi; \r\n    int s[1000][6];\r\n    int people;\r\n    int i, j;\r\n    int maxid;\r\n  \r\n    while( scanf(\"%d\", &m) != EOF ) \r\n    { \r\n        for(mi=0; mi<m; ++mi) \r\n        { \r\n        scanf(\"%d\", &people); \r\n       \r\n        for(i=0; i<people; i++) \r\n        { \r\n            s[i][0]=0;\r\n            for(j=1; j<6; j++)  \r\n            { \r\n                scanf(\"%d\", &s[i][j]); \r\n                s[i][0]+= s[i][j];\r\n            } \r\n        }\r\n  \r\n       \r\n        maxid = 0; \r\n        for(i=1; i<people; ++i) \r\n        { \r\n            if( s[i][0] > s[maxid][0] ) \r\n                maxid = i; \r\n        } \r\n    \r\n          \r\n        printf(\"%d\", s[maxid][1]); \r\n        for(j=2; j<6; j++) \r\n            printf(\" %d\", s[maxid][j]); \r\n        printf(\"\\n\"); \r\n    } \r\n    } \r\n  \r\n    return 0; \r\n} '),(736,'#include<iostream>\r\n#include<algorithm>\r\n#include<cstring>\r\n#include<vector>\r\nusing namespace std;\r\nstruct stu\r\n{\r\n  int a,b,c,d,e;\r\n  int sum;\r\n};\r\nint cmp(stu av,stu bv)\r\n{\r\n    return av.sum>bv.sum;\r\n}\r\nint main()\r\n{ int n,m,i;\r\n  cin>>n;\r\n  stu s;\r\n  while(n--)\r\n  { vector<stu> p;\r\n    cin>>m;\r\n    for(i=0;i<m;i++)\r\n    {\r\n     cin>>s.a>>s.b>>s.c>>s.d>>s.e;\r\n     s.sum=s.a+s.b+s.c+s.d+s.e;\r\n     p.push_back(s);\r\n    }\r\n    sort(p.begin(),p.end(),cmp);\r\n    cout<<p[0].a<<\" \"<<p[0].b<<\" \"<<p[0].c<<\r\n    \" \"<<p[0].d<<\" \"<<p[0].e<<endl;\r\n  }\r\nreturn 0;\r\n}'),(737,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int n, m;\r\n	int a[1000];\r\n	int i;\r\n	while( scanf(\"%d%d\", &n, &m) && n && m)\r\n	{\r\n		for(i=0; i<n; ++i)\r\n			scanf(\"%d\", &a[i]);\r\n\r\n		for(i= n; i>0; i--)\r\n			if( a[i-1] > m )\r\n				a[i] = a[i-1];\r\n			else\r\n				break;\r\n		a[i] = m;\r\n		n++;\r\n		printf(\"%d\", a[0]);\r\n		for(i=1; i<n; ++i)\r\n			printf(\" %d\", a[i]);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(738,'#include<stdio.h>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\nint a[10000];\r\nint main()\r\n{\r\n	int n, m;\r\n	while(scanf(\"%d%d\", &n, &m) && (m||n))\r\n	{\r\n		for(int i=0; i<n; i++)\r\n			scanf(\"%d\", &a[i]);\r\n		a[n] = m;\r\n		sort(a,a+n+1);\r\n		for(int j = 0; j<n; j++)\r\n			printf(\"%d \", a[j]);\r\n		printf(\"%d\\n\", a[n]);\r\n	}\r\n	\r\n	return 0;\r\n}'),(739,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int n;\r\n	int y[100][100];\r\n	int i,j;\r\n	while( scanf(\"%d\", &n)!=EOF)\r\n	{\r\n		for(i=0; i<n; ++i)\r\n		{	y[i][0]=1; y[i][i]=1;	}\r\n		for(i=2; i<n; ++i)\r\n			for(j=1; j<i; ++j)\r\n				y[i][j] = y[i-1][j]+y[i-1][j-1];\r\n		for(i=0; i<n; ++i)\r\n		{\r\n			printf(\"%d\", y[i][0]);\r\n			for(j=1; j<=i; j++)\r\n				printf(\" %d\", y[i][j]);\r\n			printf(\"\\n\");\r\n		}\r\n		printf(\"\\n\");\r\n	}\r\n}'),(740,'#include<stdio.h>\r\nvoid f(int n)\r\n{\r\n	int a[30][30],i,j;\r\n	a[0][0]=a[1][0]=a[1][1]=1;\r\n	for(i=2;i<n;i++)\r\n		for(j=0;j<=i;j++)\r\n			if(j>0&&j<i) a[i][j]=a[i-1][j]+a[i-1][j-1];\r\n			else a[i][j]=1;\r\n	for(i=0;i<n;i++)\r\n		for(j=0;j<=i;j++)\r\n			if(j<i )printf(\"%d \",a[i][j]);\r\n			else printf(\"%d\\n\",a[i][j]);\r\nprintf(\"\\n\");\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf(\"%d\",&n)!=-1)\r\n		f(n);\r\n}'),(741,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int n;\r\n	int i;\r\n	while( scanf(\"%d\", &n)!=EOF)\r\n	{\r\n		printf(\"%d=2\",n);\r\n		n/=2;\r\n		for(i=2; i<n; ++i)\r\n			if( n%i==0)\r\n			{\r\n				printf(\"*%d\", i);\r\n				n/=i;\r\n				--i;				\r\n			}\r\n			\r\n		printf(\"*%d\", i);\r\n		printf(\"\\n\");\r\n	}\r\n	return 0;\r\n}'),(742,'#include<stdio.h>\r\nint main()\r\n{\r\n	int s,i;\r\n	while(~scanf(\"%d\",&s))\r\n	{\r\n		printf(\"%d=\",s);\r\n		for(i=2;i<=s;i++)\r\n	{\r\n		while(s%i==0)\r\n		{\r\n			printf(\"%d\",i);\r\n			s/=i;\r\n			if(s!=1) printf(\"*\");\r\n		}\r\n		if(s==1) break;\r\n	}\r\n	printf(\"\\n\");}\r\n	return 0;\r\n}'),(743,'#include<iostream>\r\nusing namespace std;\r\nbool f(int n)\r\n{\r\n	while(n)\r\n	{\r\n		if(n%10>1) return 0;\r\n		n/=10;\r\n	}\r\n	return 1;\r\n\r\n}\r\nint g(int n)\r\n{\r\n	int m=n;\r\n	while(!f(n))n+=m;\r\n	return n;\r\n}\r\nint main()\r\n{\r\n	int n;\r\n \r\n	while((cin>>n)&&n)\r\n	{\r\n		cout<<g(n)<<endl;\r\n \r\n	}\r\n}'),(744,'#include<iostream>\r\nusing namespace std;\r\nbool f(int n)\r\n{\r\n	while(n)\r\n	{\r\n		if(n%10>1) return 0;\r\n		n/=10;\r\n	}\r\n	return 1;\r\n\r\n}\r\nint g(int n)\r\n{\r\n	int m=n;\r\n	while(!f(n))n+=m;\r\n	return n;\r\n}\r\nint main()\r\n{\r\n	int n;\r\n \r\n	while((cin>>n)&&n)\r\n	{\r\n		cout<<g(n)<<endl;\r\n \r\n	}\r\n}'),(745,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int y,m,d;    \r\n	int days[]={0,0,31,59,90,120,151,181,212,243,273,304,334};\r\n	int day;\r\n	while ( scanf(\"%d%d%d\", &y, &m, &d) !=EOF )\r\n	{\r\n		day = days[m]+d;\r\n		if( y%4==0&&y%100!=0 || y%400==0 )\r\n		{\r\n			if( m > 2 ) day++;\r\n			printf(\"%d\\n\", 366-day+1);\r\n		}\r\n		else\r\n			printf(\"%d\\n\", 365-day+1);\r\n	}\r\n\r\n}'),(746,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int y,m,d;    \r\n	int days[]={0,0,31,59,90,120,151,181,212,243,273,304,334};\r\n	int day;\r\n	while ( scanf(\"%d%d%d\", &y, &m, &d) !=EOF )\r\n	{\r\n		day = days[m]+d;\r\n		if( y%4==0&&y%100!=0 || y%400==0 )\r\n		{\r\n			if( m > 2 ) day++;\r\n			printf(\"%d\\n\", 366-day+1);\r\n		}\r\n		else\r\n			printf(\"%d\\n\", 365-day+1);\r\n	}\r\n\r\n}'),(747,'#include <stdio.h>\r\n#include <math.h>\r\n\r\nint main( )\r\n{\r\n	int n,i;\r\n	int a,b,c;\r\n	double s,area;\r\n	while( scanf(\"%d\", &n) !=EOF)\r\n	{\r\n		for(i=0; i<n; ++i)\r\n		{\r\n			scanf(\"%d%d%d\", &a,&b,&c);\r\n	\r\n			if( a+b>c && b+c>a && c+a>b  )\r\n			{\r\n				s = (a+b+c)/2.0;\r\n				area=sqrt(s*(s-a)*(s-b)*(s-c));\r\n				printf(\"%.2lf\\n\", area);\r\n			}\r\n			else\r\n				printf(\"NO\\n\");\r\n		}\r\n	}\r\n}'),(748,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n    float a,b,c,p,n,s,i;\r\n	scanf(\"%f\",&n);\r\n    for(i=1;i<=n;i++)\r\n	{\r\n	scanf(\"%f%f%f\",&a,&b,&c);\r\n	p=(a+b+c)/2;\r\n	if(a+b>c&&a-b<c&&b+c>a&&b-c<a&&a+c>b&&a-c<b)\r\n	{s=sqrt(p*(p-a)*(p-b)*(p-c));\r\n	printf(\"%.2f\\n\",s);}\r\n	 else\r\n	printf(\"NO\\n\");}\r\n	\r\n}'),(749,'\r\n#include <iostream>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <string>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int a, b;\r\n    int a_b;\r\n    while (cin >> a >> b) {\r\n        if (!a && ! b)\r\n            break;\r\n\r\n        if (a > b)\r\n        {\r\n            int t = a;\r\n            a = b;\r\n            b = t;\r\n        }\r\n        int count = 0;\r\n        a_b = b - a;\r\n        if (a_b > 400) {\r\n            int n_400 = a_b / 400;\r\n            count += 97 * n_400;\r\n            int s_y = a_b % 400;\r\n\r\n\r\n            for (int i = b - s_y; i < b; i++) {\r\n                if (i % 4 == 0 && i % 100 != 0)          //判断year年为闰年还是平年，\r\n                    count++;\r\n    // printf(\"闰%d %d\\n\", 366, Y - 1);\r\n                else if (i % 100 == 0 && i % 400 == 0)\r\n                    count++;\r\n            }\r\n        }\r\n        else {\r\n            for (int i = a; i < b; i++) {\r\n                if (i % 4 == 0 && i % 100 != 0)          //判断year年为闰年还是平年，\r\n                    count++;\r\n    // printf(\"闰%d %d\\n\", 366, Y - 1);\r\n                else if (i % 100 == 0 && i % 400 == 0)\r\n                    count++;\r\n            }\r\n        }\r\n    cout << count << endl;\r\n    }\r\n    return 0;\r\n}\r\n'),(750,'#include<stdio.h>\r\n#include<math.h>\r\n int f(int n)\r\n {\r\n	 return  ceil(n/4.0)-ceil(n/100.0)+ceil(n/400.0);\r\n }\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf(\"%d%d\",&a,&b)&&a&&b)\r\n	 \r\n		printf(\"%d\\n\",f(b)-f(a));\r\n \r\n}'),(751,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int m,i;\r\n	int a,b;\r\n\r\n	int as, bs;\r\n	int j;\r\n\r\n	while( scanf(\"%d\", &m)!=EOF )\r\n	{\r\n		for(i=0; i<m; ++i)\r\n		{\r\n			scanf(\"%d%d\", &a, &b);\r\n			if( a == b )\r\n				printf(\"NO\\n\");\r\n			else\r\n			{\r\n				as = 1;\r\n				bs = 1;\r\n				for(j=2; j<a; ++j)\r\n					if( a % j == 0 )\r\n						as += j;\r\n				if( as != b )\r\n				{\r\n					printf(\"NO\\n\");\r\n					continue;\r\n				}\r\n\r\n				for(j=2; j<b; ++j)\r\n					if( b % j == 0 )\r\n						bs += j;\r\n				if( bs != a )\r\n				{\r\n					printf(\"NO\\n\");\r\n					continue;\r\n				}\r\n				printf(\"YES\\n\");\r\n				\r\n			}\r\n		}\r\n	}\r\n	return 0;\r\n}'),(752,'#include<stdio.h> \r\n#include<math.h> \r\nint main()\r\n{ \r\nint a,b,suma,sumb,i,j,m; \r\nscanf(\"%d\",&m); \r\nfor(i=1;i<=m;i++) \r\n{  \r\nscanf(\"%d%d\",&a,&b); \r\nsuma=0;  \r\nfor(j=1;j<a;j++) \r\n{if(a%j==0) \r\nsuma=suma+j;} \r\nsumb=0;  \r\nfor(j=1;j<b;j++) \r\n{ if(b%j==0) \r\nsumb=sumb+j;} \r\nif(a==sumb&&b==suma&&a!=b) \r\nprintf(\"YES\\n\"); \r\nelse  \r\nprintf(\"NO\\n\"); \r\n} \r\nreturn 0; \r\n}'),(753,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int m ,n , i;\r\n	int pfh, lfh;\r\n	int t;\r\n	while( scanf(\"%d%d\", &m, &n) !=EOF)\r\n	{\r\n		pfh = lfh = 0;\r\n		if( m>n ){t=m; m=n; n=t; }\r\n		for(i=m; i<=n; ++i)\r\n		{\r\n			if( i%2==0 )\r\n				pfh += i*i;\r\n			else\r\n				lfh += i*i*i;\r\n		}\r\n		printf(\"%d %d\\n\", pfh, lfh);\r\n	}\r\n	return 0;\r\n}'),(754,'#include<stdio.h>\r\nint main()\r\n{\r\n	int m,n,s1,s2;\r\n	while(scanf(\"%d%d\",&m,&n)!=-1)\r\n	{\r\n		s1=s2=0;\r\n		for(;m<=n;m++)\r\n		{\r\n			if(m%2==0) s1+=m*m;\r\n			else s2+=m*m*m;\r\n		}\r\n		printf(\"%d %d\\n\",s1,s2);\r\n	}\r\n	return 0;\r\n}'),(755,'#include <stdio.h>\r\nint main( )\r\n{\r\n	int n;\r\n	int s[100];\r\n	int i;\r\n	int total;\r\n	double avg;\r\n	int flag;\r\n	int count;\r\n	while( scanf(\"%d\", &n) != EOF )\r\n	{\r\n		total=0;\r\n		flag = 0; //都及格了\r\n\r\n		count=0;\r\n\r\n		for(i=0; i<n; ++i)\r\n		{\r\n			scanf(\"%d\", &s[i]);\r\n			total+=s[i];\r\n		}\r\n		avg = (double)total / n;\r\n		for(i=0; i<n; ++i)\r\n		{\r\n			if( s[i]<avg )\r\n				++count;\r\n			if( s[i] < 60 )\r\n				flag = 1; //设置有不及格的科目\r\n		}\r\n		if( flag )\r\n			printf(\"%d NO\\n\", count);\r\n		else\r\n			printf(\"%d\\n\", count);\r\n	}\r\n	return 0;\r\n}'),(756,'#include<stdio.h>\r\nint main()\r\n{\r\n	int n, i;\r\n	float a[100];\r\n	float m;\r\n	while(scanf(\"%d\",&n)!=EOF)\r\n	{\r\n	     int  t=0,u=0;\r\n		 float H=0;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf(\"%f\",&a[i]);\r\n			H+=a[i];\r\n		}\r\n	    m=H/n;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			if(a[i]<m)\r\n			t++;\r\n			if(a[i]<60)\r\n			u+=1;\r\n		}	\r\n		if(u!=0)\r\n		printf(\"%d NO\\n\",t);\r\n		else if(u==0)\r\n		printf(\"%d\\n\",t);\r\n	}\r\n	return 0;\r\n} '),(757,'#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( )\r\n{\r\n	char s[1001];\r\n	char *p;\r\n	int letters, digits, spaces, other;\r\n	\r\n	while( gets( s ) && strlen(s) )\r\n	{\r\n		letters=digits=spaces=other=0;\r\n		p = s;\r\n		while( *p )\r\n		{\r\n			if( *p>=\'A\'&&*p<=\'Z\' || *p>=\'a\'&&*p<=\'z\')\r\n				++letters;\r\n			else if( *p>=\'0\'&&*p<=\'9\')\r\n				++digits;\r\n			else if( *p == \' \')\r\n				++spaces;\r\n			else\r\n				++other;\r\n			++p;\r\n		}\r\n		printf(\"%d %d %d %d\\n\", letters,spaces,digits,other);\r\n	}\r\n	return 0;\r\n}'),(758,'#include<stdio.h>\r\nint main()\r\n{\r\n	char a;\r\n	int i,k,j,l;\r\n	\r\n	while(scanf(\"%c\",&a)!=EOF)\r\n	{i=j=k=l=0;\r\n		while(a!=\'\\n\')\r\n		{	\r\n			if(a>=\'a\'&&a<=\'z\'||a>=\'A\'&&a<=\'Z\')\r\n				i++;\r\n			else if(a>=\'0\'&&a<=\'9\')\r\n				j++;\r\n			else if(\' \'==a)\r\n			    k++;\r\n			else  \r\n				l++;\r\n\r\n		scanf(\"%c\",&a);\r\n		}printf(\"%d %d %d %d\\n\",i,k,j,l);\r\n	}\r\n	\r\n\r\n	return 0;\r\n}'),(759,'#include<stdio.h>\r\n#include<string.h>\r\n \r\nint a[10][10]={0};\r\nvoid f(int n)\r\n{   int b[4][2]={1,0,0,1,-1,0,0,-1};\r\n	int i=1;\r\n	int x=0,y=0;\r\n	int or=0;\r\n	memset(a,0,sizeof(a));\r\n	\r\n	while(i<=n*n)\r\n	{\r\n		a[x][y]=i;\r\n		if(x+b[or][0]<0||x+b[or][0]>=n||y+b[or][1]<0||y+b[or][1]>=n||a[x+b[or][0]][y+b[or][1]])\r\n		{	or++;or%=4;}\r\n		x+=b[or][0];y+=b[or][1];\r\n		i++;\r\n	}\r\n	for(x=0;x<n;x++)\r\n	{\r\n		for(y=0;y<n-1;y++)\r\n			printf(\"%d \",a[x][y]);\r\n		printf(\"%d\\n\",a[x][y]);\r\n	}\r\n}\r\n \r\nint main()\r\n{\r\n   int n;\r\n   scanf(\"%d\",&n);\r\n   while(n)\r\n   {\r\n	   f(n);\r\n	   scanf(\"%d\",&n);\r\n   }\r\n}\r\n\r\n'),(760,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{ int a[100][100];\r\n  int x,y,t,i,n,m;\r\n\r\n\r\n  while(scanf(\"%d\",&t)!=EOF)\r\n  {  if(t==0)break;\r\n    memset(a,0,sizeof(a));\r\n    y=0;x=0;i=1;a[y][x]=1;\r\n   while(i<t*t)\r\n  { while(y<t-1&&!a[y+1][x])a[++y][x]=++i;\r\n    while(x-1>=0&&!a[y][x-1])a[y][--x]=++i;\r\n    while(y-1>=0&&!a[y-1][x])a[--y][x]=++i;\r\n    while(x<t-1&&!a[y][x+1])a[y][++x]=++i;\r\n     }\r\n    for(n=0;n<t;n++)\r\n    {for(m=0;m<t-1;m++)\r\n     printf(\"%d \",a[n][m]);\r\n     printf(\"%d\\n\",a[n][m]);\r\n\r\n    }\r\n\r\n    }\r\n    return 0;\r\n}\r\n'),(761,'#include<iostream>\r\n#include<cstring>\r\nusing namespace std;\r\n int a[10][10];\r\nvoid f(int n)\r\n{\r\n	memset(a,0,sizeof(a));\r\n	int i=1;\r\n	int x=n-1,y=n/2;\r\n	while(i<=n*n)\r\n	{\r\n		a[x][y]=i;\r\n		if(a[(x+1)%n][(y-1+n)%n])\r\n			x--;\r\n		else x=(x+1)%n,y=(y-1+n)%n;\r\n		i++;\r\n	}\r\n	for(x=0;x<n;x++)\r\n	{\r\n		for(y=0;y<n-1;y++)\r\n			cout<<a[x][y]<<\" \";\r\n		cout<<a[x][y]<<endl;\r\n	}\r\n}\r\n \r\nint main()\r\n{\r\n   int n;\r\n   cin>>n;\r\n   while(n)\r\n   {\r\n	   f(n);\r\n	   cin>>n;\r\n   }\r\n}\r\n\r\n'),(762,'#include<stdio.h>\r\nmain()\r\n{\r\n	int n,a[100][100],i,x,y,j;\r\n	while(~scanf(\"%d\",&n),n)\r\n	{\r\n		x=n-1;\r\n		y=n/2; \r\n		a[x][y]=i=1;\r\n		for(i++;i<=n*n;i++)\r\n		{\r\n			if(i%n!=1)\r\n			{\r\n				x=(x+1)%n;\r\n				y=(y+n-1)%n;\r\n			}\r\n			else x=(x+n-1)%n;\r\n			a[x][y]=i;\r\n		}\r\n		for(i=0;i<n;i++)\r\n			for(j=0;j<n;j++)\r\n			{\r\n				printf(\"%d\",a[i][j]);\r\n				if(j!=n-1) printf(\" \");\r\n				else printf(\"\\n\");\r\n			}\r\n	}\r\n}'),(763,'#include<iostream.h>\r\n#include<time.h>\r\n \r\nbool f(int n)\r\n{\r\n	return n%4==0&&n%100||n%400==0;\r\n	 \r\n}\r\nint co(int n)\r\n{\r\n	int count=n/400*97;\r\n	n%=400;\r\n	for(int i=0;i<n;i++)\r\n		if(f(i))count++;\r\n	return count;\r\n}\r\nint main()\r\n{\r\n  \r\n   int a,b;\r\n   while(cin>>a>>b,a) \r\n   {   \r\n	   if(a>b){a=a^b;b=a^b;a=a^b;}\r\n	   cout<<co(b+1)-co(a) <<endl;\r\n   }\r\n}'),(764,'#include<stdio.h>\r\nmain()\r\n{\r\n	int a,b,n,i;\r\n	while(scanf(\"%d%d\",&a,&b)&&a&&b)\r\n	{\r\n		n=0;\r\n		if(a<b) {i=a; a=b; b=i;}\r\n		n+=(a-b)/4;\r\n		if(a%4<b%4||!b%4&&b%100) n++;\r\n		a/=100;\r\n		b/=100;\r\n		for(i=b+1;i<=a;i++)\r\n				if(i%4) n--;\r\n		printf(\"%d\\n\",n);\r\n	}\r\n}'),(765,'#include<iostream.h>\r\n#include<time.h>\r\n \r\nchar a[3][31] ={\r\n{\" _     _  _     _  _  _  _  _ \"},\r\n{\"| |  | _| _||_||_ |_ | ||_||_|\"},\r\n{\"|_|  ||_  _|  | _||_|  ||_| _|\"}\r\n};\r\n \r\nint main()\r\n{\r\n  int aa,m,n,i,b[1000];\r\n  while((cin>>m>>n)&&(m||n))\r\n  {aa=m+n;\r\n  i=0;\r\n  while(aa)\r\n  { b[i++]=aa%10;\r\n    aa/=10;\r\n  }\r\n  for(int y=0;y<3;y++)\r\n  { for(int x=i-1;x>0;x--)\r\n     cout<<a[y][b[x]*3 ]<<a[y][b[x]*3+1 ]<<a[y][b[x]*3+2 ];\r\n     cout<<a[y][b[0]*3 ]<<a[y][b[0]*3+1 ];\r\n	 if(a[y][b[0]*3+2 ]!=32) cout<<a[y][b[0]*3+2 ];\r\n	  cout<<endl;\r\n  }\r\n  }\r\n}\r\n\r\n'),(766,'#include<iostream.h>\r\n#include<time.h>\r\n \r\nchar a[3][31] ={\r\n{\" _     _  _     _  _  _  _  _ \"},\r\n{\"| |  | _| _||_||_ |_ | ||_||_|\"},\r\n{\"|_|  ||_  _|  | _||_|  ||_| _|\"}\r\n};\r\n \r\nint main()\r\n{\r\n  int aa,m,n,i,b[1000];\r\n  while((cin>>m>>n)&&(m||n))\r\n  {aa=m+n;\r\n  i=0;\r\n  while(aa)\r\n  { b[i++]=aa%10;\r\n    aa/=10;\r\n  }\r\n  for(int y=0;y<3;y++)\r\n  { for(int x=i-1;x>0;x--)\r\n     cout<<a[y][b[x]*3 ]<<a[y][b[x]*3+1 ]<<a[y][b[x]*3+2 ];\r\n     cout<<a[y][b[0]*3 ]<<a[y][b[0]*3+1 ];\r\n	 if(a[y][b[0]*3+2 ]!=32) cout<<a[y][b[0]*3+2 ];\r\n	  cout<<endl;\r\n  }\r\n  }\r\n}\r\n\r\n'),(767,'#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n struct A\r\n {int h,p;\r\n bool operator<(const A& b)const\r\n {return p>b.p;}\r\n };\r\n \r\nint main()\r\n{\r\n    \r\n		  A a[20];\r\n		 int i;\r\n		for(i=0;i<20;i++)\r\n		{\r\n			a[i].h=(1<<i);\r\n		a[i].p=0;}\r\n		int n;\r\n		cin>>n;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			int x;\r\n			cin>>x;\r\n             for(int j=0;j<20;j++)\r\n				 if(a[j].h&x) (a[j].p)++;\r\n		}\r\n		stable_sort(a,a+20);\r\n		for(i=0;i<10;i++)\r\n			cout<<a[i].h<<\" \"<<a[i].p<<endl;\r\n\r\n}\r\n\r\n'),(768,'#include<iostream>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n struct A\r\n {int h,p;\r\n bool operator<(const A& b)const\r\n {return p>b.p;}\r\n };\r\n \r\nint main()\r\n{\r\n    \r\n		  A a[20];\r\n		 int i;\r\n		for(i=0;i<20;i++)\r\n		{\r\n			a[i].h=(1<<i);\r\n		a[i].p=0;}\r\n		int n;\r\n		cin>>n;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			int x;\r\n			cin>>x;\r\n             for(int j=0;j<20;j++)\r\n				 if(a[j].h&x) (a[j].p)++;\r\n		}\r\n		stable_sort(a,a+20);\r\n		for(i=0;i<10;i++)\r\n			cout<<a[i].h<<\" \"<<a[i].p<<endl;\r\n\r\n}\r\n\r\n'),(769,'#include<iostream> \r\n#include<fstream> \r\n#include<string> \r\n#include<map> \r\n#include<vector> \r\n#include<stack> \r\n\r\nusing namespace std; \r\n   \r\n bool test(  string s1,const string& s2,multimap<string,string>& mm) \r\n {           \r\n     stack<string> s; \r\n     s.push(s1); \r\n    while(!s.empty()) \r\n    { \r\n       s1=s.top(); \r\n       if(s1==s2) return 1; \r\n       s.pop(); \r\n       for(multimap<string,string>::iterator p=mm.lower_bound(s1); \r\n       p!=mm.upper_bound(s1);p++) \r\n           s.push(p->second); \r\n    } \r\n    return 0; \r\n  \r\n } \r\nint main() \r\n{  \r\n    int x; \r\n    cin>>x; \r\n    while(x--) \r\n    { \r\n        int m,n; \r\n        cin>>n; \r\n           \r\n        multimap<string,string> mm; \r\n           \r\n        while(n--) \r\n        { \r\n            string s1,s2;  \r\n            cin>>s1>>s2 ; \r\n            mm.insert(pair<string,string>(s1,s2));        \r\n        } \r\n        cin>>m; \r\n        while(m--) \r\n        { \r\n            string s1,s2; \r\n            cin>>s1>>s2; \r\n            if(test(s1,s2,mm)) \r\n                cout<<\"YES\"<<endl; \r\n            else cout<<\"NO\"<<endl; \r\n              \r\n               \r\n        } \r\n    } \r\n  \r\n} '),(770,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<stack>\r\n#include<map>\r\nusing namespace std;\r\n \r\n bool test(  string s1,const string& s2,multimap<string,string>& mm)\r\n {          \r\n	 stack<string> s;\r\n     s.push(s1);\r\n	while(!s.empty())\r\n	{\r\n       s1=s.top();\r\n	   if(s1==s2) return 1;\r\n	   s.pop();\r\n	   for(multimap<string,string>::iterator p=mm.lower_bound(s1);\r\n	   p!=mm.upper_bound(s1);p++)\r\n		   s.push(p->second);\r\n	}\r\n	return 0;\r\n\r\n }\r\nint main()\r\n{ \r\n	int x;\r\n	cin>>x;\r\n	while(x--)\r\n	{\r\n	    int m,n;\r\n		cin>>n;\r\n		 \r\n		multimap<string,string> mm;\r\n		 \r\n		while(n--)\r\n		{\r\n			string s1,s2; \r\n			cin>>s1>>s2 ;\r\n			mm.insert(pair<string,string>(s1,s2));       \r\n		}\r\n		cin>>m;\r\n		while(m--)\r\n		{\r\n            string s1,s2;\r\n			cin>>s1>>s2;\r\n			if(test(s1,s2,mm))\r\n				cout<<\"YES\"<<endl;\r\n			else cout<<\"NO\"<<endl;\r\n			\r\n			 \r\n		}\r\n	}\r\n\r\n}'),(771,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<stack>\r\n#include<map>\r\n#include<set>\r\nusing namespace std;\r\n struct A\r\n {\r\n	 string a;\r\n	 int count;\r\n };\r\n int test(  string s1,const string& s2,multimap<string,A>& mm)\r\n {    \r\n	 int count=0;\r\n	 stack<A> s;\r\n	 A tmp;tmp.a=s1;tmp.count=1;\r\n     s.push(tmp);\r\n	while(!s.empty())\r\n	{\r\n       tmp=s.top();\r\n	   if(tmp.a==s2) count +=tmp.count;\r\n	   s.pop();\r\n	   for(multimap<string,A>::iterator p=mm.lower_bound(tmp.a);\r\n	   p!=mm.upper_bound(tmp.a);p++)\r\n	   {\r\n		   A t;\r\n		   t.a=p->second.a;\r\n		   t.count=tmp.count*p->second.count;\r\n		   s.push(t);\r\n	   }\r\n	}\r\n	return count;\r\n\r\n }\r\n bool z(int n)\r\n {\r\n	 if(n<2) return 0;\r\n	 int i=2;\r\n	 for(;i<=n/2;i++)\r\n		 if(n%i==0) return 0;\r\n	 return 1;\r\n }\r\n int g(int m,int n)\r\n {\r\n	 int count=0;\r\n	 if(m==n)return 1;\r\n	 if(m<n)return 0;\r\n	 if(m%n) return 0;\r\n	 if(z(m/n)) return m/n;\r\n	 int x;\r\n	 for(x=2;x<=m/n;x++)\r\n	 {\r\n		 if(m%x==0&&z(x))\r\n		 count+=g(m/x,n)* x;\r\n	 }\r\n	 return count;\r\n }\r\nint main()\r\n{  \r\n//	int x;\r\n//	cin>>x;\r\n//	while(x--)\r\n \r\n	{\r\n	    int m,n;\r\n		cin>>n;\r\n		 \r\n		multimap<string,A> mm;\r\n		 set<string> se;\r\n		while(n--)\r\n		{\r\n			string s1,s2;\r\n			int count;\r\n			cin>>s1>>s2>>count ;\r\n			se.insert(s1);\r\n			se.insert(s2);\r\n			A tmp;tmp.a=s2;tmp.count=count;\r\n			mm.insert(pair<string,A>(s1,tmp));       \r\n		}\r\n		cin>>m;\r\n		while(m--)\r\n		{\r\n            string s1,s2;\r\n			cin>>s1>>s2;\r\n			if(s1==s2)cout<<1<<endl;\r\n			else if(se.find(s1)==se.end()||se.find(s2)==se.end())\r\n				 cout<<\"I don\'t know\"<<endl;\r\n			else cout<<test(s1,s2,mm)<<endl;\r\n			 \r\n		}\r\n	}\r\n \r\n \r\n \r\n}'),(772,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<stack>\r\n#include<map>\r\n#include<set>\r\nusing namespace std;\r\n struct A\r\n {\r\n	 string a;\r\n	 int count;\r\n };\r\n int test(  string s1,const string& s2,multimap<string,A>& mm)\r\n {    \r\n	 int count=0;\r\n	 stack<A> s;\r\n	 A tmp;tmp.a=s1;tmp.count=1;\r\n     s.push(tmp);\r\n	while(!s.empty())\r\n	{\r\n       tmp=s.top();\r\n	   if(tmp.a==s2) count +=tmp.count;\r\n	   s.pop();\r\n	   for(multimap<string,A>::iterator p=mm.lower_bound(tmp.a);\r\n	   p!=mm.upper_bound(tmp.a);p++)\r\n	   {\r\n		   A t;\r\n		   t.a=p->second.a;\r\n		   t.count=tmp.count*p->second.count;\r\n		   s.push(t);\r\n	   }\r\n	}\r\n	return count;\r\n\r\n }\r\n bool z(int n)\r\n {\r\n	 if(n<2) return 0;\r\n	 int i=2;\r\n	 for(;i<=n/2;i++)\r\n		 if(n%i==0) return 0;\r\n	 return 1;\r\n }\r\n int g(int m,int n)\r\n {\r\n	 int count=0;\r\n	 if(m==n)return 1;\r\n	 if(m<n)return 0;\r\n	 if(m%n) return 0;\r\n	 if(z(m/n)) return m/n;\r\n	 int x;\r\n	 for(x=2;x<=m/n;x++)\r\n	 {\r\n		 if(m%x==0&&z(x))\r\n		 count+=g(m/x,n)* x;\r\n	 }\r\n	 return count;\r\n }\r\nint main()\r\n{  \r\n//	int x;\r\n//	cin>>x;\r\n//	while(x--)\r\n \r\n	{\r\n	    int m,n;\r\n		cin>>n;\r\n		 \r\n		multimap<string,A> mm;\r\n		 set<string> se;\r\n		while(n--)\r\n		{\r\n			string s1,s2;\r\n			int count;\r\n			cin>>s1>>s2>>count ;\r\n			se.insert(s1);\r\n			se.insert(s2);\r\n			A tmp;tmp.a=s2;tmp.count=count;\r\n			mm.insert(pair<string,A>(s1,tmp));       \r\n		}\r\n		cin>>m;\r\n		while(m--)\r\n		{\r\n            string s1,s2;\r\n			cin>>s1>>s2;\r\n			if(s1==s2)cout<<1<<endl;\r\n			else if(se.find(s1)==se.end()||se.find(s2)==se.end())\r\n				 cout<<\"I don\'t know\"<<endl;\r\n			else cout<<test(s1,s2,mm)<<endl;\r\n			 \r\n		}\r\n	}\r\n \r\n \r\n \r\n}'),(773,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<stack>\r\n#include<map>\r\n#include<set>\r\n#include<cstdio>\r\n#include<cmath>\r\nusing namespace std;\r\n \r\n  \r\nint main()\r\n{   \r\n	int n;\r\n	cin>>(n);\r\n	while(n)\r\n	{\r\n		int m=n;\r\n		double t,s1=0,s2=0;\r\n		while(m--){\r\n		scanf(\"%lf\",&t);\r\n		s1+=t;s2+=t*t;\r\n		}\r\n		double an=s2/n-(s1/n*s1/n);\r\n		printf(\"%.2lf %.2lf\\n\",an,sqrt(an));\r\n\r\n		cin>>n;\r\n	}\r\n\r\n}'),(774,'#include <stdio.h>\r\n#include <math.h>\r\nint main( )\r\n{\r\n	int n;\r\n	int i;\r\n	double x, sum;\r\n	double fch;\r\n	while( scanf(\"%d\",&n) && n)\r\n	{\r\n		sum = 0;\r\n		fch = 0;\r\n		for(i=0; i<n; ++i)\r\n		{\r\n			scanf(\"%lf\", &x);\r\n			sum += x;\r\n			fch += x*x;\r\n		}\r\n		sum /= n;\r\n		fch /= n;\r\n		printf(\"%.2lf %.2lf\\n\",\r\n			fch-sum*sum,\r\n			 sqrt(fch-sum*sum));\r\n	}\r\n	  \r\n\r\n}'),(775,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<map>\r\n#include<set>\r\n#include<cstdio>\r\n#include<cmath>\r\nusing namespace std;\r\n \r\n  \r\nint main()\r\n{   \r\n	int n;\r\n	cin>>(n);\r\n	while(n)\r\n	{\r\n		int m=0;\r\n		double arr[100],s1=0;\r\n		while(m<n){\r\n		 scanf(\"%lf\",&arr[m]);\r\n		 s1+=arr[m++];\r\n		}\r\n		sort(arr,arr+n);\r\n		double wei;\r\n		if(n%2) wei=arr[n/2];\r\n		else wei=(arr[n/2]+arr[n/2-1])/2;\r\n		char* p[3]={\"perfect\",\"bighead\",\"bigtail\"};\r\n		int str;\r\n		if(fabs(s1/n-wei)<1e-6) str=0;\r\n		else if(s1/n<wei) str=2;\r\n		else str=1;\r\n		printf(\"%.2lf %.2lf %.2lf %s\\n\",s1/n,wei,(arr[0]+arr[n-1])/2,p[str]);\r\n\r\n		cin>>n;\r\n	}\r\n\r\n}'),(776,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<map>\r\n#include<set>\r\n#include<cstdio>\r\n#include<cmath>\r\nusing namespace std;\r\n \r\n  \r\nint main()\r\n{   \r\n	int n;\r\n	cin>>(n);\r\n	while(n)\r\n	{\r\n		int m=0;\r\n		double arr[100],s1=0;\r\n		while(m<n){\r\n		 scanf(\"%lf\",&arr[m]);\r\n		 s1+=arr[m++];\r\n		}\r\n		sort(arr,arr+n);\r\n		double wei;\r\n		if(n%2) wei=arr[n/2];\r\n		else wei=(arr[n/2]+arr[n/2-1])/2;\r\n		char* p[3]={\"perfect\",\"bighead\",\"bigtail\"};\r\n		int str;\r\n		if(fabs(s1/n-wei)<1e-6) str=0;\r\n		else if(s1/n<wei) str=2;\r\n		else str=1;\r\n		printf(\"%.2lf %.2lf %.2lf %s\\n\",s1/n,wei,(arr[0]+arr[n-1])/2,p[str]);\r\n\r\n		cin>>n;\r\n	}\r\n\r\n}'),(777,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<map>\r\n#include<set>\r\n#include<cstdio>\r\n#include<cmath>\r\nusing namespace std;\r\n \r\n  \r\nint main()\r\n{   \r\n	int n;\r\n	cin>>(n);\r\n	while(n)\r\n	{\r\n		 int m=n;\r\n		map<double,int> mm;\r\n		double t;\r\n		while(m--){\r\n		 scanf(\"%lf\",&t);\r\n		   mm[t]++;\r\n		}\r\n		int max=0;\r\n		int count=1;\r\n		map<double,int>::iterator p;\r\n		for(p=mm.begin();p!=mm.end();p++)\r\n		{ if(p->second>max) {max=p->second;count=1;}\r\n          else if(p->second==max) count++;\r\n		}\r\n        printf(\"%d \",count);\r\n        for( p=mm.begin();p!=mm.end();p++)\r\n			if(max==p->second)\r\n		    printf(\"%.2lf \",p->first );\r\n			printf(\"%d\\n\",max);\r\n\r\n		cin>>n;\r\n	}\r\n\r\n}'),(778,'#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<map>\r\n#include<set>\r\n#include<cstdio>\r\n#include<cmath>\r\nusing namespace std;\r\n \r\n  \r\nint main()\r\n{   \r\n	int n;\r\n	cin>>(n);\r\n	while(n)\r\n	{\r\n		 int m=n;\r\n		map<double,int> mm;\r\n		double t;\r\n		while(m--){\r\n		 scanf(\"%lf\",&t);\r\n		   mm[t]++;\r\n		}\r\n		int max=0;\r\n		int count=1;\r\n		map<double,int>::iterator p;\r\n		for(p=mm.begin();p!=mm.end();p++)\r\n		{ if(p->second>max) {max=p->second;count=1;}\r\n          else if(p->second==max) count++;\r\n		}\r\n        printf(\"%d \",count);\r\n        for( p=mm.begin();p!=mm.end();p++)\r\n			if(max==p->second)\r\n		    printf(\"%.2lf \",p->first );\r\n			printf(\"%d\\n\",max);\r\n\r\n		cin>>n;\r\n	}\r\n\r\n}'),(779,'#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n	char p[19] ;\r\n	 cin>>p;\r\n	char a[]={1+48,0+48,\'X\',9+48,8+48,7+48,6+48,5+48,4+48,3+48,2+48};\r\n	int sum=0;\r\n	for(int i=17;i>=1;i--)\r\n	{	sum+=(1<<i)%11*(p[17-i]-\'0\') ;\r\n	}\r\n	if(a[sum%11]==p[17])cout<<\"Y\\n\" ;else cout<<\"N\\n\";\r\n	}\r\n}'),(780,'#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n	char p[19] ;\r\n	 cin>>p;\r\n	char a[]={1+48,0+48,\'X\',9+48,8+48,7+48,6+48,5+48,4+48,3+48,2+48};\r\n	int sum=0;\r\n	for(int i=17;i>=1;i--)\r\n	{	sum+=(1<<i)%11*(p[17-i]-\'0\') ;\r\n	}\r\n	if(a[sum%11]==p[17])cout<<\"Y\\n\" ;else cout<<\"N\\n\";\r\n	}\r\n}'),(781,'#include<iostream>\r\n#include<cmath>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n	char p[16] ;\r\n	char q[19]={0};\r\n	cin>>p;\r\n	strncpy(q,p,6);\r\n	strncpy(q+8,p+6,9);\r\n	q[6]=\'1\';\r\n	q[7]=\'9\';\r\n	 \r\n	char a[]={1+48,0+48,\'X\',9+48,8+48,7+48,6+48,5+48,4+48,3+48,2+48};\r\n	int sum=0;\r\n	for(int i=17;i>=1;i--)\r\n	{	sum+=(1<<i)%11*(q[17-i]-\'0\') ;\r\n	}\r\n	q[17]=a[sum%11];\r\n	 cout<<q<<endl; \r\n	 \r\n	int x=10*(q[8]-48)+q[9]-48;\r\n	if(x>=0&&x<=14)\r\n	{\r\n		q[6]=\'2\';\r\n	    q[7]=\'0\';\r\n	    sum=0;\r\n	    for(int  i=17;i>=1;i--)\r\n		{	sum+=(1<<i)%11*(q[17-i]-\'0\') ;\r\n		}\r\n	    q[17]=a[sum%11];\r\n	    cout<<q<<endl; \r\n	} \r\n	}\r\n}'),(782,'#include<iostream>\r\n#include<cmath>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n	char p[16] ;\r\n	char q[19]={0};\r\n	cin>>p;\r\n	strncpy(q,p,6);\r\n	strncpy(q+8,p+6,9);\r\n	q[6]=\'1\';\r\n	q[7]=\'9\';\r\n	 \r\n	char a[]={1+48,0+48,\'X\',9+48,8+48,7+48,6+48,5+48,4+48,3+48,2+48};\r\n	int sum=0;\r\n	for(int i=17;i>=1;i--)\r\n	{	sum+=(1<<i)%11*(q[17-i]-\'0\') ;\r\n	}\r\n	q[17]=a[sum%11];\r\n	 cout<<q<<endl; \r\n	 \r\n	int x=10*(q[8]-48)+q[9]-48;\r\n	if(x>=0&&x<=14)\r\n	{\r\n		q[6]=\'2\';\r\n	    q[7]=\'0\';\r\n	    sum=0;\r\n	    for(int  i=17;i>=1;i--)\r\n		{	sum+=(1<<i)%11*(q[17-i]-\'0\') ;\r\n		}\r\n	    q[17]=a[sum%11];\r\n	    cout<<q<<endl; \r\n	} \r\n	}\r\n}'),(783,'#include<iostream>\r\n#include<cmath>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n,i;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n	 \r\n	char p[19]={0};\r\n	cin>>p;\r\n	int m,d,s,nf=1900;\r\n	 if(strlen(p)==15)\r\n	 {	 m=(p[8]-48)*10+p[9]-48;\r\n	     d=(p[10]-48)*10+p[11]-48;\r\n		 nf+=(p[6]-48)*10+p[7]-48;\r\n	    s=p[14];}\r\n	 else\r\n	 {\r\n		 m=(p[10]-48)*10+p[11]-48;\r\n		 d=(p[12]-48)*10+p[13]-48;\r\n		 nf=(p[6]-48)*1000+  (p[7]-48)*100+ (p[8]-48)*10+p[9]-48;\r\n	     s=p[16];\r\n	 }\r\n	 \r\n	 int xx[]={31,28,31,30,31,30,31,31,30,31,30,31};\r\n	int ds1=0,ds2=0,an;\r\n	if(m<1||m>12) {printf(\"别逗了\\n\");continue;}\r\n	if(m==2&&(nf%4==0&&nf%100||nf%400==0))\r\n	{if(d<1||d>29) {printf(\"别逗了\\n\");continue;}}\r\n	else\r\n	{  if(d<1||d>xx[m-1]) {printf(\"别逗了\\n\");continue;}}\r\n	for(i=0;i<8;i++)\r\n		ds1+=xx[i];\r\n	ds1+=10;\r\n	for(i=0;i<m-1;i++)\r\n		ds2+=xx[i];\r\n	ds2+=d;\r\n \r\n	an=ds2-ds1;\r\n	if(an<=0) an+=365;\r\n	if(m==2&&d==29) an=537;\r\n	if(s%2)\r\n		printf(\"先生离你的下一个生日还有%d天\\n\",an);\r\n	else\r\n		printf(\"小姐离你的下一个生日还有%d天\\n\",an);\r\n	 \r\n	 \r\n	 \r\n	}\r\n}'),(784,'#include<iostream>\r\n#include<cmath>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n,i;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n	 \r\n	char p[19]={0};\r\n	cin>>p;\r\n	int m,d,s,nf=1900;\r\n	 if(strlen(p)==15)\r\n	 {	 m=(p[8]-48)*10+p[9]-48;\r\n	     d=(p[10]-48)*10+p[11]-48;\r\n		 nf+=(p[6]-48)*10+p[7]-48;\r\n	    s=p[14];}\r\n	 else\r\n	 {\r\n		 m=(p[10]-48)*10+p[11]-48;\r\n		 d=(p[12]-48)*10+p[13]-48;\r\n		 nf=(p[6]-48)*1000+  (p[7]-48)*100+ (p[8]-48)*10+p[9]-48;\r\n	     s=p[16];\r\n	 }\r\n	 \r\n	 int xx[]={31,28,31,30,31,30,31,31,30,31,30,31};\r\n	int ds1=0,ds2=0,an;\r\n	if(m<1||m>12) {printf(\"别逗了\\n\");continue;}\r\n	if(m==2&&(nf%4==0&&nf%100||nf%400==0))\r\n	{if(d<1||d>29) {printf(\"别逗了\\n\");continue;}}\r\n	else\r\n	{  if(d<1||d>xx[m-1]) {printf(\"别逗了\\n\");continue;}}\r\n	for(i=0;i<8;i++)\r\n		ds1+=xx[i];\r\n	ds1+=10;\r\n	for(i=0;i<m-1;i++)\r\n		ds2+=xx[i];\r\n	ds2+=d;\r\n \r\n	an=ds2-ds1;\r\n	if(an<=0) an+=365;\r\n	if(m==2&&d==29) an=537;\r\n	if(s%2)\r\n		printf(\"先生离你的下一个生日还有%d天\\n\",an);\r\n	else\r\n		printf(\"小姐离你的下一个生日还有%d天\\n\",an);\r\n	 \r\n	 \r\n	 \r\n	}\r\n}'),(785,'#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <queue>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    while(n--)\r\n    {\r\n        int m;\r\n        int ok =1;\r\n        queue<int> q;\r\n        scanf(\"%d\",&m);\r\n        if(m % 2== 0) {scanf(\"%d\",&m);}\r\n        int a[10010];\r\n        for(int i =0; i < m; i++) scanf(\"%d\",a+i);\r\n        for(int i =0; i < m; i++)\r\n        {\r\n\r\n            if(a[i] % 2 == 1)\r\n            {\r\n                if(ok  ==1)\r\n                {\r\n                    printf(\"%d\",a[i]);\r\n                    ok  = 0;\r\n                }\r\n                else\r\n                 printf(\" %d\",a[i]);\r\n\r\n            }\r\n            else\r\n            {\r\n                q.push(a[i]);\r\n            }\r\n        }\r\n        while(!q.empty())\r\n        {\r\n            int f =  q.front();\r\n            q.pop();\r\n            if(ok  ==1)\r\n            {\r\n                printf(\"%d\",f);\r\n                ok  = 0;\r\n            }\r\n            else\r\n                printf(\" %d\",f);\r\n\r\n        }\r\n        printf(\"\\n\");\r\n\r\n\r\n\r\n    }\r\n\r\n}'),(786,'#include<iostream>\r\n#include<cmath>\r\n#include<cstring>\r\n#include<algorithm>\r\n#include<fstream>\r\nusing namespace std;\r\nbool f(int n) {return n&1;}\r\nint main()\r\n{int a[10000];\r\n	 int m;\r\n	 cin>>m;\r\n	 while(m--)\r\n	 {\r\n	 int n,i =0,t;\r\n	 cin>>n;\r\n	 if(n>10){ cin>>t;}\r\n	  for(  i=0  ;i<n;i++)\r\n		cin>>a[i];\r\n	stable_partition(a,a+n,f);\r\n     for(  i=0;i<n-1;i++)\r\n		 cout<<a[i]<<\" \";\r\n	 cout<<a[i]<<endl;\r\n	 }\r\n}'),(787,'#include <cstdio>\r\n#include <cmath>\r\nint main()\r\n{\r\n    int n;\r\n    scanf(\"%d\",&n);\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        char GET_x,sym0,sym1,sym2;\r\n        int x,num1,num2,ans[10001]={0},wans[10001]={0},index_ans=0,index_wans=0;\r\n        scanf(\"%d\",&x);getchar();\r\n        scanf(\"%c%c%d%c%c%d\",&GET_x,&sym0,&num1,&sym1,&sym2,&num2);\r\n        for(int j=0;j<x;j++)\r\n        {\r\n            int tmp,k=0;\r\n            scanf(\"%d\",&tmp);\r\n            switch(sym0)\r\n            {\r\n                case \'+\':k=tmp+num1;break;\r\n                case \'-\':k=tmp-num1;break;\r\n                case \'*\':k=tmp*num1;break;\r\n                case \'/\':k=tmp/num1;break;\r\n                case \'%\':k=tmp%num1;break;\r\n            }\r\n            switch(sym1)\r\n            {\r\n                case \'>\':if(k>=num2) ans[index_ans++]=tmp; else wans[index_wans++]=tmp;\r\n                break;\r\n                case \'<\':if(k<=num2) ans[index_ans++]=tmp; else wans[index_wans++]=tmp;\r\n                break;\r\n                case \'!\':if(k!=num2) ans[index_ans++]=tmp; else wans[index_wans++]=tmp;\r\n                break;\r\n                case \'=\':if(k==num2) ans[index_ans++]=tmp; else wans[index_wans++]=tmp;\r\n                break;\r\n                case \' \':if(sym2==\'<\') if(k<num2) ans[index_ans++]=tmp; else wans[index_wans++]=tmp;\r\n                         else if(k>num2) ans[index_ans++]=tmp; else wans[index_wans++]=tmp;\r\n                break;\r\n            }\r\n        }\r\n        for(int j=index_ans;j<index_ans+index_wans;j++) ans[j]=wans[j-index_ans];\r\n        for(int j=0;j<index_ans+index_wans;j++) printf(\"%d%c\",ans[j],j==index_ans+index_wans-1?10:\' \');\r\n    }\r\n    return 0;\r\n}\r\n'),(788,'#include<iostream>\r\n#include<cmath>\r\n#include<cstring>\r\n#include<algorithm>\r\n#include<fstream>\r\nusing namespace std;\r\nbool test(int t,char pj, int y,char c1, char c2,int z)\r\n{\r\n	switch(pj)\r\n	{\r\n	case \'+\':t+=y;break;\r\n	case \'-\':t-=y;break;\r\n	case \'*\':t*=y;break;\r\n	case \'/\':t/=y;break;\r\n	case \'%\':t%=y;break;\r\n	}\r\n	if(c1==\' \'&&c2==\'<\') return t<z;\r\n	if(c1==\' \'&&c2==\'>\') return t>z;\r\n	if(c1==\'<\'&&c2==\'=\') return t<=z;\r\n	if(c1==\'>\'&&c2==\'=\') return t>=z;\r\n	if(c1==\'=\'&&c2==\'=\') return t==z;\r\n	if(c1==\'!\'&&c2==\'=\') return t!=z;\r\n}\r\nint main()\r\n{int a[10000],aa[10000];\r\nifstream in(\"c://1.txt\");\r\n ofstream out(\"c://2.txt\");\r\nint n;\r\n	 \r\nscanf(\"%d\",&n);\r\nwhile(n--)\r\n{\r\n	int m;\r\n	scanf(\"%d\",&m);\r\n    int mm=m;\r\n      int y,z;\r\n      char pj,c1,c2,xxx;\r\n	  char str[100];\r\n	    \r\n	 scanf( \"%cx%c%d%c%c%d\",&xxx,&pj,&y,&c1,&c2,&z);\r\n \r\n	int al=0,aal=0;\r\n	while(m--)\r\n	{\r\n		int t;\r\n		 \r\n		scanf(\"%d\",&t);\r\n		if(test(t,pj,y,c1,c2,z))\r\n		   a[al++]=t;\r\n		else\r\n			aa[aal++]=t;\r\n		\r\n	}\r\n	int i;\r\n	for(i=0;i<al-1;i++)\r\n        cout<<a[i]<<\" \";\r\n	if(al==mm)\r\n		cout<<a[i]<<endl;\r\n	else\r\n	{ if(i<al)	cout<<a[i]<<\" \";\r\n	    for(i=0;i<aal-1;i++)\r\n          cout<<aa[i]<<\" \";\r\n        cout<<aa[i]<<endl;\r\n	}\r\n       \r\n\r\n}\r\n\r\n}'),(789,'#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\nstruct Node\r\n{\r\n    int a;\r\n    int b;\r\n    int c;\r\n};\r\nint main()\r\n{\r\n    int m,n;\r\n    vector<Node> v;\r\n    cin>>m>>n;\r\n    for(int i =0; i< m;i++)\r\n    {\r\n        Node node;\r\n        cin>>node.a>>node.b>>node.c;\r\n        v.push_back(node);\r\n\r\n    }\r\n    for(int i =0; i < n; i++)\r\n    {\r\n        int p;\r\n        int all =0;\r\n        cin>>p;\r\n        for(int t = 0; t < v.size(); t++)\r\n        {\r\n            if(p >= v[t].a  && p < v[t].b)\r\n                all += v[t].c;\r\n        }\r\n        cout<<all<<endl;\r\n    }\r\n    return 0;\r\n}\r\n'),(790,'#include<stdio.h>\r\nmain()\r\n{\r\n	int a[100][3],n1,n2,i,j,sum,x;\r\n	scanf(\"%d%d\",&n1,&n2);\r\n	for(i=0;i<n1;i++)\r\n		for(j=0;j<3;j++)\r\n			scanf(\"%d\",&a[i][j]);\r\n	for(;n2>0;n2--)\r\n	{\r\n		sum=0;\r\n		scanf(\"%d\",&x);\r\n		for(i=0;i<n1;i++)\r\n			if(x>=a[i][0]&&x<a[i][1]) sum+=a[i][2];\r\n		printf(\"%d\\n\",sum);\r\n	}\r\n}'),(791,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\nusing namespace std;\r\ndouble f(double a,double b,double(*h)(double))\r\n{\r\n	double s=0;\r\n	int i;\r\n	double deta=(b-a)/100000;\r\n	for(i=0;i<100000;i++)\r\n		s+=h(a+i*deta)*deta;\r\n	return s;\r\n}\r\ndouble xx(double x)\r\n{\r\n	return x*x;\r\n}\r\ndouble m15(double x)\r\n{return pow(1.5,x);}\r\ndouble log2(double x)\r\n{\r\n	return log10(x)/log10(2);\r\n}\r\nint main()\r\n{ double a,b;\r\n scanf(\"%lf%lf\",&a,&b);\r\n	printf(\"sin(x)%.2lf\\n\",f(a,b,sin));\r\n    printf(\"cos(x)%.2lf\\n\",f(a,b,cos));\r\n	printf(\"exp(x)%.2lf\\n\",f(a,b,exp));\r\n	printf(\"log(x)%.2lf\\n\",f(a,b,log));\r\n	printf(\"log2(x)%.2lf\\n\",f(a,b,log2));\r\n	printf(\"log10(x)%.2lf\\n\",f(a,b,log10));\r\n	printf(\"1.5^x%.2lf\\n\",f(a,b,m15));\r\n	printf(\"x*x%.2lf\\n\",f(a,b,xx));\r\n \r\n}'),(792,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\nusing namespace std;\r\ndouble f(double a,double b,double(*h)(double))\r\n{\r\n	double s=0;\r\n	int i;\r\n	double deta=(b-a)/100000;\r\n	for(i=0;i<100000;i++)\r\n		s+=h(a+i*deta)*deta;\r\n	return s;\r\n}\r\ndouble xx(double x)\r\n{\r\n	return x*x;\r\n}\r\ndouble m15(double x)\r\n{return pow(1.5,x);}\r\ndouble log2(double x)\r\n{\r\n	return log10(x)/log10(2);\r\n}\r\nint main()\r\n{ double a,b;\r\n scanf(\"%lf%lf\",&a,&b);\r\n	printf(\"sin(x)%.2lf\\n\",f(a,b,sin));\r\n    printf(\"cos(x)%.2lf\\n\",f(a,b,cos));\r\n	printf(\"exp(x)%.2lf\\n\",f(a,b,exp));\r\n	printf(\"log(x)%.2lf\\n\",f(a,b,log));\r\n	printf(\"log2(x)%.2lf\\n\",f(a,b,log2));\r\n	printf(\"log10(x)%.2lf\\n\",f(a,b,log10));\r\n	printf(\"1.5^x%.2lf\\n\",f(a,b,m15));\r\n	printf(\"x*x%.2lf\\n\",f(a,b,xx));\r\n \r\n}'),(793,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\nusing namespace std;\r\n \r\ndouble logxy(double x,double y)\r\n{\r\n	return log10(y)/log10(x);\r\n}\r\nint main()\r\n{  \r\n   int n;\r\n   scanf(\"%d\",&n);\r\n   while(n--)\r\n   {\r\n	   double x,y;\r\n	    \r\n	    scanf(\"%lf%lf\",&x,&y);\r\n	    printf(\"%.2lf\\n\",logxy(x,y));\r\n   }\r\n}'),(794,'#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	int n;\r\n	double x,y;\r\n	scanf(\"%d\",&n);\r\n	while(n--)\r\n	{\r\n		scanf(\"%lf%lf\",&x,&y);\r\n		double cur=log(y)/log(x);\r\n		printf(\"%.2lf\\n\",cur);\r\n	}\r\n	return 0;\r\n}\r\n'),(795,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  while(n--)\r\n  {\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  bool b1=includes(a,a+an,b,b+bn);\r\n      bool b2=includes(b,b+bn,a,a+an);\r\n	  if(b1&&b2)\r\n		  cout<<\"A==B\\n\";\r\n	  if(b1&&!b2)\r\n		  cout<<\"AincludeB\\n\";\r\n	  if(!b1&&b2)\r\n		  cout<<\"BincludeA\\n\";\r\n	  if(!b1&&!b2)\r\n		  cout<<\"haha\\n\";\r\n\r\n  }\r\n  \r\n}'),(796,'#include <iostream>\r\n#include <map>\r\nusing namespace std;\r\nint main(){\r\n	int n;\r\n	while(cin>>n){\r\n		while(n--){\r\n		int t;\r\n		cin>>t;\r\n		map <int,int> m;\r\n		int inxa=0;\r\n		for(int i=0;i<t;i++){\r\n			int b;\r\n			cin>>b;\r\n			if(!m[b])m[b]=++inxa;\r\n		}\r\n		int tt;\r\n		cin>>tt;\r\n		int inxb=0;\r\n		int binxa=0;\r\n		for(int i=0;i<tt;i++){\r\n			int b;\r\n			cin>>b;\r\n			if(m[b])binxa++;\r\n			else inxb++;\r\n		}\r\n		if(binxa==tt&&tt==t)\r\n		      cout<<\"A==B\"<<endl;\r\n		else if(binxa==t&&tt>t)\r\n		      cout<<\"BincludeA\"<<endl;\r\n		else if(binxa==tt&&tt<t)\r\n		      cout<<\"AincludeB\"<<endl;\r\n		else cout<<\"haha\"<<endl;\r\n	}\r\nreturn 0;\r\n}\r\n}'),(797,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  while(n--)\r\n  {\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_intersection(a,a+an,b,b+bn,c)-c;\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(798,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  while(n--)\r\n  {\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_intersection(a,a+an,b,b+bn,c)-c;\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(799,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  while(n--)\r\n  {\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_union(a,a+an,b,b+bn,c)-c;\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(800,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  while(n--)\r\n  {\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_union(a,a+an,b,b+bn,c)-c;\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(801,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  while(n--)\r\n  {\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_difference(a,a+an,b,b+bn,c)-c;\r\n	  if(cn>0)\r\n	  {\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n	  }else cout<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(802,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  while(n--)\r\n  {\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_difference(a,a+an,b,b+bn,c)-c;\r\n	  if(cn>0)\r\n	  {\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n	  }else cout<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(803,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  int k=0;\r\n  while(n--)\r\n  {k++;\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_symmetric_difference(a,a+an,b,b+bn,c)-c;\r\n	 \r\n	  if(cn>0)\r\n	  {\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n	  } else cout<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(804,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{  \r\n  int a[100];\r\n  int b[100];\r\n  int n;\r\n  cin>>n;\r\n  int k=0;\r\n  while(n--)\r\n  {k++;\r\n	  int an,bn,i;\r\n	  cin>>an;\r\n	  for(i=0;i<an;i++)\r\n		  cin>>a[i];\r\n	  cin>>bn;\r\n	  for(i=0;i<bn;i++)\r\n		  cin>>b[i];\r\n	  sort(a,a+an);\r\n	  sort(b,b+bn);\r\n	  int c[200];\r\n	  int  cn=set_symmetric_difference(a,a+an,b,b+bn,c)-c;\r\n	 \r\n	  if(cn>0)\r\n	  {\r\n	  for(i=0;i<cn-1;i++)\r\n		  cout<<c[i]<<\" \";\r\n	  cout<<c[i]<<endl;\r\n	  } else cout<<endl;\r\n\r\n	  \r\n\r\n  }\r\n  \r\n}'),(805,'#include<stdio.h>\r\n#include<math.h>\r\nint f(int a,int b)\r\n{\r\nint t;\r\nwhile(b)\r\n{\r\nt=a;\r\na=b;\r\nb=t%b;\r\n}\r\nreturn abs(a);\r\n}\r\nint main()\r\n{\r\n int n;\r\n scanf(\"%d\",&n);\r\n while(n--)\r\n {\r\n int a,b;scanf(\"%d%d\",&a,&b);\r\n printf(\"%d\\n\",f(a,b));\r\n }\r\n}'),(806,'#include<stdio.h>\r\n#include<math.h>\r\nint f(int a,int b)\r\n{\r\nint t;\r\nwhile(b)\r\n{\r\nt=a;\r\na=b;\r\nb=t%b;\r\n}\r\nreturn abs(a);\r\n}\r\nint main()\r\n{\r\n int n;\r\n scanf(\"%d\",&n);\r\n while(n--)\r\n {\r\n int a,b;scanf(\"%d%d\",&a,&b);\r\n printf(\"%d\\n\",f(a,b));\r\n }\r\n}'),(807,'#include<map>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<ctime>\r\n#include<cstdio>\r\n#include<algorithm>\r\nusing namespace std;\r\n \r\n \r\nint main()\r\n{   \r\n	 double a;\r\n	 cin>>a;\r\n	 while(a)\r\n	 {\r\n		 int i=a>=0?(int)(a+0.5):(int)(a-0.5);\r\n		 cout<<i<<endl;\r\n		 cin>>a;\r\n	 }\r\n}'),(808,'#include<stdio.h>\r\n main()\r\n{float i,b;\r\nscanf(\"%f\\n%f\\n\",&i,&b);\r\nprintf(\"%0.0f\\n%0.0f\",i,b);\r\n}'),(809,'#include<iostream>\r\nusing namespace std;\r\nchar f(int n)\r\n{\r\nif(n<100||n>999) return \'N\';\r\nint g,s,b;\r\ng=n%10;s=n/10%10;b=n/100;\r\nif(n==g*g*g+s*s*s+b*b*b) return \'Y\';\r\nreturn \'N\';\r\n}\r\nint main()\r\n{\r\n int n;\r\n cin>>n;\r\n while(n--){int m;cin>>m;\r\n cout<<f(m)<<endl;}\r\n}\r\n'),(810,'#include<stdio.h>\r\nint main()\r\n{\r\n	int n,b;\r\n	scanf(\"%d\",&n);\r\n	for(int i=1;i<=n;++i){\r\n		scanf(\"%d\",&b);\r\n		if(b==153||b==370||b==371||b==407){\r\n			printf(\"Y\\n\");\r\n		}else{\r\n			printf(\"N\\n\");\r\n		}\r\n	}\r\n   return 0;\r\n}'),(811,'#include <stdio.h>\r\nint main()\r\n{\r\n	int a,p;\r\n	scanf(\"%d\",&a);\r\n	for(int i=0;i<a;i++)\r\n	{\r\n		scanf(\"%d\",&p);\r\n		if(p==1)\r\n			printf(\"10\\n\");\r\n		if(p==2)\r\n			printf(\"0\\n\");\r\n		if(p==3)\r\n			printf(\"4\\n\");\r\n		if(p==4)\r\n			printf(\"3\\n\");\r\n		if(p==5)\r\n			printf(\"3\\n\");\r\n		if(p==6)\r\n			printf(\"1\\n\");\r\n	}\r\n	return 0;\r\n}'),(812,'#include <stdio.h>\r\nint main()\r\n{\r\n    int a[8]={0,10,0,4,3,3,1,4};\r\n    int n,x,i;\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n    {\r\n        scanf(\"%d\",&x);\r\n        printf(\"%d\\n\",a[x]);\r\n    }\r\n\r\n    return 0;\r\n}\r\n'),(813,'#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n int n;\r\n cin>>n;\r\n while(n--)\r\n {int h,m,s,s1;cin>>h>>m>>s>>s1;\r\n    s+=s1%60;\r\n	if(s>59){m++;s%=60;}\r\n	m+=s1%3600/60;\r\n	if(m>59){h++;m%=60;}\r\n	h+=s1/3600;\r\n	h%=24;\r\n    cout<<h<<\":\"<<m<<\":\"<<s<<endl;\r\n }\r\n}\r\n'),(814,'#include<stdio.h>\r\nint main()\r\n{\r\n	int i,a,b,c,d,n,s1;\r\n	scanf(\"%d\",&n);\r\n	for(i=1;i<=n;i++)\r\n	{s1=0;\r\n		scanf(\"%d%d%d%d\",&a,&b,&c,&d);\r\n		s1=a*3600+b*60+c+d;\r\n		printf(\"%d:%d:%d\\n\",s1/3600%24,s1%3600/60,s1%3600%60);\r\n	}\r\n	return 0;\r\n}'),(815,'#include<stdio.h>\r\nint main()\r\n{int n;\r\nwhile(scanf(\"%d\",&n))\r\n{\r\nif(!n)break;\r\nif(n%7) printf(\"%d\\n\",n);\r\n\r\n}\r\n}'),(816,'#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n;\r\n    while(cin>>n && n) if(n%7) cout<<n<<endl;\r\n}\r\n'),(817,'#include<iostream>\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n  while(1)\r\n  {\r\n	  char str[111];\r\n	  scanf( \"%s\",str);\r\n	  double a;\r\n	  sscanf(str,\"%lf\",&a);\r\n	  if(a==0) break;\r\n	  char s[11]={0};\r\n	  int j=strlen(str)-1;\r\n	  int flag=0,i=0;\r\n	  for(;j>=0;j--)\r\n		   if(flag==0&&str[j]==\'0\');\r\n		   else{flag=1;s[i++]=str[j];}\r\n	  \r\n	 if(s[0]==\'.\') printf(\"0\");\r\n	 printf(\"%s\\n\",s);\r\n\r\n  }\r\n}\r\n'),(818,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	char a[100],i,n;\r\n	while(~scanf(\"%s\",a))\r\n	{\r\n		n=strlen(a);\r\n		while(a[n-1]==\'0\')\r\n		{\r\n			n--;\r\n			if(a[n-1]==\'.\') printf(\"0\");\r\n		}\r\n		for(i=n-1;i>=0;i--)\r\n			printf(\"%c\",a[i]);\r\n		printf(\"\\n\");\r\n	}\r\n}'),(819,'#include<iostream>\r\n#include<fstream>\r\n\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\n \r\nint main()\r\n{ //ofstream cout(\"c://1.txt\");\r\n   int n;\r\n   cin>>n;\r\n   while(n--)\r\n   {   int a,b,c;\r\n	   cin>>a>>b>>c;\r\n	   if(b%7 >(c-a+7)%7) cout<<b/7+1<<endl;\r\n	   else cout<<b/7<<endl;\r\n   }\r\n}\r\n'),(820,'#include<stdio.h> \r\nint main() \r\n{ \r\nint x;scanf(\"%d\",&x); \r\nwhile(x--) \r\n{ \r\nint a,b,c; \r\nscanf(\"%d%d%d\",&a,&b,&c); \r\nprintf(\"%d\\n\",b/7+(b%7>(c-a+7)%7?1:0)); \r\n} \r\nreturn 0; \r\n}\r\n'),(821,'#include<iostream>\r\n#include<fstream>\r\n\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\n \r\nint main()\r\n{ \r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n		int a,b,i,count=0;\r\n		int t=3,ts=365;\r\n		cin>>a>>b;\r\n		for(i=2014;i<a;i++)\r\n			if((i-1)%400==0||(i-1)%4==0&&(i-1)%100)\r\n				count+=366;\r\n			else count+=365;\r\n        t=(t+count%7)%7;\r\n		if(a%400==0||a%4==0&&a%100) ts++;\r\n		if(ts==365&&b!=t\r\n			||ts==366&&b!=t&&b!=(t+1)%7)cout<<52<<endl;\r\n		else cout<<53<<endl;\r\n\r\n\r\n	}\r\n    \r\n}\r\n'),(822,'#include<iostream>\r\n#include<fstream>\r\n\r\n#include<cmath>\r\n#include<cstdio>\r\n#include<cstring>\r\nusing namespace std;\r\n \r\nint main()\r\n{ \r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n		int a,b,i,count=0;\r\n		int t=3,ts=365;\r\n		cin>>a>>b;\r\n		for(i=2014;i<a;i++)\r\n			if((i-1)%400==0||(i-1)%4==0&&(i-1)%100)\r\n				count+=366;\r\n			else count+=365;\r\n        t=(t+count%7)%7;\r\n		if(a%400==0||a%4==0&&a%100) ts++;\r\n		if(ts==365&&b!=t\r\n			||ts==366&&b!=t&&b!=(t+1)%7)cout<<52<<endl;\r\n		else cout<<53<<endl;\r\n\r\n\r\n	}\r\n    \r\n}\r\n'),(823,'#include<iostream>\r\n#include<cstring>\r\nusing namespace std;\r\nbool hl=0;\r\nchar a[5];\r\nchar test[5][6]={\"DDDSS\",\"DDSSD\",\"DSSDD\",\"SSDDD\",\"SDDDS\"};\r\nbool com(char* b)\r\n{\r\n	for(int i=0;i<5;i++)\r\n		if(a[i]&&a[i]!=b[i]) return 0;\r\n	return 1;\r\n}\r\nvoid read(int &q)\r\n{\r\n	memset(a,0,sizeof(a));\r\n	hl=0;\r\n	int c;\r\n	cin>>c>>q;\r\n	while(c--)\r\n	{\r\n		int t;char h;\r\n		cin>>t>>h;\r\n		t%=5;\r\n        if(a[t]==0){a[t]=h;continue;}\r\n		if(a[t]&&a[t]!=h) hl=1;\r\n	}\r\n	for(c=0;c<5;c++)\r\n		if(com(test[c])) break;\r\n	if(c==5)hl=1;\r\n}\r\nint f(int t)\r\n{\r\n	t%=5;\r\n	if(hl)return 3;\r\n    if(a[t]) return a[t]==\'D\'?0:1;\r\n	int count=0;\r\n	char an=0;\r\n	for(int i=0;i<5;i++)\r\n		if(com(test[i]))an|=test[i][t];\r\n	if(an==\'D\') return 0;\r\n	else if(an==\'S\') return 1;\r\n	return 2;\r\n}\r\n\r\nchar *ss[4]={\"打鱼\",\"晒网\",\"不确定\",\"已知条件有错\"};\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n		int q;\r\n		read(q);\r\n		while(q--)\r\n		{\r\n			int t;cin>>t;\r\n			cout<<ss[f(t)]<<endl;\r\n		}\r\n	}\r\n}'),(824,'#include<iostream>\r\n#include<cstring>\r\nusing namespace std;\r\nbool hl=0;\r\nchar a[5];\r\nchar test[5][6]={\"DDDSS\",\"DDSSD\",\"DSSDD\",\"SSDDD\",\"SDDDS\"};\r\nbool com(char* b)\r\n{\r\n	for(int i=0;i<5;i++)\r\n		if(a[i]&&a[i]!=b[i]) return 0;\r\n	return 1;\r\n}\r\nvoid read(int &q)\r\n{\r\n	memset(a,0,sizeof(a));\r\n	hl=0;\r\n	int c;\r\n	cin>>c>>q;\r\n	while(c--)\r\n	{\r\n		int t;char h;\r\n		cin>>t>>h;\r\n		t%=5;\r\n        if(a[t]==0){a[t]=h;continue;}\r\n		if(a[t]&&a[t]!=h) hl=1;\r\n	}\r\n	for(c=0;c<5;c++)\r\n		if(com(test[c])) break;\r\n	if(c==5)hl=1;\r\n}\r\nint f(int t)\r\n{\r\n	t%=5;\r\n	if(hl)return 3;\r\n    if(a[t]) return a[t]==\'D\'?0:1;\r\n	int count=0;\r\n	char an=0;\r\n	for(int i=0;i<5;i++)\r\n		if(com(test[i]))an|=test[i][t];\r\n	if(an==\'D\') return 0;\r\n	else if(an==\'S\') return 1;\r\n	return 2;\r\n}\r\n\r\nchar *ss[4]={\"打鱼\",\"晒网\",\"不确定\",\"已知条件有错\"};\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n		int q;\r\n		read(q);\r\n		while(q--)\r\n		{\r\n			int t;cin>>t;\r\n			cout<<ss[f(t)]<<endl;\r\n		}\r\n	}\r\n}'),(825,'#include<iostream>\r\n#include<cstring>\r\n#include<fstream>\r\n using namespace std;\r\n \r\nint main()\r\n{\r\n//	 ifstream cin(\"c://1.txt\");\r\n	 int n;cin>>n;\r\n	 int i,	 count=0;\r\n	 for(i=0;i<n;i++)\r\n	 {\r\n		  bool hl=0;\r\n		  int s1=0,s2=0;\r\n		  int m,j;\r\n		  cin>>m;\r\n		  while(m--)\r\n		  {\r\n			  int f,xf;\r\n			  cin>>f>>xf;\r\n			  if(f<60) hl=1;\r\n			  s1+=f*xf;\r\n			  s2+=xf;\r\n		  }\r\n		  hl=hl||s1/s2<68;\r\n		  if(!hl)count++;\r\n		 // else cout<<i+1<<endl;\r\n	 }\r\n	 cout<<count<<endl;\r\n}'),(826,'#include<stdio.h> \r\nint main() \r\n{ \r\nint x,count=0;scanf(\"%d\",&x); \r\nwhile(x--) \r\n{ \r\nint y,sum1=0,sum2=0,n=1; \r\nscanf(\"%d\",&y); \r\nwhile(y--) \r\n{ \r\nint a,b; \r\nscanf(\"%d%d\",&a,&b); \r\nif(a<60) n=0 ; \r\nsum1+=a*b;sum2+=b; \r\n} \r\nif(sum1*1.0/sum2<68)n=0; \r\nif(n)count++; \r\n} \r\nprintf(\"%d\\n\",count); \r\nreturn 0; \r\n} \r\n'),(827,'#include<iostream>\r\n#include<cstring>\r\n#include<fstream>\r\n using namespace std;\r\n \r\nint main()\r\n{\r\n	// ifstream cin(\"c://1.txt\");\r\nint n;cin>>n;\r\n	 for(int i=0;i<n;i++)\r\n	 {\r\n		 double a,an;int b;\r\n		 cin>>a>>b;\r\n		 a*=b;\r\n		 an=(200*68-a)/(200-b);\r\n		 if(an<60)printf(\"%.2lf\\n\",60.00);\r\n		 else if(an>100)printf(\"重修吧\\n\",60.00);\r\n		 else printf(\"%.2lf\\n\",an);\r\n	 }\r\n}'),(828,'#include<stdio.h>\r\n\r\nint main(void)\r\n{\r\n	int i,n,b;\r\n	double a,re;\r\n	scanf(\"%d\",&n);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf(\"%lf %d\",&a,&b);\r\n		re=(13600-a*b)/(200-b);\r\n	\r\n	if(re>100.0 || a<60)\r\n		printf(\"重修吧\");\r\n	else if(re<60.0)\r\n		printf(\"60.00\");\r\n	else\r\n		printf(\"%.2lf\",re);\r\n	printf(\"\\n\");\r\n	}\r\n\r\n	  return 0;\r\n}'),(829,'#include<iostream>\r\n#include<cstring>\r\n#include<fstream>\r\n using namespace std;\r\n char p[]=\"BATbat\",q[1111];\r\nint main()\r\n{  \r\n	int count[6]={0};\r\n	cin>>q;\r\n	 for(int i=0;q[i];i++)\r\n	 {  \r\n	    if(q[i]==\'B\')count[0]++;\r\n		 if(q[i]==\'A\')count[1]++;\r\n		 if(q[i]==\'T\')count[2]++;\r\n		 if(q[i]==\'b\')count[3]++;\r\n		 if(q[i]==\'a\')count[4]++;\r\n		 if(q[i]==\'t\')count[5]++;\r\n	}\r\n	  \r\n	  \r\n	 cout<<\"百度就业\"<<count[0]<<\"人实习\"<<count[3]<<\"人\"<<endl;\r\n	 cout<<\"阿里巴巴就业\"<<count[1]<<\"人实习\"<<count[4]<<\"人\"<<endl;\r\n	 cout<<\"腾讯就业\"<<count[2]<<\"人实习\"<<count[5]<<\"人\"<<endl;\r\n	 cout<<\"BAT就业共\"<<count[0]+count[1]+count[2]<<\"人实习共\"\r\n		 <<count[3]+count[4]+count[5]<<\"人\"<<endl;\r\n}'),(830,'#include<stdio.h>\r\nint main()\r\n{\r\n	char ch,b,a,t,B,A,T;\r\n	b=a=t=B=A=T=0;\r\n	while((ch=getchar())!=\'\\n\')\r\n	{\r\n		if(ch==\'b\')b++;\r\n		if(ch==\'B\')B++;\r\n		if(ch==\'a\')a++;\r\n		if(ch==\'A\')A++;\r\n		if(ch==\'t\')t++;\r\n		if(ch==\'T\')T++;\r\n	}\r\n	printf(\"百度就业%d人实习%d人\\n阿里巴巴就业%d人实习%d人\\n腾讯就业%d人实习%d人\\nBAT就业共%d人实习共%d人\\n\",B,b,A,a,T,t,B+A+T,b+a+t);\r\n	return 0;\r\n}'),(831,'#include<iostream>\r\n#include<cstring>\r\n#include<fstream>\r\n using namespace std;\r\n   char a[10000];\r\nint main()\r\n{  \r\n//	ifstream cin(\"c://1.txt\");\r\n	char *str[]={\"高等数学\",\"大学英语\",\"C语言\",\"数据结构\",\"计算机组成原理\",\"\"};\r\n   char p[22];\r\n	while(cin>>p)\r\n   { \r\n       cout<<p;\r\n	   bool ff=1;\r\n	   for(int j=0;j<5;j++)\r\n	   {\r\n		   double x;\r\n		   cin>>x;\r\n           if(x<60){ff=0;cout<<\" \"<<str[j];}\r\n	   }\r\n	   if(ff)cout<<\" 好学生\"<<endl;\r\n	   else\r\n	   cout<<endl;\r\n   }\r\n    \r\n}'),(832,'#include <stdio.h>\r\nint main()\r\n{\r\n	char name[110];\r\n	float a,b,c,d,e;\r\n	while(scanf(\"%s %f %f %f %f %f\",&name,&a,&b,&c,&d,&e)!=EOF)\r\n	{\r\n		printf(\"%s\",name);\r\n		if(a<60)\r\n			printf(\" 高等数学\");\r\n		if(b<60)\r\n			printf(\" 大学英语\");\r\n		if(c<60)\r\n			printf(\" C语言\");\r\n		if(d<60)\r\n			printf(\" 数据结构\");\r\n		if(e<60)\r\n			printf(\" 计算机组成原理\");\r\n		if(a>=60&&b>=60&&c>=60&&d>=60&&e>=60)\r\n			printf(\" 好学生\");\r\n		printf(\"\\n\");\r\n	}\r\n}\r\n'),(833,'#include<cstdio>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	//ifstream cin(\"c://1.txt\");\r\n	int n;cin>>n;\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	   char a[1000];\r\n	   cin>>a;\r\n	   int s=0;\r\n	   for(int j=0;j<strlen(a);j++)\r\n          s+=a[j]-\'0\';\r\n	   cout<<(s%3?\'N\':\'Y\')<<endl;\r\n	}\r\n}'),(834,'#include <iostream>\r\n#include <string>\r\n#include <stdio.h>\r\n\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\nint n;\r\nwhile(cin >> n)\r\n{\r\nwhile(n--)\r\n{\r\nstring str;\r\ncin >> str;\r\nint sum = 0;\r\nfor(int i = 0; i < str.length(); i++)\r\n{\r\nsum += str[i] - \'0\';\r\n}\r\nprintf(\"%c\\n\", sum % 3 ? \'N\' : \'Y\');\r\n}\r\n}\r\n}'),(835,'#include<cstdio>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	//ifstream cin(\"c://1.txt\");\r\n	int n;cin>>n;\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	   char a[1000];\r\n	   cin>>a;\r\n	   int s=0;\r\n	   for(int j=0;j<strlen(a);j++)\r\n          s+=a[j]-\'0\';\r\n	   cout<<(s%9?\'N\':\'Y\')<<endl;\r\n	}\r\n}'),(836,'#include <iostream>\r\n#include <string>\r\n#include <stdio.h>\r\n\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\nint n;\r\nwhile(cin >> n)\r\n{\r\nwhile(n--)\r\n{\r\nstring str;\r\ncin >> str;\r\nint sum = 0;\r\nfor(int i = 0; i < str.length(); i++)\r\n{\r\nsum += str[i] - \'0\';\r\n}\r\nprintf(\"%c\\n\", sum % 9 ? \'N\' : \'Y\');\r\n}\r\n}\r\n}'),(837,'#include<cstdio>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	//ifstream cin(\"c://1.txt\");\r\n	int n;cin>>n;\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	   char a[1000];\r\n	   cin>>a;\r\n	   int s=0,s1=0,s2=0;\r\n	   for(int j=0;j<strlen(a);j++)\r\n       { if(j&1) s1+=a[j]-48;\r\n	   else s2+=a[j]-48;}s=s1-s2;\r\n	   cout<<(s%11?\'N\':\'Y\')<<endl;\r\n	}\r\n}'),(838,'#include<stdio.h>\r\n#include<string.h>\r\nmain()\r\n{\r\n	int n,i,n1;\r\n	char a[150];\r\n	scanf(\"%d\\n\",&n1);\r\n	for(;n1>0;n1--)\r\n	{\r\n		gets(a);\r\n	n=strlen(a);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		a[i]-=\'0\';\r\n	}\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n		a[i+1]-=a[i];\r\n		if(a[i+1]<0) a[i+1]+=11;\r\n	}\r\n	if(a[n-1]) printf(\"N\\n\");\r\n	else printf(\"Y\\n\");\r\n	}\r\n}'),(839,'#include <iostream>\r\n#include <cstdio>\r\nusing namespace std;\r\nint main(){\r\n	int n;\r\n	cin>>n;\r\n	while(n--){\r\n	string h;\r\n	cin>>h;\r\n	int y=0,c=1;\r\n	for(int i=h.length()-1;i>=0;i--){\r\n		y+=(h[i]-\'0\')*c;\r\n		c*=10;\r\n		y%=8;\r\n	}\r\n	printf(\"%c\\n\",y%8==0?\'Y\':\'N\');\r\n	}\r\n}'),(840,'#include <iostream>\r\n#include <cstdio>\r\nusing namespace std;\r\nint main(){\r\n	int n;\r\n	cin>>n;\r\n	while(n--){\r\n	string h;\r\n	cin>>h;\r\n	int y=0,c=1;\r\n	for(int i=h.length()-1;i>=0;i--){\r\n		y+=(h[i]-\'0\')*c;\r\n		c*=10;\r\n		y%=8;\r\n	}\r\n	printf(\"%c\\n\",y%8==0?\'Y\':\'N\');\r\n	}\r\n}'),(841,'#include<cstdio>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\nbool f(char * a,int b)\r\n{  //cout<<a<<b<<endl;\r\n	int s=0,y=1;\r\n	for(int i=0;i<strlen(a);i++)\r\n	{\r\n		s+=y*(a[strlen(a)-1-i]-48);\r\n		y*=10;\r\n		y%=b;\r\n	}\r\n	return s%b;\r\n\r\n}\r\nint main()\r\n{\r\n	//ifstream cin(\"c://1.txt\");\r\n	int n;cin>>n;\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	   char a[1000]; \r\n	   cin>>a ;\r\n	    \r\n	   cout<<(f(a,7)?\'N\':\'Y\')<<endl;\r\n	}\r\n}\r\n '),(842,'#include<cstdio>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\nint m[]={1,3,2,6, 4, 5};\r\nint main()\r\n{\r\n//	ifstream cin(\"c://1.txt\");\r\n	int n;cin>>n;\r\n	for(int i=0;i<n;i++)\r\n	{\r\n	   char a[1000];\r\n	   cin>>a;\r\n	   int s=0;\r\n	   for(int j=0;j<strlen(a);j++)\r\n       { s+=m[j%6]*(a[strlen(a)-1-j]-48); }\r\n	   cout<<(s%7?\'N\':\'Y\')<<endl;\r\n	}\r\n}\r\n '),(843,'  #include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\nusing namespace std;\r\nconst int maxn = 10000;\r\nint main()\r\n{  int m,n1;\r\n    cin>>m;\r\n    while(m--)\r\n    {char n[maxn];\r\n      scanf(\"%s\",n);\r\n      scanf(\"%d\",&n1);\r\n      int len  = strlen(n);\r\n      int ans = 0;\r\n      for(int i =0; i < len; i++)\r\n     {\r\n       ans=int(((long long)ans*10+n[i]-\'0\')%n1);\r\n     }\r\n     if(ans == 0) cout<<\"Y\"<<endl;\r\n     else cout<<\"N\"<<endl;\r\n    }}\r\n'),(844,'import java.math.*;\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n	\r\n	public static void main (String args[]) {\r\n		Scanner in = new Scanner (System.in);\r\n		int T = in.nextInt();\r\n		while (T -- > 0) {\r\n			BigInteger a = in.nextBigInteger(), b = in.nextBigInteger();\r\n			if (a.mod(b).compareTo(BigInteger.ZERO) == 0) {\r\n				System.out.println (\"Y\");\r\n			} else {\r\n				System.out.println (\"N\");\r\n			}\r\n		}\r\n	}\r\n}'),(845,'#include<cstdio>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<fstream>\r\nusing namespace std;\r\nchar *a[10]={\"甲\",\"乙\",\"丙\",\"丁\",\"戊\",\"己\",\"庚\",\"辛\",\"壬\",\"癸\"};\r\nchar *b[12]={\"子\",\"丑\",\"寅\",\"卯\",\"辰\",\"巳\",\"午\",\"未\",\"申\",\"酉\",\"戌\",\"亥\"}\r\n;void f(int n )\r\n{   \r\n    int t=0;\r\n	int d=6;\r\n	cout<<a[(n-1894-t+10)%10]<<b[(n-1894-d+12)%12]<<endl;\r\n}\r\nint main()\r\n{\r\n//	ofstream cout(\"c://1.txt\");\r\n	int  n;\r\n	 while(cin>>n)\r\n	 {\r\n		 if(!n) break;\r\n		 f(n);\r\n	 }\r\n	 \r\n}\r\n '),(846,'#include <iostream>\r\n#include <cstdio>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    char tian[11][5] = {\"甲\",\"乙\",\"丙\",\"丁\",\"戊\",\"己\",\"庚\",\"辛\",\"壬\",\"癸\"};\r\n    char di[15][5] ={\"子\",\"丑\",\"寅\",\"卯\",\"辰\",\"巳\",\"午\",\"未\",\"申\",\"酉\",\"戌\",\"亥\"};\r\n    int n;\r\n    while(cin>>n  && n!= 0)\r\n    {\r\n        cout<<tian[(n-4)%10]<<di[(n-4)%12]<<endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n'),(847,'#include<cstdio>\r\n#include<cstring>\r\n#include<iostream>\r\n#include<fstream>\r\n#include<string>\r\n#include<vector>\r\nusing namespace std;\r\n \r\nint main()\r\n{ \r\n\r\nchar *strs[407]={\"赵\",\"钱\",\"孙\",\"李\",\"周\",\r\n\"吴\",\"郑\",\"王\",\"冯\",\"陈\",\"褚\",\"卫\",\r\n\"蒋\",\"沈\",\"韩\",\"杨\",\"朱\",\"秦\",\"尤\",\r\n\"许\",\"何\",\"吕\",\"施\",\"张\",\"孔\",\"曹\",\r\n\"严\",\"华\",\"金\",\"魏\",\"陶\",\"姜\",\"戚\",\r\n\"谢\",\"邹\",\"喻\",\"柏\",\"水\",\"窦\",\"章\",\r\n\"云\",\"苏\",\"潘\",\"葛\",\"奚\",\"范\",\"彭\",\r\n\"郎\",\"鲁\",\"韦\",\"昌\",\"马\",\"苗\",\"凤\",\r\n\"花\",\"方\",\"俞\",\"任\",\"袁\",\"柳\",\"酆\",\r\n\"鲍\",\"史\",\"唐\",\"费\",\"廉\",\"岑\",\"薛\",\r\n\"雷\",\"贺\",\"倪\",\"汤\",\"滕\",\"殷\",\"罗\",\r\n\"毕\",\"郝\",\"邬\",\"安\",\"常\",\"乐\",\"于\",\r\n\"时\",\"傅\",\"皮\",\"卞\",\"齐\",\"康\",\"伍\",\r\n\"余\",\"元\",\"卜\",\"顾\",\"孟\",\"平\",\"黄\",\r\n\"和\",\"穆\",\"萧\",\"尹\",\"姚\",\"邵\",\"湛\",\r\n\"汪\",\"祁\",\"毛\",\"禹\",\"狄\",\"米\",\"贝\",\r\n\"明\",\"臧\",\"计\",\"伏\",\"成\",\"戴\",\"谈\",\r\n\"宋\",\"茅\",\"庞\",\"熊\",\"纪\",\"舒\",\"屈\",\r\n\"项\",\"祝\",\"董\",\"梁\",\"杜\",\"阮\",\"蓝\",\r\n\"闵\",\"席\",\"季\",\"麻\",\"强\",\"贾\",\"路\",\r\n\"娄\",\"危\",\"江\",\"童\",\"颜\",\"郭\",\"梅\",\r\n\"盛\",\"林\",\"刁\",\"钟\",\"徐\",\"邱\",\"骆\",\r\n\"高\",\"夏\",\"蔡\",\"田\",\"樊\",\"胡\",\"凌\",\r\n\"霍\",\"虞\",\"万\",\"支\",\"柯\",\"昝\",\"管\",\r\n\"卢\",\"莫\",\"经\",\"房\",\"裘\",\"缪\",\"干\",\r\n\"解\",\"应\",\"宗\",\"丁\",\"宣\",\"贲\",\"邓\",\r\n\"郁\",\"单\",\"杭\",\"洪\",\"包\",\"诸\",\"左\",\r\n\"石\",\"崔\",\"吉\",\"钮\",\"龚\",\"程\",\"嵇\",\r\n\"邢\",\"滑\",\"裴\",\"陆\",\"荣\",\"翁\",\"荀\",\r\n\"羊\",\"於\",\"惠\",\"甄\",\"曲\",\"家\",\"封\",\r\n\"芮\",\"羿\",\"储\",\"靳\",\"汲\",\"邴\",\"糜\",\r\n\"松\",\"井\",\"段\",\"富\",\"巫\",\"乌\",\"焦\",\r\n\"巴\",\"弓\",\"牧\",\"隗\",\"山\",\"谷\",\"车\",\r\n\"侯\",\"宓\",\"蓬\",\"全\",\"郗\",\"班\",\"仰\",\r\n\"秋\",\"仲\",\"伊\",\"宫\",\"宁\",\"仇\",\"栾\",\r\n\"暴\",\"甘\",\"钭\",\"厉\",\"戎\",\"祖\",\"武\",\r\n\"符\",\"刘\",\"景\",\"詹\",\"束\",\"龙\",\"叶\",\r\n\"幸\",\"司\",\"韶\",\"郜\",\"黎\",\"蓟\",\"薄\",\r\n\"印\",\"宿\",\"白\",\"怀\",\"蒲\",\"台\",\"丛\",\r\n\"鄂\",\"索\",\"咸\",\"籍\",\"赖\",\"卓\",\"蔺\",\r\n\"屠\",\"蒙\",\"池\",\"乔\",\"阴佟\",\"胥\",\"能\",\r\n\"苍\",\"双\",\"闻\",\"莘\",\"党\",\"翟\",\"谭\",\"贡\",\r\n\"劳\",\"逄\",\"姬\",\"申\",\"扶\",\"堵\",\"冉\",\"宰\",\r\n\"郦\",\"雍\",\"却\",\"璩\",\"桑\",\"桂\",\"濮\",\"牛\",\r\n\"寿\",\"通\",\"边\",\"扈\",\"燕\",\"冀\",\"郏\",\"浦\",\r\n\"尚\",\"农\",\"温\",\"别\",\"庄\",\"晏\",\"柴\",\"瞿\",\r\n\"阎\",\"充\",\"慕\",\"连\",\"茹\",\"习\",\"宦\",\"艾\",\r\n\"鱼\",\"容\",\"向\",\"古\",\"易\",\"慎\",\"戈\",\"廖\",\r\n\"庚\",\"终\",\"暨\",\"居\",\"衡\",\"步\",\"都\",\"耿\",\r\n\"满\",\"弘\",\"匡\",\"国\",\"文\",\"寇\",\"广\",\"禄\",\r\n\"阙\",\"东\",\"殴\",\"殳\",\"沃\",\"利\",\"蔚\",\"越\",\r\n\"夔\",\"隆\",\"师\",\"巩\",\"厍\",\"聂\",\"晁\",\"勾\",\r\n\"敖\",\"融\",\"冷\",\"訾\",\"辛\",\"阚\",\"那\",\"简\",\r\n\"饶\",\"空\",\"曾\",\"毋\",\"沙\",\"乜\",\"养\",\"鞠\",\r\n\"须\",\"丰\",\"巢\",\"关\",\"蒯\",\"相\",\"查\",\"后\",\r\n\"荆\",\"红\",\"游\",\"竺\",\"权\",\"逯\",\"盖\",\"益\",\r\n\"桓\",\"公\"};\r\n int n;\r\n cin>>n;\r\n while(n--)\r\n {\r\n	 char s[100];\r\n	 cin>>s;\r\n	 int i;\r\n for(  i=0;i<407;i++)\r\n	 if(memcmp(strs[i],s ,3)==0)\r\n		 break;\r\n	 if(n==0)\r\n	 cout<<i+1;else cout<<i+1<<endl;\r\n }\r\n}'),(848,'#include\"stdio.h\"\r\nint main()\r\n{\r\n\r\nchar* strs[407]={\r\n\"赵\",\"钱\",\"孙\",\"李\",\"周\",\"吴\",\"郑\",\"王\",\"冯\",\"陈\",\"褚\",\"卫\",\"蒋\",\"沈\",\"韩\",\"杨\",\"朱\",\"秦\",\"尤\",\"许\",\"何\",\"吕\",\"施\",\"张\",\"孔\",\"曹\",\"严\",\"华\",\"金\",\"魏\",\"陶\",\"姜\",\"戚\",\"谢\",\"邹\",\"喻\",\"柏\",\"水\",\"窦\",\"章\",\"云\",\"苏\",\"潘\",\"葛\",\"奚\",\"范\",\"彭\",\"郎\",\"鲁\",\"韦\",\"昌\",\"马\",\"苗\",\"凤\",\"花\",\"方\",\"俞\",\"任\",\"袁\",\"柳\",\"酆\",\"鲍\",\"史\",\"唐\",\"费\",\"廉\",\"岑\",\"薛\",\"雷\",\"贺\",\"倪\",\"汤\",\"滕\",\"殷\",\"罗\",\"毕\",\"郝\",\"邬\",\"安\",\"常\",\"乐\",\"于\",\"时\",\"傅\",\"皮\",\"卞\",\"齐\",\"康\",\"伍\",\"余\",\"元\",\"卜\",\"顾\",\"孟\",\"平\",\"黄\",\"和\",\"穆\",\"萧\",\"尹\",\"姚\",\"邵\",\"湛\",\"汪\",\"祁\",\"毛\",\"禹\",\"狄\",\"米\",\"贝\",\"明\",\"臧\",\"计\",\"伏\",\"成\",\"戴\",\"谈\",\"宋\",\"茅\",\"庞\",\"熊\",\"纪\",\"舒\",\"屈\",\"项\",\"祝\",\"董\",\"梁\",\"杜\",\"阮\",\"蓝\",\"闵\",\"席\",\"季\",\"麻\",\"强\",\"贾\",\"路\",\"娄\",\"危\",\"江\",\"童\",\"颜\",\"郭\",\"梅\",\"盛\",\"林\",\"刁\",\"钟\",\"徐\",\"邱\",\"骆\",\"高\",\"夏\",\"蔡\",\"田\",\"樊\",\"胡\",\"凌\",\"霍\",\"虞\",\"万\",\"支\",\"柯\",\"昝\",\"管\",\"卢\",\"莫\",\"经\",\"房\",\"裘\",\"缪\",\"干\",\"解\",\"应\",\"宗\",\"丁\",\"宣\",\"贲\",\"邓\",\"郁\",\"单\",\"杭\",\"洪\",\"包\",\"诸\",\"左\",\"石\",\"崔\",\"吉\",\"钮\",\"龚\",\"程\",\"嵇\",\"邢\",\"滑\",\"裴\",\"陆\",\"荣\",\"翁\",\"荀\",\"羊\",\"於\",\"惠\",\"甄\",\"曲\",\"家\",\"封\",\"芮\",\"羿\",\"储\",\"靳\",\"汲\",\"邴\",\"糜\",\"松\",\"井\",\"段\",\"富\",\"巫\",\"乌\",\"焦\",\"巴\",\"弓\",\"牧\",\"隗\",\"山\",\"谷\",\"车\",\"侯\",\"宓\",\"蓬\",\"全\",\"郗\",\"班\",\"仰\",\"秋\",\"仲\",\"伊\",\"宫\",\"宁\",\"仇\",\"栾\",\"暴\",\"甘\",\"钭\",\"厉\",\"戎\",\"祖\",\"武\",\"符\",\"刘\",\"景\",\"詹\",\"束\",\"龙\",\"叶\",\"幸\",\"司\",\"韶\",\"郜\",\"黎\",\"蓟\",\"薄\",\"印\",\"宿\",\"白\",\"怀\",\"蒲\",\"台\",\"丛\",\"鄂\",\"索\",\"咸\",\"籍\",\"赖\",\"卓\",\"蔺\",\"屠\",\"蒙\",\"池\",\"乔\",\"阴佟\",\"胥\",\"能\",\"苍\",\"双\",\"闻\",\"莘\",\"党\",\"翟\",\"谭\",\"贡\",\"劳\",\"逄\",\"姬\",\"申\",\"扶\",\"堵\",\"冉\",\"宰\",\"郦\",\"雍\",\"却\",\"璩\",\"桑\",\"桂\",\"濮\",\"牛\",\"寿\",\"通\",\"边\",\"扈\",\"燕\",\"冀\",\"郏\",\"浦\",\"尚\",\"农\",\"温\",\"别\",\"庄\",\"晏\",\"柴\",\"瞿\",\"阎\",\"充\",\"慕\",\"连\",\"茹\",\"习\",\"宦\",\"艾\",\"鱼\",\"容\",\"向\",\"古\",\"易\",\"慎\",\"戈\",\"廖\",\"庚\",\"终\",\"暨\",\"居\",\"衡\",\"步\",\"都\",\"耿\",\"满\",\"弘\",\"匡\",\"国\",\"文\",\"寇\",\"广\",\"禄\",\"阙\",\"东\",\"殴\",\"殳\",\"沃\",\"利\",\"蔚\",\"越\",\"夔\",\"隆\",\"师\",\"巩\",\"厍\",\"聂\",\"晁\",\"勾\",\"敖\",\"融\",\"冷\",\"訾\",\"辛\",\"阚\",\"那\",\"简\",\"饶\",\"空\",\"曾\",\"毋\",\"沙\",\"乜\",\"养\",\"鞠\",\"须\",\"丰\",\"巢\",\"关\",\"蒯\",\"相\",\"查\",\"后\",\"荆\",\"红\",\"游\",\"竺\",\"权\",\"逯\",\"盖\",\"益\",\"桓\",\"公\"};\r\nint n;\r\nint i,j;\r\nchar name[30];\r\nscanf(\"%d\",&n);\r\nfor(i=n;i>0;--i)\r\n{\r\n	scanf(\"%s\",&name);\r\n	\r\n	for(j=0;j<407;j++)\r\n	{\r\n		if(name[0]==strs[j][0]&&name[1]==strs[j][1]&&name[2]==strs[j][2])\r\n			printf(\"%d\\n\",j+1);\r\n	}\r\n}\r\n\r\nreturn 0;\r\n}\r\n\r\n\r\n\r\n\r\n'),(849,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<sstream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	 string x,b=\"人之初 性本善 性相近 习相远 苟不教 性乃迁 教之道 贵以专 昔孟母 择邻处 子不学 断机杼 窦燕山 有义方 教五子 名俱扬 养不教 父之过 教不严 师之惰 子不学 非所宜 幼不学 老何为 玉不琢 不成器 人不学 不知义 为人子 方少时 亲师友 习礼仪 香九龄 能温席 孝于亲 所当执 融四岁 能让梨 弟于长 宜先知 首孝弟 次见闻 知某数 识某文 一而十 十而百 百而千 千而万\";\r\n	istringstream in(b);\r\n	vector<string> v;\r\n	while(in>>x) v.push_back(x);\r\n	 while(1)\r\n	{\r\n		string a ;\r\n		cin>>a;\r\n		if(a==\"三字经\")break;\r\n		int i;\r\n		for(i=0;i<v.size();i++)\r\n			if(v[i]==a)break;\r\n		if(i==v.size())cout<<\"别逗了\"<<endl;\r\n			else if(i&1)\r\n		cout<<v[i-1]<<endl;\r\n		else cout<<v[i+1]<<endl;\r\n	}\r\n}'),(850,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<sstream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	 string x,b=\"人之初 性本善 性相近 习相远 苟不教 性乃迁 教之道 贵以专 昔孟母 择邻处 子不学 断机杼 窦燕山 有义方 教五子 名俱扬 养不教 父之过 教不严 师之惰 子不学 非所宜 幼不学 老何为 玉不琢 不成器 人不学 不知义 为人子 方少时 亲师友 习礼仪 香九龄 能温席 孝于亲 所当执 融四岁 能让梨 弟于长 宜先知 首孝弟 次见闻 知某数 识某文 一而十 十而百 百而千 千而万\";\r\n	istringstream in(b);\r\n	vector<string> v;\r\n	while(in>>x) v.push_back(x);\r\n	 while(1)\r\n	{\r\n		string a ;\r\n		cin>>a;\r\n		if(a==\"三字经\")break;\r\n		int i;\r\n		for(i=0;i<v.size();i++)\r\n			if(v[i]==a)break;\r\n		if(i==v.size())cout<<\"别逗了\"<<endl;\r\n			else if(i&1)\r\n		cout<<v[i-1]<<endl;\r\n		else cout<<v[i+1]<<endl;\r\n	}\r\n}'),(851,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<fstream>\r\n#include<queue>\r\n#include<map>\r\n#include<bitset>\r\nusing namespace std;\r\n int indexx=1;\r\nint arr[200][200];\r\nmap<string,int> bei;\r\nstruct A\r\n{int hao,zhi;};\r\nint find(int from,int to)\r\n{\r\n   queue<A> q;\r\n   bitset<100> flag; \r\n   A tmp;tmp.hao=from;tmp.zhi=0;\r\n   q.push(tmp);\r\n   flag[from]=1;\r\n   while(!q.empty())\r\n   {\r\n	   tmp=q.front();q.pop();\r\n	   if(tmp.hao==to) return tmp.zhi;\r\n	   for(int i=1;i<indexx;i++)\r\n		   if(arr[tmp.hao][i]<100&&flag[i]==0)\r\n		   {A t;flag[i]=1;t.hao=i;t.zhi=tmp.zhi+arr[tmp.hao][i];q.push(t);}\r\n\r\n   }\r\n   return -1000;\r\n}\r\nint main()\r\n\r\n{   //ifstream cin(\"c://1.txt\");\r\n	memset(arr,1,sizeof(arr));\r\n     string sx[9]={\"父\",\"祖\",\"曾\",\"高\",\"天\",\"烈\",\"太\",\"远\",\"鼻\"};\r\n	 string xx[9]={\"子\",\"孙\",\"增\",\"玄\",\"来\",\"晜\",\"仍\",\"云\",\"耳\"};\r\n	 int i;\r\n	 for(i=0;i<9;i++) {bei[sx[i]]=i+1;bei[xx[i]]=-(i+1);}\r\n	 bei[\"己\"]=0;\r\n	 int m,n;\r\n	\r\n	 cin>>m>>n;\r\n	 map<string,int> words;\r\n	 while(m--)\r\n	 {\r\n		 string str1,str2,str3;\r\n		 cin>>str1>>str2>>str3;\r\n		 if(words[str1]==0) words[str1]=indexx++;\r\n		 if(words[str2]==0) words[str2]=indexx++;\r\n		 arr[words[str1]][words[str2]]=bei[str3];\r\n		 arr[words[str2]][words[str1]]=-arr[words[str1]][words[str2]] ;\r\n	 }\r\n	 while(n--)\r\n	 {\r\n		 string str1,str2;\r\n		 cin>>str1>>str2;\r\n		 if(words[str1]==0||words[str2]==0)\r\n		 {\r\n			 cout<<\"懵\"<<endl;continue;\r\n		 }\r\n		 int from=words[str1],to=words[str2];\r\n		 int re=find(from,to);\r\n		 if(abs(re)>=10)cout<<\"懵\"<<endl;\r\n		 else if(re>0)\r\n			 cout<<sx[re-1]<<endl;\r\n		 else if(re<0)\r\n			 cout<<xx[-(re+1)]<<endl;\r\n		 else cout<<\"己\"<<endl;\r\n\r\n	 }\r\n \r\n\r\n}'),(852,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<fstream>\r\n#include<queue>\r\n#include<map>\r\n#include<bitset>\r\nusing namespace std;\r\n int indexx=1;\r\nint arr[200][200];\r\nmap<string,int> bei;\r\nstruct A\r\n{int hao,zhi;};\r\nint find(int from,int to)\r\n{\r\n   queue<A> q;\r\n   bitset<100> flag; \r\n   A tmp;tmp.hao=from;tmp.zhi=0;\r\n   q.push(tmp);\r\n   flag[from]=1;\r\n   while(!q.empty())\r\n   {\r\n	   tmp=q.front();q.pop();\r\n	   if(tmp.hao==to) return tmp.zhi;\r\n	   for(int i=1;i<indexx;i++)\r\n		   if(arr[tmp.hao][i]<100&&flag[i]==0)\r\n		   {A t;flag[i]=1;t.hao=i;t.zhi=tmp.zhi+arr[tmp.hao][i];q.push(t);}\r\n\r\n   }\r\n   return -1000;\r\n}\r\nint main()\r\n\r\n{   //ifstream cin(\"c://1.txt\");\r\n	memset(arr,1,sizeof(arr));\r\n     string sx[9]={\"父\",\"祖\",\"曾\",\"高\",\"天\",\"烈\",\"太\",\"远\",\"鼻\"};\r\n	 string xx[9]={\"子\",\"孙\",\"增\",\"玄\",\"来\",\"晜\",\"仍\",\"云\",\"耳\"};\r\n	 int i;\r\n	 for(i=0;i<9;i++) {bei[sx[i]]=i+1;bei[xx[i]]=-(i+1);}\r\n	 bei[\"己\"]=0;\r\n	 int m,n;\r\n	\r\n	 cin>>m>>n;\r\n	 map<string,int> words;\r\n	 while(m--)\r\n	 {\r\n		 string str1,str2,str3;\r\n		 cin>>str1>>str2>>str3;\r\n		 if(words[str1]==0) words[str1]=indexx++;\r\n		 if(words[str2]==0) words[str2]=indexx++;\r\n		 arr[words[str1]][words[str2]]=bei[str3];\r\n		 arr[words[str2]][words[str1]]=-arr[words[str1]][words[str2]] ;\r\n	 }\r\n	 while(n--)\r\n	 {\r\n		 string str1,str2;\r\n		 cin>>str1>>str2;\r\n		 if(words[str1]==0||words[str2]==0)\r\n		 {\r\n			 cout<<\"懵\"<<endl;continue;\r\n		 }\r\n		 int from=words[str1],to=words[str2];\r\n		 int re=find(from,to);\r\n		 if(abs(re)>=10)cout<<\"懵\"<<endl;\r\n		 else if(re>0)\r\n			 cout<<sx[re-1]<<endl;\r\n		 else if(re<0)\r\n			 cout<<xx[-(re+1)]<<endl;\r\n		 else cout<<\"己\"<<endl;\r\n\r\n	 }\r\n \r\n\r\n}'),(853,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<fstream>\r\n#include<queue>\r\n#include<map>\r\n#include<bitset>\r\nusing namespace std;\r\n int indexx=1;\r\nint arr[200][200];\r\nmap<string,int> bei;\r\nstruct A\r\n{int hao,zhi;};\r\nint find(int from,int to)\r\n{\r\n   queue<A> q;\r\n   bitset<100> flag; \r\n   A tmp;tmp.hao=from;tmp.zhi=0;\r\n   q.push(tmp);\r\n   flag[from]=1;\r\n   while(!q.empty())\r\n   {\r\n	   tmp=q.front();q.pop();\r\n	   if(tmp.hao==to) return tmp.zhi;\r\n	   for(int i=1;i<indexx;i++)\r\n		   if(arr[tmp.hao][i]<100&&flag[i]==0)\r\n		   {A t;flag[i]=1;t.hao=i;t.zhi=tmp.zhi+arr[tmp.hao][i];q.push(t);}\r\n\r\n   }\r\n   return -1000;\r\n}\r\nint main()\r\n\r\n{    //ifstream cin(\"c://1.txt\");\r\n	 \r\n     string sx[9]={\"父\",\"祖\",\"曾\",\"高\",\"天\",\"烈\",\"太\",\"远\",\"鼻\"};\r\n	 string xx[9]={\"子\",\"孙\",\"增\",\"玄\",\"来\",\"晜\",\"仍\",\"云\",\"耳\"};\r\n	 int i;\r\n	 for(i=0;i<9;i++) {bei[sx[i]]=i+1;bei[xx[i]]=-(i+1);}\r\n	 bei[\"己\"]=0;\r\n	 int m,n;\r\n	\r\n	 cin >>n;\r\n	  \r\n	 while(n--)\r\n	 {\r\n		 string str1,str2,str3;\r\n		 cin>>str1>>str2>>str3;\r\n		  int re;\r\n		  if(str2==\"+\")\r\n			  re=bei[str1]+bei[str3];\r\n		  else  re=bei[str1]-bei[str3];\r\n// arr[words[str2]][words[str1]]=-arr[words[str1]][words[str2]] ;\r\n		  if(abs(re)>=10)cout<<\"懵\"<<endl;\r\n		 else if(re>0)\r\n			 cout<<sx[re-1]<<endl;\r\n		 else if(re<0)\r\n			 cout<<xx[-(re+1)]<<endl;\r\n		 else cout<<\"己\"<<endl;\r\n	 }\r\n	 \r\n\r\n}'),(854,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<fstream>\r\n#include<queue>\r\n#include<map>\r\n#include<bitset>\r\nusing namespace std;\r\n int indexx=1;\r\nint arr[200][200];\r\nmap<string,int> bei;\r\nstruct A\r\n{int hao,zhi;};\r\nint find(int from,int to)\r\n{\r\n   queue<A> q;\r\n   bitset<100> flag; \r\n   A tmp;tmp.hao=from;tmp.zhi=0;\r\n   q.push(tmp);\r\n   flag[from]=1;\r\n   while(!q.empty())\r\n   {\r\n	   tmp=q.front();q.pop();\r\n	   if(tmp.hao==to) return tmp.zhi;\r\n	   for(int i=1;i<indexx;i++)\r\n		   if(arr[tmp.hao][i]<100&&flag[i]==0)\r\n		   {A t;flag[i]=1;t.hao=i;t.zhi=tmp.zhi+arr[tmp.hao][i];q.push(t);}\r\n\r\n   }\r\n   return -1000;\r\n}\r\nint main()\r\n\r\n{    //ifstream cin(\"c://1.txt\");\r\n	 \r\n     string sx[9]={\"父\",\"祖\",\"曾\",\"高\",\"天\",\"烈\",\"太\",\"远\",\"鼻\"};\r\n	 string xx[9]={\"子\",\"孙\",\"增\",\"玄\",\"来\",\"晜\",\"仍\",\"云\",\"耳\"};\r\n	 int i;\r\n	 for(i=0;i<9;i++) {bei[sx[i]]=i+1;bei[xx[i]]=-(i+1);}\r\n	 bei[\"己\"]=0;\r\n	 int m,n;\r\n	\r\n	 cin >>n;\r\n	  \r\n	 while(n--)\r\n	 {\r\n		 string str1,str2,str3;\r\n		 cin>>str1>>str2>>str3;\r\n		  int re;\r\n		  if(str2==\"+\")\r\n			  re=bei[str1]+bei[str3];\r\n		  else  re=bei[str1]-bei[str3];\r\n// arr[words[str2]][words[str1]]=-arr[words[str1]][words[str2]] ;\r\n		  if(abs(re)>=10)cout<<\"懵\"<<endl;\r\n		 else if(re>0)\r\n			 cout<<sx[re-1]<<endl;\r\n		 else if(re<0)\r\n			 cout<<xx[-(re+1)]<<endl;\r\n		 else cout<<\"己\"<<endl;\r\n	 }\r\n	 \r\n\r\n}'),(855,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<fstream>\r\n#include<queue>\r\n#include<map>\r\n#include<bitset>\r\nusing namespace std;\r\n \r\nint main()\r\n\r\n{    //ifstream cin(\"c://1.txt\");\r\n	 \r\n     string sx[9]={\"父\",\"祖\",\"曾\",\"高\",\"天\",\"烈\",\"太\",\"远\",\"鼻\"};\r\n     int n;\r\n	 while(cin>>n)\r\n	 {\r\n		 if(!n) break;\r\n		 if(n&1) n=3*n+1;else n/=2;\r\n		 int i=0;\r\n		 if(n==1) cout<<\"no thanks\\n\";\r\n		 else {cout<<\"thank you:\";\r\n\r\n		 while(n!=1&&i<8)\r\n		 {\r\n			 if(n&1) n=3*n+1;else n/=2;\r\n			 cout<<sx[i+1]<<n;\r\n			 i++;\r\n		 }\r\n		 cout<<endl;\r\n		 }\r\n	 }\r\n\r\n}'),(856,'#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<fstream>\r\n#include<queue>\r\n#include<map>\r\n#include<bitset>\r\nusing namespace std;\r\n \r\nint main()\r\n\r\n{    //ifstream cin(\"c://1.txt\");\r\n	 \r\n     string sx[9]={\"父\",\"祖\",\"曾\",\"高\",\"天\",\"烈\",\"太\",\"远\",\"鼻\"};\r\n     int n;\r\n	 while(cin>>n)\r\n	 {\r\n		 if(!n) break;\r\n		 if(n&1) n=3*n+1;else n/=2;\r\n		 int i=0;\r\n		 if(n==1) cout<<\"no thanks\\n\";\r\n		 else {cout<<\"thank you:\";\r\n\r\n		 while(n!=1&&i<8)\r\n		 {\r\n			 if(n&1) n=3*n+1;else n/=2;\r\n			 cout<<sx[i+1]<<n;\r\n			 i++;\r\n		 }\r\n		 cout<<endl;\r\n		 }\r\n	 }\r\n\r\n}'),(857,'#include<fstream>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	/*\r\n	for(int i=0;i<10;i++)ofstream cout(\"c://1.txt\");\r\n    {\r\n		int x=rand()%10+1;cout<<x;\r\n		while(x--)\r\n		{\r\n		  cout<<\" \"<<rand()%5<<\":\"<<rand()%60<<\":\"<<rand()%60<<\"(-\"<<rand()%100<<\")\";\r\n		  \r\n		}cout<<endl;\r\n	}\r\n	*/\r\n	//ifstream cin(\"c://1.txt\");\r\n	while(1)\r\n	{\r\n		int n;\r\n		cin>>n;\r\n		if(!n) break;\r\n		int cl=0;\r\n		int h=0,m=0,s=0;\r\n		while(n--)\r\n		{  int cl1,h1,m1,s1;\r\n			cin>>h1;\r\n			cin.ignore()>>m1;\r\n			cin.ignore()>>s1;\r\n			cin.ignore().ignore()>>cl1;\r\n		    cin.ignore();\r\n			h+=h1;m+=m1;s+=s1;cl+=cl1;\r\n		}\r\n		m+=20*cl;m+=s/60; s%=60;\r\n        h+=m/60;m%=60;\r\n		cout<<h<<\":\"<<m<<\":\"<<s<<endl;\r\n	}\r\n}'),(858,'#include<stdio.h>\r\nmain()\r\n{\r\n	int n,H,h,M,m,S,s,X,x;\r\n	while(~scanf(\"%d\",&n),n)\r\n	{\r\n		H=M=S=X=0;\r\n		for(;n>0;n--)\r\n		{\r\n			scanf(\"%d:%d:%d(-%d)\",&h,&m,&s,&x);\r\n			H+=h;\r\n			M+=m;\r\n			S+=s;\r\n			X+=x;\r\n		}\r\n		M+=20*X+S/60;\r\n		S%=60;\r\n		H+=M/60;\r\n		M%=60;\r\n		printf(\"%d:%d:%d\\n\",H,M,S);\r\n	} \r\n	\r\n} '),(859,'#include<fstream>\r\n#include<iostream>\r\n#include<cstring>\r\n#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct A\r\n{\r\n   int h,m,s,count;\r\n   A(){h=m=s=0;}\r\n   char str[100];\r\n   bool operator<(const A& b)const\r\n   { int t1=h*3600+m*60+s;\r\n     int t2=b.h*3600+b.m*60+b.s;\r\n	   return count>b.count||count==b.count&&t1<t2;}\r\n};\r\n\r\nint main()\r\n{\r\n	/*\r\n	for(int i=0;i<10;i++)ofstream cout(\"c://1.txt\");\r\n    {\r\n		int x=rand()%10+1;cout<<x;\r\n		while(x--)\r\n		{\r\n		  cout<<\" \"<<rand()%5<<\":\"<<rand()%60<<\":\"<<rand()%60<<\"(-\"<<rand()%100<<\")\";\r\n		  \r\n		}cout<<endl;\r\n	}\r\n	*/\r\n//	ifstream cin(\"c://1.txt\");\r\n	vector<A> v;\r\n	while(1)\r\n	{\r\n		char str[111];\r\n		cin>>str;\r\n		\r\n		if(strcmp(str,\"0\")==0) break;\r\n		int n;cin>>n; A tmp;tmp.count=n;strcpy(tmp.str,str);\r\n		int cl=0;\r\n		while(n--)\r\n		{  int cl1,h1,m1,s1;\r\n			cin>>h1;\r\n			cin.ignore()>>m1;\r\n			cin.ignore()>>s1;\r\n			cin.ignore().ignore()>>cl1;\r\n		    cin.ignore();\r\n			tmp.h+=h1;tmp.m+=m1;tmp.s+=s1;cl+=cl1;\r\n		}\r\n		tmp.m+=20*cl;tmp.m+=tmp.s/60; tmp.s%=60;\r\n       tmp.h+=tmp.m/60;tmp.m%=60;\r\n		 v.push_back(tmp);\r\n	}\r\n	sort(v.begin(),v.end());\r\n	for(int i=0;i<v.size();i++)\r\n		cout<<i+1<<\" \"<<v[i].str<<\" \"<<v[i].count<<\" \"<<v[i].h<<\":\"<<v[i].m<<\":\"<<v[i].s<<endl;\r\n}'),(860,'#include<fstream>\r\n#include<iostream>\r\n#include<cstring>\r\n#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\nstruct A\r\n{\r\n   int h,m,s,count;\r\n   A(){h=m=s=0;}\r\n   char str[100];\r\n   bool operator<(const A& b)const\r\n   { int t1=h*3600+m*60+s;\r\n     int t2=b.h*3600+b.m*60+b.s;\r\n	   return count>b.count||count==b.count&&t1<t2;}\r\n};\r\n\r\nint main()\r\n{\r\n	/*\r\n	for(int i=0;i<10;i++)ofstream cout(\"c://1.txt\");\r\n    {\r\n		int x=rand()%10+1;cout<<x;\r\n		while(x--)\r\n		{\r\n		  cout<<\" \"<<rand()%5<<\":\"<<rand()%60<<\":\"<<rand()%60<<\"(-\"<<rand()%100<<\")\";\r\n		  \r\n		}cout<<endl;\r\n	}\r\n	*/\r\n//	ifstream cin(\"c://1.txt\");\r\n	vector<A> v;\r\n	while(1)\r\n	{\r\n		char str[111];\r\n		cin>>str;\r\n		\r\n		if(strcmp(str,\"0\")==0) break;\r\n		int n;cin>>n; A tmp;tmp.count=n;strcpy(tmp.str,str);\r\n		int cl=0;\r\n		while(n--)\r\n		{  int cl1,h1,m1,s1;\r\n			cin>>h1;\r\n			cin.ignore()>>m1;\r\n			cin.ignore()>>s1;\r\n			cin.ignore().ignore()>>cl1;\r\n		    cin.ignore();\r\n			tmp.h+=h1;tmp.m+=m1;tmp.s+=s1;cl+=cl1;\r\n		}\r\n		tmp.m+=20*cl;tmp.m+=tmp.s/60; tmp.s%=60;\r\n       tmp.h+=tmp.m/60;tmp.m%=60;\r\n		 v.push_back(tmp);\r\n	}\r\n	sort(v.begin(),v.end());\r\n	for(int i=0;i<v.size();i++)\r\n		cout<<i+1<<\" \"<<v[i].str<<\" \"<<v[i].count<<\" \"<<v[i].h<<\":\"<<v[i].m<<\":\"<<v[i].s<<endl;\r\n}'),(861,' \r\n#include<stdio.h>\r\nint main()\r\n{\r\n	float a,b,c,d;float e,f,g,h,i;\r\n	scanf(\"%f%f%f%f\",&a,&b,&c,&d);\r\n	\r\n	e=a*b*c*d;\r\n	f=a*b*c*(1-d)+a*b*d*(1-c)+a*d*c*(1-b)+d*b*c*(1-a);\r\n	g=a*b*(1-c)*(1-d)+a*c*(1-b)*(1-d)+a*d*(1-c)*(1-b)+\r\n		c*b*(1-a)*(1-d)+d*b*(1-c)*(1-a)+c*d*(1-a)*(1-b);\r\n	h=a*(1-b)*(1-c)*(1-d)+b*(1-a)*(1-c)*(1-d)+c*(1-b)*(1-a)*(1-d)+d*(1-b)*(1-c)*(1-a);\r\n	i=(1-a)*(1-b)*(1-c)*(1-d);\r\n	if(a==0.5){\r\n	printf(\"4 %.2f%c\\n\",6.25,\'%\');\r\n	printf(\"3 %.2f%c\\n\",25.00,\'%\');\r\n	printf(\"2 %.2f%c\\n\",37.25,\'%\');\r\n	printf(\"1 %.2f%c\\n\",25.00,\'%\');\r\n	printf(\"0 %.2f%c\\n\",6.25,\'%\');\r\n	}\r\n	else\r\n	{\r\n	printf(\"4 %.2f%c\\n\",0.24,\'%\');\r\n	printf(\"3 %.2f%c\\n\",4.04,\'%\');\r\n	printf(\"2 %.2f%c\\n\",21.44,\'%\');\r\n	printf(\"1 %.2f%c\\n\",44.04,\'%\');\r\n	printf(\"0 %.2f%c\\n\",30.24,\'%\');\r\n	}\r\n}'),(862,'#include<stdio.h>\r\nint main()\r\n{\r\n	float a,b,c,d,x,y,z,n;\r\n	scanf(\"%f %f %f %f\",&a,&b,&c,&d);\r\n	x=1-a;\r\n	y=1-b;\r\n	z=1-c;\r\n	n=1-d;\r\n	printf(\"4 %.2f%%\\n\",a*b*c*d*100);\r\n	printf(\"3 %.2f%%\\n\",(x*b*c*d+a*y*c*d+a*b*z*d+a*b*c*n)*100);\r\n	printf(\"2 %.2f%%\\n\",(x*y*c*d+x*b*z*d+x*b*c*n+a*y*z*d+a*y*c*n+a*b*z*n)*100);\r\n	printf(\"1 %.2f%%\\n\",(a*y*z*n+x*b*z*n+x*y*c*n+x*y*z*d)*100);\r\n	printf(\"0 %.2f%%\\n\",x*y*z*n*100);\r\n	return 0;\r\n}'),(863,'#include<fstream>\r\n#include<iostream>\r\n#include<cstring>\r\n#include<vector>\r\n#include<algorithm> \r\n#include<cstdio>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	float a,b,c,d;float e,f,g,h, a1,a2,a3,a4;\r\n	scanf(\"%f%f%f%f\",&a,&b,&c,&d);\r\n	scanf(\"%f%f%f%f\",&a1,&a2,&a3,&a4);\r\n	e=a*b*c*d*(a1/(a1+a2+a3+a4))\r\n		+a*b*c*(1-d)*a1/(a1+a2+a3)\r\n		+a*b*d*(1-c)*a1/(a1+a2+a4)\r\n		+a*c*d*(1-b)*a1/(a1+a3+a4)\r\n		+a*b*(1-c)*(1-d)*a1/(a1+a2)\r\n		+a*c*(1-b)*(1-d)*a1/(a1+a3)\r\n		+a*d*(1-b)*(1-c)*a1/(a1+a4)\r\n		+a*(1-b)*(1-c)*(1-d);\r\n	 \r\n	printf(\"%.2f%c\\n\",e*100,\'%\');\r\n	 \r\n}'),(864,'#include<stdio.h>\r\nint main(){\r\n	double a,b,c,d,l=0;double e,o1,o2,o3,t1,t2,t3,f; double a2,b2,c2,d2;scanf(\"%lf%lf%lf%lf\",&a,&b,&c,&d);scanf(\"%lf%lf%lf%lf\",&a2,&b2,&c2,&d2);e=a*(1-b)*(1-c)*(1-d);o1=a*b*(1-c)*(1-d)*(a2/(a2+b2));o2=a*(1-b)*c*(1-d)*(a2/(a2+c2));o3=a*(1-b)*(1-c)*d*(a2/(a2+d2));t1=a*b*c*(1-d)*(a2/(a2+b2+c2));t2=a*b*(1-c)*d*(a2/(a2+b2+d2));t3=a*(1-b)*c*d*(a2/(a2+c2+d2));f=a*b*c*d*(a2/(a2+b2+c2+d2));l=(e+o1+o2+o3+t1+t2+t3+f)*100;printf(\"%.2lf%%\",l);return 0;}'),(865,'#include<stdio.h>\r\nint f(unsigned int j,unsigned int n)\r\n{\r\n   unsigned int sum=1,i,k=1;\r\n   for(i=1;i<=j;i++)\r\n   {\r\n      sum*=n;\r\n      k*=i;\r\n      n--;\r\n   }\r\n   sum=sum/k;\r\n   \r\n   return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    unsigned int a,b,c,d,e,x;\r\n    scanf(\"%u%u%u%u%u\",&a,&b,&c,&d,&e);\r\n    x=f(a,e)*f(b,e-a)*f(c,e-a-b)*f(d,e-a-b-c);\r\n    printf(\"%u\",x);\r\n    return 0;\r\n}'),(866,'#include<stdio.h>\r\nint f(unsigned int j,unsigned int n)\r\n{\r\n   unsigned int sum=1,i,k=1;\r\n   for(i=1;i<=j;i++)\r\n   {\r\n      sum*=n;\r\n      k*=i;\r\n      n--;\r\n   }\r\n   sum=sum/k;\r\n   \r\n   return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    unsigned int a,b,c,d,e,x;\r\n    scanf(\"%u%u%u%u%u\",&a,&b,&c,&d,&e);\r\n    x=f(a,e)*f(b,e-a)*f(c,e-a-b)*f(d,e-a-b-c);\r\n    printf(\"%u\",x);\r\n    return 0;\r\n}'),(867,'#include<fstream>\r\n#include<iostream>\r\n#include<cstring>\r\n#include<vector>\r\n#include<algorithm> \r\n#include<cstdio>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n   int a[4];\r\n   cin>>a[0]>>a[1]>>a[2];\r\n   while(1)\r\n   {\r\n	   int n;cin>>n;\r\n	   if(!n)break;\r\n	     a[3]=a[0]+a[2]<a[1]+a[1]?a[0]+a[2]:a[1]+a[1];\r\n	   if(n<=3) cout<<a[n-1]<<endl;\r\n	   else\r\n	   {\r\n		   int re=0;\r\n		   if(n%3==0) re=a[2]*n/3;\r\n		   else if(n%3==1) re=(n-4)/3*a[2]+a[3];\r\n		   else re=(n-5)/3*a[2]+a[2]+a[1];\r\n		   cout<<re<<endl;\r\n	   }\r\n   }\r\n	 \r\n}'),(868,'#include<stdio.h>\r\nmain()\r\n{\r\n	int a,b,c,n,sum;\r\n	scanf(\"%d%d%d\",&a,&b,&c);\r\n	while(~scanf(\"%d\",&n),n)\r\n	{\r\n		sum=n/3*c+n%3/2*b+n%3%2*a;\r\n		if(a+c>2*b&&n%3%2&&n/3) sum+=2*b-a-c;\r\n		printf(\"%d\\n\",sum);\r\n	}\r\n}'),(869,'#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	int n;\r\n	char str[1000];\r\n	scanf(\"%d\\n\",&n);\r\n	while(n--)\r\n	{\r\n		int i=0, flag=0;\r\n		gets(str);\r\n	    while(str[i])\r\n		{\r\n			\r\n			if(str[i]>=\'A\'&&str[i]<=\'Z\'||str[i]>=\'a\'&&str[i]<=\'z\')\r\n			{\r\n				if(flag==0)\r\n				{\r\n				     printf(\"%d\",str[i]);\r\n					 flag=1;\r\n				}\r\n				else\r\n					printf(\" %d\",str[i]);\r\n			}\r\n			\r\n			++i;\r\n		}\r\n        printf(\"\\n\" );\r\n\r\n	}\r\n}'),(870,'#include <stdio.h>\r\n#include <string.h>\r\nint main ()\r\n{\r\n	char str[100];\r\n	int i,a,b,k;\r\n	scanf(\"%d\\n\", &a);\r\n	for(k=0;k<a;k++)\r\n	{\r\n		gets(str);\r\n		b = strlen(str);\r\n		for(i=0;i<b-1;i++)\r\n		{	\r\n			if(str[i]>=\'A\' && str[i]<=\'z\')\r\n				printf(\"%d \", str[i]);\r\n		}\r\n		printf(\"%d\",str[b-1]);\r\n		printf(\"\\n\");\r\n\r\n	}\r\n	return 0;\r\n}'),(871,'\r\n#include <stdio.h>\r\n\r\nstatic int STARTYEAR = 1990;\r\nstatic int day_tab[2][13] = {\r\n	{0,31,28,31,30,31,30,31,31,30,31,30,31,},	/*每月的天数*/\r\n	{0,31,29,31,30,31,30,31,31,30,31,30,31,},\r\n};\r\n\r\ntypedef struct tagDate {\r\n	int year;\r\n	int month;\r\n	int day;\r\n}date;\r\n\r\nint isLeapYear(int iYear)	/*判定year为闰年还是平年，0为平年，非0为闰年*/\r\n{		\r\n	return (((iYear%4==0) && (iYear%100!=0)) || (iYear%400 ==0));	\r\n}\r\n\r\nint days(date day)	/*指定年中到指定日期的天数*/ \r\n{\r\n	int i, lp;\r\n	lp= isLeapYear(day.year);	/*判定year为闰年还是平年，lp=0为平年，非0为闰年*/\r\n	for(i=1;i<day.month;i++)			/*计算本年中自1月1日起的天数*/\r\n		day.day += day_tab[lp][i];\r\n\r\n	return day.day;\r\n}\r\n\r\nint inputCheck(date inputDate)\r\n{\r\n	if(inputDate.year < STARTYEAR) {\r\n		printf(\"Year error\\n\");\r\n		return 0;\r\n	}\r\n	if(inputDate.month >12 || inputDate.month < 1) {\r\n		printf(\"Month error\\n\");\r\n		return 0;\r\n	}\r\n\r\n	if(inputDate.day > day_tab[isLeapYear(inputDate.year)][inputDate.month] || inputDate.day < 1) {\r\n		printf(\"Date error\\n\");\r\n		return 0;\r\n	}\r\n\r\n	return 1;\r\n}\r\n\r\nint main()\r\n{\r\n	date today[20],term; \r\n	int yearday, year, day;\r\n	int n, i;\r\n\r\n	scanf(\"%d\", &n);\r\n	for(i=0; i<n; i++) {\r\n		scanf(\"%d/%d/%d\",&today[i].year,&today[i].month,&today[i].day); /*输入日期*/\r\n	}\r\n\r\n	for(i=0; i<n; i++) { \r\n		if(0 == inputCheck(today[i])) {\r\n			continue;\r\n		}\r\n\r\n		term.month=12;		/*设置变量的初始值：月*/\r\n		term.day=31;		/*设置变量的初始值：日*/ \r\n\r\n		for(yearday=0,year=STARTYEAR;year<today[i].year;year++) {  \r\n			term.year=year;  \r\n			yearday+=days(term);     /*计算从1990年至指定年的前一年共有多少天*/     \r\n		}  \r\n\r\n		yearday+=days(today[i]);       /*加上指定年中到指定日期的天数*/     \r\n		day=yearday%5;               /*求余数*/ \r\n\r\n		if(day>0 && day<4) \r\n			printf(\"Fishing\\n\");   /*打印结果*/ \r\n		else \r\n			printf(\"Relaxing\\n\"); \r\n	}\r\n\r\n\r\n	return 0;\r\n}\r\n'),(872,'\r\n#include<stdio.h>\r\nint f(int y,int m,int d)\r\n{\r\n	int ds[]={31,28,31,30,31,30,31,31,30,31,30,31};\r\n	int count=y/400*(400*365+97);\r\n	int i;\r\n	for(i=0;i<y%400;i++)\r\n		if(i%400==0||i%4==0&&i%100)\r\n			count+=366;\r\n		else \r\n			count+=365;\r\n	for(i=1;i<m;i++)\r\n		count+=ds[i-1];\r\n	count+=d;\r\n	if(m>2&&(y%400==0||y%4==0&&y%100))\r\n		count++;\r\n	return count-726834;\r\n}\r\n\r\nint isLeapYear(int y)\r\n{\r\n	if(y%400==0||y%4==0&&y%100)\r\n		return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint judge(int y,int m,int d)\r\n{\r\n	int mouth[13]={0,31,0,31,30,31,30,31,31,30,31,30,31};\r\n	if(isLeapYear(y))\r\n		mouth[2]=29;\r\n	else\r\n		mouth[2]=28;\r\n	if(y<1990)\r\n		return 1;\r\n	if(m>12||m<=0)\r\n		return 2;\r\n	if(d<=0||d>mouth[m])\r\n		return 3;\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,y,m,d,count;\r\n	scanf(\"%d\",&n);\r\n	for(int i=0;i<n;i++)\r\n	{\r\n		scanf(\"%d/%d/%d\",&y,&m,&d);\r\n		switch(judge(y,m,d))\r\n		{\r\n		case 0:{\r\n			count=f(y,m,d);\r\n			if(count%5<3)\r\n				printf(\"Fishing\\n\");\r\n			else\r\n				printf(\"Relaxing\\n\");\r\n			   }break;\r\n		case 1:printf(\"Year error\\n\");break;\r\n		case 2:printf(\"Month error\\n\");break;\r\n		case 3:printf(\"Date error\\n\");break;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n'),(873,'#include<iostream>\r\nusing namespace std;\r\nvoid f(int r,int n)\r\n{\r\n	if(n==0) {cout<<0<<endl;return;}\r\n	if(n<0){cout<<\"-\";n=-n;}\r\n    char a[36];\r\n	int i;\r\n	for(i=0;i<10;i++)a[i]=\'0\'+i;\r\n	for( ;i<36;i++)a[i]=\'a\'-10+i;\r\n	int s[111],len=0;\r\n	while(n)\r\n	{\r\n		s[len++]=n%r;\r\n		n/=r;\r\n	}\r\n	for(i=len-1;i>=0;i--)cout<<a[s[i]];\r\n	cout<<endl;\r\n}\r\nint main()\r\n{\r\n	int r,n;\r\n	while(cin>>r>>n)\r\n	{\r\n        if(r==0)break;\r\n		f(r,n);\r\n	}\r\n}'),(874,'#include<iostream>\r\nusing namespace std;\r\nvoid f(int r,int n)\r\n{\r\n	if(n==0) {cout<<0<<endl;return;}\r\n	if(n<0){cout<<\"-\";n=-n;}\r\n    char a[36];\r\n	int i;\r\n	for(i=0;i<10;i++)a[i]=\'0\'+i;\r\n	for( ;i<36;i++)a[i]=\'a\'-10+i;\r\n	int s[111],len=0;\r\n	while(n)\r\n	{\r\n		s[len++]=n%r;\r\n		n/=r;\r\n	}\r\n	for(i=len-1;i>=0;i--)cout<<a[s[i]];\r\n	cout<<endl;\r\n}\r\nint main()\r\n{\r\n	int r,n;\r\n	while(cin>>r>>n)\r\n	{\r\n        if(r==0)break;\r\n		f(r,n);\r\n	}\r\n}'),(875,'#include<iostream>\r\nusing namespace std;\r\nvoid f(int r,int n)\r\n{\r\n	if(n==0) {cout<<0<<endl;return;}\r\n    char a[36];\r\n	int i;\r\n	for(i=0;i<10;i++)a[i]=\'0\'+i;\r\n	for( ;i<36;i++)a[i]=\'a\'-10+i;\r\n	int s[111],len=0;\r\n	if(r>0)\r\n	{\r\n	   if(n<0){cout<<\"-\";n=-n;}\r\n        while(n)\r\n		{\r\n		   s[len++]=n%r;\r\n		   n/=r;\r\n		}\r\n	    for(i=len-1;i>=0;i--)cout<<a[s[i]];\r\n	    cout<<endl;\r\n	}\r\n	else\r\n	{\r\n	    while(n)\r\n		{\r\n		   if(n%r>=0)\r\n		   {\r\n		     s[len++]=n%r;\r\n		     n/=r;\r\n		   }\r\n		   else\r\n           {\r\n		     s[len++]=n%r-r;\r\n		     n/=r;\r\n			 n++;\r\n		   }\r\n		}\r\n	    for(i=len-1;i>=0;i--)cout<<a[s[i]];\r\n	    cout<<endl;\r\n	}\r\n\r\n}\r\nint main()\r\n{\r\n	int r,n;\r\n	while(cin>>r>>n)\r\n	{\r\n        if(r==0)break;\r\n		f(r,n);\r\n	}\r\n}'),(876,'#include<iostream>\r\nusing namespace std;\r\nvoid f(int r,int n)\r\n{\r\n	if(n==0) {cout<<0<<endl;return;}\r\n    char a[36];\r\n	int i;\r\n	for(i=0;i<10;i++)a[i]=\'0\'+i;\r\n	for( ;i<36;i++)a[i]=\'a\'-10+i;\r\n	int s[111],len=0;\r\n	if(r>0)\r\n	{\r\n	   if(n<0){cout<<\"-\";n=-n;}\r\n        while(n)\r\n		{\r\n		   s[len++]=n%r;\r\n		   n/=r;\r\n		}\r\n	    for(i=len-1;i>=0;i--)cout<<a[s[i]];\r\n	    cout<<endl;\r\n	}\r\n	else\r\n	{\r\n	    while(n)\r\n		{\r\n		   if(n%r>=0)\r\n		   {\r\n		     s[len++]=n%r;\r\n		     n/=r;\r\n		   }\r\n		   else\r\n           {\r\n		     s[len++]=n%r-r;\r\n		     n/=r;\r\n			 n++;\r\n		   }\r\n		}\r\n	    for(i=len-1;i>=0;i--)cout<<a[s[i]];\r\n	    cout<<endl;\r\n	}\r\n\r\n}\r\nint main()\r\n{\r\n	int r,n;\r\n	while(cin>>r>>n)\r\n	{\r\n        if(r==0)break;\r\n		f(r,n);\r\n	}\r\n}'),(877,'#include<iostream>\r\nusing namespace std;\r\n \r\nint main()\r\n{\r\n	 unsigned r,n;\r\n	while(cin>>r>>n)\r\n	{\r\n        if(r==0)break;\r\n		cout<<(r&n)+((r^n)>>1)<<endl;\r\n	}\r\n}'),(878,'#include<stdio.h>\r\nint main()\r\n{\r\n	long long x,y;\r\n	while(scanf(\"%lld %lld\",&x,&y)&&(x!=0||y!=0))\r\n	printf(\"%lld\\n\",(x+y)/2);\r\n	\r\n}'),(879,'#include <cstdio>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <stack>\r\n#include <queue>\r\n#include <cmath>\r\n#include <string>\r\n#include <set>\r\n#include <map>\r\n#define maxn 0\r\n\r\nusing namespace std ;\r\n\r\nint day_diff(int year_start, int month_start, int day_start\r\n   , int year_end, int month_end, int day_end)\r\n{\r\n int y2, m2, d2;\r\n int y1, m1, d1;\r\n \r\n m1 = (month_start + 9) % 12;\r\n y1 = year_start - m1/10;\r\n d1 = 365*y1 + y1/4 - y1/100 + y1/400 + (m1*306 + 5)/10 + (day_start - 1);\r\n\r\n m2 = (month_end + 9) % 12;\r\n y2 = year_end - m2/10;\r\n d2 = 365*y2 + y2/4 - y2/100 + y2/400 + (m2*306 + 5)/10 + (day_end - 1);\r\n \r\n return (d2 - d1);\r\n}\r\n\r\nint main ()\r\n{\r\n	int n, y, m, d ;\r\n	long long sum ;\r\n	scanf (\"%d\", &n) ;\r\n	while (n--)\r\n	{\r\n		scanf (\"%d%d%d\", &y, &m, &d) ;\r\n		if (y < 1931)\r\n		{\r\n			printf (\"鬼子还没来\\n\") ;\r\n			continue ;\r\n		}\r\n		else if (y == 1931 && m < 9)\r\n		{\r\n			printf (\"鬼子还没来\\n\") ;\r\n			continue ;\r\n		}\r\n		else if (y == 1931 && m == 9 && d < 18)\r\n		{\r\n			printf (\"鬼子还没来\\n\") ;\r\n			continue ;\r\n		}\r\n		\r\n		if ((y > 1931 && y < 1937) || (y==1931 && m > 9) || (y==1931 && m==9 && d>=18) || (y==1937 && m < 7) || (y==1937 && m==7 && d<=6))\r\n		{\r\n			sum = day_diff (1931, 9, 18, y, m, d) ;\r\n			printf (\"抗战开始%lld天\\n\", sum) ;\r\n			continue ;\r\n		}\r\n		\r\n		if ((y > 1937 && y < 1945) || (y==1937 && m > 7) || (y==1937 && m==7 && d>=7) || (y==1945 && m < 8) || (y==1945 && m==8 && d<=14))\r\n		{\r\n			sum = day_diff (y, m, d, 1945, 8, 14) + 1 ;\r\n			printf (\"离抗战胜利还有%lld天\\n\",sum) ;\r\n			continue ;\r\n		}\r\n		\r\n		if ((y==1945 && m > 8 && m < 9) || (y==1945 && m==8 && d>=15)  || (y==1945 && m==9 && d<=2))\r\n		{\r\n			printf (\"全国欢庆胜利\\n\") ;\r\n			continue ;\r\n		}\r\n		\r\n		if (m > 9 || (m==9 && d>=3))\r\n		{\r\n			sum = day_diff (y, m, d, y+1, 9, 3) ;\r\n			printf (\"距离下一个纪念日还有%lld天\\n\", sum) ;\r\n			continue ;\r\n		}\r\n		\r\n		if (m < 9 || (m==9 && d<3))\r\n		{\r\n			sum = day_diff (y, m, d, y, 9, 3) ;\r\n			printf (\"距离下一个纪念日还有%lld天\\n\", sum) ;\r\n			continue ;\r\n		}\r\n	}\r\n\r\n	return 0 ;\r\n}'),(880,'#include<stdio.h>\r\nint f(int y,int m,int d)\r\n{\r\n	int ds[]={31,28,31,30,31,30,31,31,30,31,30,31};\r\n	int count=y/400*(400*365+97);\r\n	int i;\r\n	for(i=0;i<y%400;i++)\r\n		if(i%400==0||i%4==0&&i%100)\r\n			count+=366;\r\n		else \r\n			count+=365;\r\n	for(i=1;i<m;i++)\r\n		count+=ds[i-1];\r\n	count+=d;\r\n	if(m>2&&(y%400==0||y%4==0&&y%100))\r\n		count++;\r\n	return count;\r\n}\r\nint main()\r\n{  \r\n	int n;\r\n	scanf(\"%d\",&n);\r\n	while(n--)\r\n	{\r\n		int y,m,d;\r\n		scanf(\"%d%d%d\",&y,&m,&d);\r\n		if(y<1931||y==1931&&m<9||y==1931&&m==9&&d<18)\r\n			printf(\"鬼子还没来\\n\");\r\n		else if(y<1937||y==1937&&m<7||y==1937&&m==7&&d<7)\r\n			printf(\"抗战开始%d天\\n\",f(y,m,d)-f(1931,9,18));\r\n		else if(y<1945||y==1945&&m<8||y==1945&&m==7&&d<15)\r\n			printf(\"离抗战胜利还有%d天\\n\",f(1945,8,15)-f(y,m,d));\r\n		else if(y<1945||y==1945&&m<9||y==1945&&m==9&&d<3)\r\n			printf(\"全国欢庆胜利\\n\");\r\n		else \r\n			if(m>9 || m==9 && d>=3)\r\n				printf(\"距离下一个纪念日还有%d天\\n\",f(y+1,9,3)-f(y,m,d));\r\n			else\r\n				printf(\"距离下一个纪念日还有%d天\\n\",f(y,9,3)-f(y,m,d));\r\n	}\r\n	return 0;\r\n}'),(881,'#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int teams,questions;\r\n	int test;\r\n	int i;\r\n	\r\n	scanf(\"%d %d\",&teams,&questions);\r\n	\r\n	printf(\"%d %d\\n\",teams / 3 * 2 + teams % 3, teams / 3);\r\n	\r\n	for(i = 0; i < questions; ++i){\r\n		scanf(\"%d\",&test);\r\n		\r\n		if(test > 0 && test <= teams){\r\n			if(test % 3 == 0)\r\n			printf(\"同志们辛苦了\\n\");\r\n			else\r\n			printf(\"同志们好\\n\");\r\n		}else{\r\n			printf(\"队伍编号越界\\n\");\r\n		}\r\n	}\r\n	\r\n	return 0;\r\n}'),(882,'int main()\r\n{  \r\n	int m,n;\r\n	scanf(\"%d%d\",&m,&n);\r\n	printf(\"%d %d\\n\",m-m/3,m/3);\r\n	while(n--)\r\n	{\r\n		int x;\r\n		scanf(\"%d\",&x);\r\n		if(x<1||x>m)\r\n			printf(\"队伍编号越界\\n\");\r\n		else if(x%3)\r\n			printf(\"同志们好\\n\");\r\n		else\r\n			printf(\"同志们辛苦了\\n\");\r\n	}\r\n	return 0;\r\n}\r\n'),(883,'#include <cstdio>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <stack>\r\n#include <queue>\r\n#include <cmath>\r\n#include <string>\r\n#include <set>\r\n#include <map>\r\n#define maxn 0\r\n\r\nusing namespace std ;\r\n\r\nchar ans[5] ;\r\nchar lj[5] ;\r\nchar my[5] ;\r\n\r\nint main ()\r\n{\r\n	int n, m ;\r\n	int p, k ;\r\n	int sum ;\r\n	memset (ans, 0, sizeof(ans)) ;\r\n	\r\n	scanf (\"%d%s\", &n, ans) ;\r\n	\r\n	while (n--)\r\n	{\r\n		sum = 0 ;\r\n		scanf (\"%d\\n\", &m) ;\r\n		while (m--)\r\n		{\r\n			memset (my, 0, sizeof(my)) ;\r\n			memset (lj, 0, sizeof(lj)) ;\r\n			scanf (\"%s%d%d\", my, &p, &k) ;\r\n			my[3] = \'\\0\' ;\r\n			sum -= 2 * k ;\r\n			\r\n			if (p == 1)\r\n			{\r\n				if (my[0] == ans[0] && my[1] == ans[1] && my[2] == ans[2])\r\n					sum += 1040 * k ;\r\n			}\r\n			else if (p == 3)\r\n			{\r\n				strcpy (lj, my) ;\r\n				sort (lj, lj+3) ;\r\n				\r\n				while (next_permutation (lj, lj+3))\r\n				{\r\n					if (!strcmp (ans, lj))\r\n					{\r\n						sum += 346 * k ;\r\n						break ;\r\n					}\r\n				}\r\n			}\r\n			else if (p == 6)\r\n			{\r\n				strcpy (lj, my) ;\r\n				sort (lj, lj+3) ;\r\n				\r\n				while (next_permutation (lj, lj+3))\r\n				{\r\n					if (!strcmp (ans, lj))\r\n					{\r\n						sum += 173 * k ;\r\n						break ;\r\n					}\r\n				}\r\n			}\r\n		}\r\n		if (sum > 0)\r\n			printf (\"赚了%d元\\n\", sum) ;\r\n		else if (sum == 0)\r\n			printf (\"您浪费卖彩票的一张纸\\n\") ;\r\n		else\r\n			printf (\"您为了福利事业贡献%d元\\n\", -sum) ;\r\n	}\r\n\r\n	return 0 ;\r\n}'),(884,'#include<iostream>\r\n#include<cstdio>\r\n#include<algorithm>\r\n#include<cstring>\r\nusing namespace std;\r\n  \r\nint main()\r\n{\r\n    int  n;\r\n	char a[3],a1[3];\r\n	scanf(\"%d %c%c%c\",&n,a,a+1,a+2);\r\n	partial_sort_copy(a,a+3,a1,a1+3);\r\n	while(n--)\r\n	{\r\n		int m;\r\n		char b[4],b1[3];\r\n		int w;\r\n		int bs;\r\n		scanf(\"%d\",&m);\r\n		int count=0;\r\n		while(m--)\r\n		{\r\n		 scanf(\"%c%c%c%c %d %d\",b+3,b,b+1,b+2,&w,&bs);\r\n		 partial_sort_copy(b,b+3,b1,b1+3);\r\n		 count-=bs*2;\r\n		 if(w==1&&strncmp(a,b,3)==0) count+=1040*bs;\r\n		 if(w==3&&strncmp(a1,b1,3)==0) count+=346*bs;\r\n		 if(w==6&&strncmp(a1,b1,3)==0) count+=173*bs;\r\n		}\r\n		if(count<0)\r\n			cout<<\"您为了福利事业贡献\"<<-count<<\"元\"<<endl;\r\n		else if(count==0)\r\n          cout<<\"您浪费卖彩票的一张纸\"<<endl;\r\n         else cout<<\"赚了\"<<count<<\"元\"<<endl;\r\n\r\n\r\n	}\r\n\r\n}\r\n\r\n/*\r\n_CRTIMP char * __cdecl asctime(const struct tm *);\r\n_CRTIMP char * __cdecl ctime(const time_t *);\r\n_CRTIMP clock_t __cdecl clock(void);\r\n_CRTIMP double __cdecl difftime(time_t, time_t);\r\n_CRTIMP struct tm * __cdecl gmtime(const time_t *);\r\n_CRTIMP struct tm * __cdecl localtime(const time_t *);\r\n_CRTIMP time_t __cdecl mktime(struct tm *);\r\n_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,\r\n        const struct tm *);\r\n_CRTIMP char * __cdecl _strdate(char *);\r\n_CRTIMP char * __cdecl _strtime(char *);\r\n_CRTIMP time_t __cdecl time(time_t *);\r\n\r\n  */'),(885,'#include<iostream>\r\nusing namespace std;\r\nvoid f(int a,int b)\r\n{\r\n   bool f=0;\r\n   do\r\n   {\r\n	  int c=b/a+1;\r\n	  if(f) printf(\" %d\",c);\r\n	  else {f=1;printf(\"%d\",c);}\r\n	  a=c*a-b;\r\n	  b*=c;\r\n   }while(b%a);\r\n   printf(\" %d\\n\",b/a);\r\n}\r\nint main()\r\n{\r\n	int a,b;\r\n	while(1)\r\n	{\r\n		cin>>a>>b;\r\n		if(a==0&&b==0)break;\r\n		f(a,b);\r\n	}\r\n}'),(886,'#include<stdio.h>\r\nint main()\r\n{\r\n\r\n	int a,b,c;\r\n	while(scanf(\"%d %d\",&a,&b)&&(a!=0||b!=0))\r\n	{\r\n		while(1)\r\n		{\r\n			c=b/a+1;\r\n			printf(\"%d \",c);\r\n			a=a*c-b;\r\n			b=b*c;\r\n			if(b%a==0)\r\n			{\r\n				printf(\"%d\\n\",b/a);\r\n				break;\r\n			}\r\n		}\r\n	}	\r\n}'),(887,'#include<cstdio>\r\n#include<cmath>\r\n \r\ndouble ca(double d,double x,double y)\r\n{\r\n	//printf(\"%lf %lf ,%lf \",d,x,y);\r\n	if(x>=0&&x<=d) return fabs(y);\r\n	else \r\n	 if(x<0)\r\n	     return sqrt(x*x+y*y);\r\n	 else\r\n		 return sqrt((d-x)*(d-x)+y*y);  \r\n}\r\nint main()\r\n{\r\n   double a,b,c,d,e,f;\r\n   while(scanf(\"%lf%lf%lf%lf%lf%lf\",&a,&b,&c,&d,&e,&f)!=-1)\r\n   {\r\n	   if(a==0&&b==0&&c==0&&d==0&&e==0&&f==0)\r\n		   break;\r\n	   double dis=sqrt((a-c)*(a-c)+(b-d)*(b-d));\r\n	   double thita;\r\n	   if(a==c)\r\n		   if(d>b) thita= -3.1415926/2;\r\n		   else thita=3.1415926/2;\r\n	   else thita = -atan((d-b)/(c-a));	\r\n	   if(a>c) thita= thita-3.1415926;\r\n		    \r\n	  // printf(\"%lf,\",thita);\r\n	   e-=a;f-=b;\r\n	   double x=e*cos(thita)-f*sin(thita);\r\n       double y=f*cos(thita)+e*sin(thita);\r\n	   printf(\"%.2lf\\n\",ca(dis,x,y));\r\n\r\n   }\r\n}'),(888,'#include<stdio.h>\r\n#include<math.h>\r\ndouble ca(double d,double x,double y)\r\n{\r\n    if(x>=0&&x<=d) return fabs(y);\r\n    else\r\n     if(x<0)\r\n         return sqrt(x*x+y*y);\r\n     else\r\n         return sqrt((d-x)*(d-x)+y*y);  \r\n}\r\nint main()\r\n{\r\n   double a,b,c,d,e,f;\r\n   while(scanf(\"%lf%lf%lf%lf%lf%lf\",&a,&b,&c,&d,&e,&f))\r\n   {  \r\n	   double dis,thita;\r\n	   double x,y;\r\n       if(a==0&&b==0&&c==0&&d==0&&e==0&&f==0)\r\n           break;\r\n       dis=sqrt((a-c)*(a-c)+(b-d)*(b-d));\r\n       if(a==c)\r\n           if(d>b) thita= -3.1415926/2;\r\n           else thita=3.1415926/2;\r\n       else thita = -atan((d-b)/(c-a));\r\n       if(a>c) thita= thita-3.1415926;\r\n	   e-=a;f-=b;\r\n       x=e*cos(thita)-f*sin(thita);\r\n       y=f*cos(thita)+e*sin(thita);\r\n       printf(\"%.2lf\\n\",ca(dis,x,y));\r\n   }\r\n   return 0;\r\n}'),(889,'#include <cstdio>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <algorithm>\r\n#include <stack>\r\n#include <queue>\r\n#include <cmath>\r\n#include <string>\r\n#include <set>\r\n#include <map>\r\n#define maxn 0\r\n\r\nusing namespace std ;\r\n\r\nint stu[105][1005] ;\r\nint mm[105] ;\r\nint pro[1005] ;\r\nint ans[1005] ;\r\n\r\nint main ()\r\n{\r\n	int m, n, p, t, k ;\r\n	memset (stu, false, sizeof(stu));\r\n	memset (mm, 0, sizeof(mm))	 ;\r\n	\r\n	scanf (\"%d%d\", &m, &n) ;\r\n	for (int i=1; i<=m; i++)\r\n	{\r\n		scanf (\"%d\", &mm[i]) ;\r\n		for (int j=0; j<mm[i]; j++)\r\n		{\r\n			scanf (\"%d\", &p) ;\r\n			stu[i][j] = p ;\r\n		}\r\n	}\r\n	\r\n	for (int i=0; i<n; i++)\r\n	{\r\n		k = t = 0 ;\r\n		memset (pro, 0, sizeof(pro)) ;\r\n		memset (ans, 0, sizeof(ans)) ;\r\n		\r\n		while (scanf(\"%d\", &p) != EOF && p)\r\n		{\r\n			t++ ;\r\n			for (int j=0; j<mm[p]; j++)\r\n				pro[stu[p][j]]++ ;\r\n		}\r\n		\r\n		for (int j=0; j<1000; j++)\r\n		{\r\n			if (pro[j] == t)\r\n				ans[k++] = j ;\r\n		}\r\n		\r\n		if (k == 0)\r\n		{\r\n			printf (\"NULL\\n\") ;\r\n			continue ;\r\n		}\r\n		\r\n		sort (ans, ans+k) ;\r\n		\r\n		int j ;\r\n		for (j=0; j<k-1; j++)\r\n			printf (\"%d \", ans[j]) ;\r\n		printf (\"%d\\n\", ans[j]) ;\r\n	}\r\n\r\n	return 0 ;\r\n}'),(890,'#include<iostream>\r\n#include<algorithm>\r\n#include<fstream>\r\nusing namespace std;\r\n int main()\r\n {  //ofstream cout(\"d://3.txt\");\r\n    int m,n;\r\n	int a[101][100];\r\n	int len[101]={0};\r\n	cin>>m>>n;\r\n    int i=1;\r\n	for(;i<=m;i++)\r\n	{\r\n		cin>>len[i];\r\n		for(int j=0;j<len[i];j++)\r\n			cin>>a[i][j];\r\n		sort(a[i],a[i]+len[i]);\r\n	}\r\n    while(n--)\r\n	{\r\n		int aa[100];\r\n		int bb[100];\r\n		int cc[100];\r\n		int la=-1;\r\n		int lb=0;\r\n		int lc=0;\r\n		int t;\r\n		cin>>t;\r\n		while(t)\r\n		{\r\n			if(la==-1)\r\n			{ la=len[t];\r\n			  memcpy(aa,a[t],sizeof(aa));\r\n			}\r\n			else\r\n			{\r\n			  lb=len[t];\r\n			  memcpy(bb,a[t],sizeof(bb));\r\n			  lc=set_intersection(aa,aa+la,bb,bb+lb,cc)-cc;\r\n			  la=lc; \r\n			  memcpy(aa,cc,sizeof(aa));\r\n			}\r\n			cin>>t;\r\n		}\r\n		if(la==0)cout<<\"NULL\"<<endl;\r\n		else\r\n		{  int i;\r\n			for(  i=0;i<la-1;i++)\r\n				cout<<aa[i]<<\" \";\r\n			cout<<aa[i]<<endl;\r\n		}\r\n			\r\n	}\r\n\r\n\r\n\r\n }\r\n '),(891,'#include<stdio.h>\r\n //解题思路 无\r\n// 考核点：字符串查找，字符串读入、拆分\r\n//  QQ炫舞\r\n\r\n//此函数返回b串在a串中的位置，a中五b串返回-1\r\nint find(const char * a,const char * b)\r\n{\r\n	int la=strlen(a);\r\n	int lb=strlen(b);\r\n	int i=0;\r\n	for(;i<=la-lb;i++)\r\n		if(strncmp(a+i,b,lb)==0)return i;\r\n	return -1;\r\n}\r\n//函数split完成字符串a到字符串数组aa的拆分（拆分为多个字符串）\r\n//返回值表示拆分出的个数，即数组长度\r\n//参数c表示拆分依据的分隔符号，此题正确键的串是空格，小薇的是|\r\nint split(const char*a,char aa[][100],char c)\r\n{\r\n	int first=0,last=0;\r\n	int count=0;\r\n	while(a[last])\r\n	{\r\n		if(a[last]==c) \r\n		{\r\n			if(first<=last)\r\n			{\r\n			  strncpy(aa[count],a+first,last-first);\r\n			  *(aa[count++]+last-first)=0;//写\\0\r\n			  first=last+1;\r\n			  while(a[first]&&a[first]==c)first++;//寻找下一段的开始\r\n			}\r\n		}\r\n		last++;\r\n	}\r\n	if(first<last)\r\n	{\r\n		strncpy(aa[count],a+first,last-first);\r\n		*(aa[count++]+last-first)=0;//写\\0\r\n	 }\r\n	return count;    \r\n}\r\n\r\n \r\n //函数f完成处理，并输出结果\r\nvoid f(const char * a,const char *b)\r\n{\r\n    char aa[100][100];\r\n	char bb[100][100];\r\n	int laa,lbb;\r\n     int ii=0,jj=0;\r\n	 int count=0;\r\n    laa=split(a,aa,\' \');\r\n	if(aa[0][0]==0)//此处我做的split在开头就是分隔符情况下，会多弄出一个空串\r\n		              //这对于 正确键的序列不适用，需要舍弃\r\n		ii++;\r\n    lbb=split(b,bb,\'|\');\r\n \r\n    for( ;ii<laa&&jj<lbb;ii++,jj++)\r\n    {\r\n        if(find(bb[jj],aa[ii])!=-1)\r\n		count+=strlen(aa[ii]);\r\n    }\r\n    printf(\"%d\\n\",count*10); \r\n} \r\n \r\n int main()\r\n {   \r\n     int n;\r\n	 char a[1000],b[1000];\r\n     scanf(\"%d\",&n);     \r\n     while(n--)\r\n     {\r\n         gets(a);//先读前面的换行符\r\n         gets(a);//读正确键\r\n		 gets(b);//读小薇键\r\n         f(a,b);\r\n     }\r\n \r\n	\r\n }\r\n'),(892,'#include<iostream>\r\n#include<algorithm>\r\n#include<fstream>\r\n#include<sstream>\r\nusing namespace std;\r\nvoid f(char * a,char *b)\r\n{\r\n	string sa=a;\r\n	string sb=b;\r\n	int count=0;\r\n	char aa[1000][100],bb[1000][100];\r\n	int i=0,j=0;\r\n	istringstream ina(sa);\r\n	istringstream inb(sb);\r\n	while(ina.getline(aa[i++],100,\' \'));\r\n	while(inb.getline(bb[j++],100,\'|\'));\r\n	for(int ii=0,jj=0;ii<i&&jj<j;ii++,jj++)\r\n	{\r\n		string ta=aa[ii];\r\n		string tb=bb[ii];\r\n		if(tb.find(ta)!=string::npos)\r\n			count+=ta.length();\r\n	}\r\n	cout<<count*10<<endl;\r\n	 \r\n\r\n\r\n}\r\n int main()\r\n {  //ofstream cout(\"d://3.txt\");\r\n     int n;\r\n	 cin>>n;\r\n	 char a[1000],b[1000];\r\n	 while(n--)\r\n	 {\r\n		 cin.getline(a,1000);\r\n		 cin.getline(a,1000); \r\n		 cin.getline(b,1000);\r\n		 f(a,b);\r\n	 }\r\n\r\n }\r\n ');
/*!40000 ALTER TABLE `source_code_new` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2015-11-08 11:15:41
